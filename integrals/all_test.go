// Copyright 2019 Infin IT Pty Ltd. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package misc_test

import (
	. "github.com/dreading/gospecfunc/integrals"
	"testing"
)

func TestAbramowitz0(t *testing.T) {
	testCases := []struct {
		num, den, res float64
	}{
		{1.0e0, 512.0e0, 0.87377726306985360531e0},
		{1.0e0, 128.0e0, 0.84721859650456925922e0},
		{1.0e0, 32.0e0, 0.77288934483988301615e0},
		{1.0e0, 8.0e0, 0.59684345853450151603e0},
		{1.0e0, 2.0e0, 0.29871735283675888392e0},
		{1.0e0, 1.0e0, 0.15004596450516388138e0},
		{5.0e0, 4.0e0, 0.11114662419157955096e0},
		{3.0e0, 2.0e0, 0.83909567153151897766e-1},
		{15.0e0, 8.0e0, 0.56552321717943417515e-1},
		{2.0e0, 1.0e0, 0.49876496603033790206e-1},
		{17.0e0, 8.0e0, 0.44100889219762791328e-1},
		{3.0e0, 1.0e0, 0.19738535180254062496e-1},
		{4.0e0, 1.0e0, 0.86193088287161479900e-2},
		{5.0e0, 1.0e0, 0.40224788162540127227e-2},
		{6.0e0, 1.0e0, 0.19718658458164884826e-2},
		{7.0e0, 1.0e0, 0.10045868340133538505e-2},
		{10.0e0, 1.0e0, 0.15726917263304498649e-3},
		{15.0e0, 1.0e0, 0.10352666912350263437e-4},
		{20.0e0, 1.0e0, 0.91229759190956745069e-6},
		{40.0e0, 1.0e0, 0.25628287737952698742e-9},
	}

	for _, tc := range testCases {
		ζ := Abramowitz0(tc.num / tc.den)
		if close(ζ, tc.res) == false {
			t.Fatalf("Abramowitz0(%v): expected %v, got %v", tc.num/tc.den, tc.res, ζ)
		}

	}
}

func TestAbramowitz1(t *testing.T) {
	testCases := []struct {
		num, den, res float64
	}{
		{1.0e0, 512.0e0, 0.49828219848799921792e0},
		{1.0e0, 128.0e0, 0.49324391773047288556e0},
		{1.0e0, 32.0e0, 0.47431612784691234649e0},
		{1.0e0, 8.0e0, 0.41095983258760410149e0},
		{1.0e0, 2.0e0, 0.25317617388227035867e0},
		{1.0e0, 1.0e0, 0.14656338138597777543e0},
		{5.0e0, 4.0e0, 0.11421547056018366587e0},
		{3.0e0, 2.0e0, 0.90026307383483764795e-1},
		{15.0e0, 8.0e0, 0.64088214170742303375e-1},
		{2.0e0, 1.0e0, 0.57446614314166191085e-1},
		{17.0e0, 8.0e0, 0.51581624564800730959e-1},
		{3.0e0, 1.0e0, 0.25263719555776416016e-1},
		{4.0e0, 1.0e0, 0.11930803330196594536e-1},
		{5.0e0, 1.0e0, 0.59270542280915272465e-2},
		{6.0e0, 1.0e0, 0.30609215358017829567e-2},
		{7.0e0, 1.0e0, 0.16307382136979552833e-2},
		{10.0e0, 1.0e0, 0.28371851916959455295e-3},
		{15.0e0, 1.0e0, 0.21122150121323238154e-4},
		{20.0e0, 1.0e0, 0.20344578892601627337e-5},
		{40.0e0, 1.0e0, 0.71116517236209642290e-9},
	}

	for _, tc := range testCases {
		ζ := Abramowitz1(tc.num / tc.den)
		if close(ζ, tc.res) == false {
			t.Fatalf("Abramowitz1(%v): expected %v, got %v", tc.num/tc.den, tc.res, ζ)
		}

	}
}

func TestAbramowitz2(t *testing.T) {
	testCases := []struct {
		num, den, res float64
	}{
		{1.0e0, 512.0e0, 0.44213858162107913430e0},
		{1.0e0, 128.0e0, 0.43923379545684026308e0},
		{1.0e0, 32.0e0, 0.42789857297092602234e0},
		{1.0e0, 8.0e0, 0.38652825661854504406e0},
		{1.0e0, 2.0e0, 0.26538204413231368110e0},
		{1.0e0, 1.0e0, 0.16848734838334595000e0},
		{5.0e0, 4.0e0, 0.13609200032513227112e0},
		{3.0e0, 2.0e0, 0.11070330027727917352e0},
		{15.0e0, 8.0e0, 0.82126019995530382267e-1},
		{2.0e0, 1.0e0, 0.74538781999594581763e-1},
		{17.0e0, 8.0e0, 0.67732034377612811390e-1},
		{3.0e0, 1.0e0, 0.35641808698811851022e-1},
		{4.0e0, 1.0e0, 0.17956589956618269083e-1},
		{5.0e0, 1.0e0, 0.94058737143575370625e-2},
		{6.0e0, 1.0e0, 0.50809356204299213556e-2},
		{7.0e0, 1.0e0, 0.28149565414209719359e-2},
		{10.0e0, 1.0e0, 0.53808696422559303431e-3},
		{15.0e0, 1.0e0, 0.44821756380146327259e-4},
		{20.0e0, 1.0e0, 0.46890678427324100410e-5},
		{40.0e0, 1.0e0, 0.20161544850996420504e-8},
	}

	for _, tc := range testCases {
		ζ := Abramowitz2(tc.num / tc.den)
		if close(ζ, tc.res) == false {
			t.Fatalf("Abramowitz2(%v): expected %v, got %v", tc.num/tc.den, tc.res, ζ)
		}

	}
}

func TestClausen(t *testing.T) {
	testCases := []struct {
		num, den, res float64
	}{
		{1.0e0, 512.0e0, 0.14137352886760576684e-1},
		{1.0e0, 32.0e0, 0.13955467081981281934e0},
		{-1.0e0, 8.0e0, -0.38495732156574238507e0},
		{1.0e0, 2.0e0, 0.84831187770367927099e0},
		{1.0e0, 1.0e0, 0.10139591323607685043e1},
		{-3.0e0, 2.0e0, -0.93921859275409211003e0},
		{2.0e0, 1.0e0, 0.72714605086327924743e0},
		{5.0e0, 2.0e0, 0.43359820323553277936e0},
		{-3.0e0, 1.0e0, -0.98026209391301421161e-1},
		{4.0e0, 1.0e0, -0.56814394442986978080e0},
		{17.0e0, 4.0e0, -0.70969701784448921625e0},
		{-5.0e0, 1.0e0, 0.99282013254695671871e0},
		{11.0e0, 2.0e0, -0.98127747477447367875e0},
		{6.0e0, 1.0e0, -0.64078266570172320959e0},
		{8.0e0, 1.0e0, 0.86027963733231192456e0},
		{-10.0e0, 1.0e0, 0.39071647608680211043e0},
		{15.0e0, 1.0e0, 0.47574793926539191502e0},
		{20.0e0, 1.0e0, 0.10105014481412878253e1},
		{-30.0e0, 1.0e0, 0.96332089044363075154e0},
		{50.0e0, 1.0e0, -0.61782699481929311757e0},
	}

	for _, tc := range testCases {
		ζ := Clausen(tc.num / tc.den)
		if close(ζ, tc.res) == false {
			t.Fatalf("Clausen(%v): expected %v, got %v", tc.num/tc.den, tc.res, ζ)
		}

	}
}

func TestDebye1(t *testing.T) {
	testCases := []struct {
		num, den, res float64
	}{
		{1.0e0, 512.0e0, 0.99951182471380889183e0},
		{1.0e0, 32.0e0, 0.99221462647120597836e0},
		{1.0e0, 8.0e0, 0.96918395997895308324e0},
		{1.0e0, 2.0e0, 0.88192715679060552968e0},
		{1.0e0, 1.0e0, 0.77750463411224827642e0},
		{3.0e0, 2.0e0, 0.68614531078940204342e0},
		{2.0e0, 1.0e0, 0.60694728460981007205e0},
		{5.0e0, 2.0e0, 0.53878956907785587703e0},
		{3.0e0, 1.0e0, 0.48043521957304283829e0},
		{4.0e0, 1.0e0, 0.38814802129793784501e0},
		{17.0e0, 4.0e0, 0.36930802829242526815e0},
		{5.0e0, 1.0e0, 0.32087619770014612104e0},
		{11.0e0, 2.0e0, 0.29423996623154246701e0},
		{6.0e0, 1.0e0, 0.27126046678502189985e0},
		{8.0e0, 1.0e0, 0.20523930310221503723e0},
		{10.0e0, 1.0e0, 0.16444346567994602563e0},
		{15.0e0, 1.0e0, 0.10966194482735821276e0},
		{20.0e0, 1.0e0, 0.82246701178200016086e-1},
		{30.0e0, 1.0e0, 0.54831135561510852445e-1},
		{50.0e0, 1.0e0, 0.32898681336964528729e-1},
	}

	for _, tc := range testCases {
		ζ := Debye1(tc.num / tc.den)
		if close(ζ, tc.res) == false {
			t.Fatalf("Debye1(%v): expected %v, got %v", tc.num/tc.den, tc.res, ζ)
		}

	}
}

func TestDebye2(t *testing.T) {
	testCases := []struct {
		num, den, res float64
	}{
		{1.0e0, 512.0e0, 0.9993491172790459973830},
		{1.0e0, 32.0e0, 0.98962402299599181205e0},
		{1.0e0, 8.0e0, 0.95898426200345986743e0},
		{1.0e0, 2.0e0, 0.84372119334725358934e0},
		{1.0e0, 1.0e0, 0.70787847562782928288e0},
		{3.0e0, 2.0e0, 0.59149637225671282917e0},
		{2.0e0, 1.0e0, 0.49308264399053185014e0},
		{5.0e0, 2.0e0, 0.41079413579749669069e0},
		{3.0e0, 1.0e0, 0.34261396060786351671e0},
		{4.0e0, 1.0e0, 0.24055368752127897660e0},
		{17.0e0, 4.0e0, 0.22082770061202308232e0},
		{5.0e0, 1.0e0, 0.17232915939014138975e0},
		{11.0e0, 2.0e0, 0.14724346738730182894e0},
		{6.0e0, 1.0e0, 0.12666919046715789982e0},
		{8.0e0, 1.0e0, 0.74268805954862854626e-1},
		{10.0e0, 1.0e0, 0.47971498020121871622e-1},
		{15.0e0, 1.0e0, 0.21369201683658373846e-1},
		{20.0e0, 1.0e0, 0.12020564476446432799e-1},
		{30.0e0, 1.0e0, 0.53424751249537071952e-2},
		{50.0e0, 1.0e0, 0.19232910450553508562e-2},
	}

	for _, tc := range testCases {
		ζ := Debye2(tc.num / tc.den)
		if close(ζ, tc.res) == false {
			t.Fatalf("Debye2(%v): expected %v, got %v", tc.num/tc.den, tc.res, ζ)
		}

	}
}

func TestDebye3(t *testing.T) {
	testCases := []struct {
		num, den, res float64
	}{
		{1.0e0, 512.0e0, 0.99926776885985461940e0},
		{1.0e0, 32.0e0, 0.98833007755734698212e0},
		{1.0e0, 8.0e0, 0.95390610472023510237e0},
		{1.0e0, 2.0e0, 0.82496296897623372315e0},
		{1.0e0, 1.0e0, 0.67441556407781468010e0},
		{3.0e0, 2.0e0, 0.54710665141286285468e0},
		{2.0e0, 1.0e0, 0.44112847372762418113e0},
		{5.0e0, 2.0e0, 0.35413603481042394211e0},
		{3.0e0, 1.0e0, 0.28357982814342246206e0},
		{4.0e0, 1.0e0, 0.18173691382177474795e0},
		{17.0e0, 4.0e0, 0.16277924385112436877e0},
		{5.0e0, 1.0e0, 0.11759741179993396450e0},
		{11.0e0, 2.0e0, 0.95240802723158889887e-1},
		{6.0e0, 1.0e0, 0.77581324733763020269e-1},
		{8.0e0, 1.0e0, 0.36560295673194845002e-1},
		{10.0e0, 1.0e0, 0.19295765690345489563e-1},
		{15.0e0, 1.0e0, 0.57712632276188798621e-2},
		{20.0e0, 1.0e0, 0.24352200674805479827e-2},
		{30.0e0, 1.0e0, 0.72154882216335666096e-3},
		{50.0e0, 1.0e0, 0.15585454565440389896e-3},
	}

	for _, tc := range testCases {
		ζ := Debye3(tc.num / tc.den)
		if close(ζ, tc.res) == false {
			t.Fatalf("Debye3(%v): expected %v, got %v", tc.num/tc.den, tc.res, ζ)
		}

	}
}

func TestDebye4(t *testing.T) {
	testCases := []struct {
		num, den, res float64
	}{
		{1.0e0, 512.0e0, 0.99921896192761576256e0},
		{1.0e0, 32.0e0, 0.98755425280996071022e0},
		{1.0e0, 8.0e0, 0.95086788606389739976e0},
		{1.0e0, 2.0e0, 0.81384569172034042516e0},
		{1.0e0, 1.0e0, 0.65487406888673697092e0},
		{3.0e0, 2.0e0, 0.52162830964878715188e0},
		{2.0e0, 1.0e0, 0.41189273671788528876e0},
		{5.0e0, 2.0e0, 0.32295434858707304628e0},
		{3.0e0, 1.0e0, 0.25187863642883314410e0},
		{4.0e0, 1.0e0, 0.15185461258672022043e0},
		{17.0e0, 4.0e0, 0.13372661145921413299e0},
		{5.0e0, 1.0e0, 0.91471377664481164749e-1},
		{11.0e0, 2.0e0, 0.71227828197462523663e-1},
		{6.0e0, 1.0e0, 0.55676547822738862783e-1},
		{8.0e0, 1.0e0, 0.21967566525574960096e-1},
		{10.0e0, 1.0e0, 0.96736755602711590082e-2},
		{15.0e0, 1.0e0, 0.19646978158351837850e-2},
		{20.0e0, 1.0e0, 0.62214648623965450200e-3},
		{30.0e0, 1.0e0, 0.12289514092077854510e-3},
		{50.0e0, 1.0e0, 0.15927210319002161231e-4},
	}

	for _, tc := range testCases {
		ζ := Debye4(tc.num / tc.den)
		if close(ζ, tc.res) == false {
			t.Fatalf("Debye4(%v): expected %v, got %v", tc.num/tc.den, tc.res, ζ)
		}

	}
}

// The floating point comparison tests are copied from from math/all_test.go.
func tolerance(a, b, e float64) bool {
	// Multiplying by e here can underflow denormal values to zero.
	// Check a==b so that at least if a and b are small and identical
	// we say they match.
	if a == b {
		return true
	}
	d := a - b
	if d < 0 {
		d = -d
	}
	// note: b is correct (expected) value, a is actual value.
	// make error tolerance a fraction of b, not a.
	if b != 0 {
		e = e * b
		if e < 0 {
			e = -e
		}
	}
	return d < e
}

func close(a, b float64) bool      { return tolerance(a, b, 1e-14) }
func veryclose(a, b float64) bool  { return tolerance(a, b, 5e-16) }
func soclose(a, b, e float64) bool { return tolerance(a, b, e) }
