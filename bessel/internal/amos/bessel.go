// Copyright 2019 Infin IT Pty Ltd. All rights reserved.
//
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//
// The original Fortran code are from
//  ALGORITHM 644, TRANSACTIONS ON MATHEMATICAL SOFTWARE,
//	VOL. 21, NO. 4, December, 1995, P.  388--393.
//  AMOS, DONALD E., SANDIA NATIONAL LABORATORIES

package amos

import (
	"github.com/dreading/gospecfunc/machine"
	"math"
)

// ZBESH COMPUTE THE HANKEL FUNCTION OF A COMPLEX ARGUMENT
//
// FOR KODE=1 COMPUTES AN N MEMBER SEQUENCE OF COMPLEX
// HANKEL (BESSEL) FUNCTIONS CY(J)=H(M,FNU+J-1,Z) FOR KINDS M=1
// OR 2, REAL, NONNEGATIVE ORDERS FNU+J-1, J=1,...,N, AND COMPLEX
// Z != CMPLX(0.0,0.0) IN THE CUT PLANE -PI < ARG(Z) <=  PI.
// ON KODE=2, ZBESH RETURNS THE SCALED HANKEL FUNCTIONS
//
// CY(I)=EXP(-MM*Z*I)*H(M,FNU+J-1,Z)       MM=3-2*M,   I**2=-1.
//
// WHICH REMOVES THE EXPONENTIAL BEHAVIOR IN BOTH THE UPPER AND
// LOWER HALF PLANES. DEFINITIONS AND NOTATION ARE FOUND IN THE
// NBS HANDBOOK OF MATHEMATICAL FUNCTIONS (REF. 1).
//
// INPUT      ZR,ZI,FNU ARE DOUBLE PRECISION
//   ZR,ZI  - Z=CMPLX(ZR,ZI), Z != CMPLX(0.0e0,0.0e0),
//            -PT < ARG(Z) <=  PI
//   FNU    - ORDER OF INITIAL H FUNCTION, FNU >= 0.0e0
//   KODE   - A PARAMETER TO INDICATE THE SCALING OPTION
//            KODE= 1  RETURNS
//                     CY(J)=H(M,FNU+J-1,Z),   J=1,...,N
//                = 2  RETURNS
//                     CY(J)=H(M,FNU+J-1,Z)*EXP(-I*Z*(3-2M))
//                          J=1,...,N  ,  I**2=-1
//   M      - KIND OF HANKEL FUNCTION, M=1 OR 2
//   N      - NUMBER OF MEMBERS IN THE SEQUENCE, N >= 1
//
// OUTPUT     CYR,CYI ARE DOUBLE PRECISION
//   CYR,CYI- DOUBLE PRECISION VECTORS WHOSE FIRST N COMPONENTS
//            CONTAIN REAL AND IMAGINARY PARTS FOR THE SEQUENCE
//            CY(J)=H(M,FNU+J-1,Z)  OR
//            CY(J)=H(M,FNU+J-1,Z)*EXP(-I*Z*(3-2M))  J=1,...,N
//            DEPENDING ON KODE, I**2=-1.
//   NZ     - NUMBER OF COMPONENTS SET TO ZERO DUE TO UNDERFLOW,
//            NZ= 0   , NORMAL RETURN
//            NZ > 0 , FIRST NZ COMPONENTS OF CY SET TO ZERO DUE
//                      TO UNDERFLOW, CY(J)=CMPLX(0.0e0,0.0e0)
//                      J=1,...,NZ WHEN Y > 0.0 AND M=1 OR
//                      Y < 0.0 AND M=2. FOR THE COMPLMENTARY
//                      HALF PLANES, NZ STATES ONLY THE NUMBER
//                      OF UNDERFLOWS.
//   IERR   - ERROR FLAG
//            IERR=0, NORMAL RETURN - COMPUTATION COMPLETED
//            IERR=1, INPUT ERROR   - NO COMPUTATION
//            IERR=2, OVERFLOW      - NO COMPUTATION, FNU TOO
//                    LARGE OR CABS(Z) TOO SMALL OR BOTH
//            IERR=3, CABS(Z) OR FNU+N-1 LARGE - COMPUTATION DONE
//                    BUT LOSSES OF SIGNIFCANCE BY ARGUMENT
//                    REDUCTION PRODUCE LESS THAN HALF OF MACHINE
//                    ACCURACY
//            IERR=4, CABS(Z) OR FNU+N-1 TOO LARGE - NO COMPUTA-
//                    TION BECAUSE OF COMPLETE LOSSES OF SIGNIFI-
//                    CANCE BY ARGUMENT REDUCTION
//            IERR=5, ERROR              - NO COMPUTATION,
//                    ALGORITHM TERMINATION CONDITION NOT MET
func ZBESH(ZR float64, ZI float64, FNU float64, KODE int, M int, N int, CYR []float64, CYI []float64, NZ int, IERR int) (float64, float64, float64, int, int, int, []float64, []float64, int, int) {

	// THE COMPUTATION IS CARRIED OUT BY THE RELATION
	//
	// H(M,FNU,Z)=(1/MP)*EXP(-MP*FNU)*K(FNU,Z*EXP(-MP))
	//     MP=MM*HPI*I,  MM=3-2*M,  HPI=PI/2,  I**2=-1
	//
	// FOR M=1 OR 2 WHERE THE K BESSEL FUNCTION IS COMPUTED FOR THE
	// RIGHT HALF PLANE RE(Z) >= 0.0. THE K FUNCTION IS CONTINUED
	// TO THE LEFT HALF PLANE BY THE RELATION
	//
	// K(FNU,Z*EXP(MP)) = EXP(-MP*FNU)*K(FNU,Z)-MP*I(FNU,Z)
	// MP=MR*PI*I, MR=+1 OR -1, RE(Z) > 0, I**2=-1
	//
	// WHERE I(FNU,Z) IS THE I BESSEL FUNCTION.
	//
	// EXPONENTIAL DECAY OF H(M,FNU,Z) OCCURS IN THE UPPER HALF Z
	// PLANE FOR M=1 AND THE LOWER HALF Z PLANE FOR M=2.  EXPONENTIAL
	// GROWTH OCCURS IN THE COMPLEMENTARY HALF PLANES.  SCALING
	// BY EXP(-MM*Z*I) REMOVES THE EXPONENTIAL BEHAVIOR IN THE
	// WHOLE Z PLANE FOR Z TO INFINITY.
	//
	// FOR NEGATIVE ORDERS,THE FORMULAE
	//
	//       H(1,-FNU,Z) = H(1,FNU,Z)*CEXP( PI*FNU*I)
	//       H(2,-FNU,Z) = H(2,FNU,Z)*CEXP(-PI*FNU*I)
	//                 I**2=-1
	// CAN BE USED.
	//
	// IN MOST COMPLEX VARIABLE COMPUTATION, ONE MUST EVALUATE ELE-
	// MENTARY FUNCTIONS. WHEN THE MAGNITUDE OF Z OR FNU+N-1 IS
	// LARGE, LOSSES OF SIGNIFICANCE BY ARGUMENT REDUCTION OCCUR.
	// CONSEQUENTLY, IF EITHER ONE EXCEEDS U1=SQRT(0.5/UR), THEN
	// LOSSES EXCEEDING HALF PRECISION ARE LIKELY AND AN ERROR FLAG
	// IERR=3 IS TRIGGERED WHERE UR=math.Max(machine.D1MACH[4),1.0e-18) IS
	// DOUBLE PRECISION UNIT ROUNDOFF LIMITED TO 18 DIGITS PRECISION.
	// IF EITHER IS LARGER THAN U2=0.5/UR, THEN ALL SIGNIFICANCE IS
	// LOST AND IERR=4. IN ORDER TO USE THE INT FUNCTION, ARGUMENTS
	// MUST BE FURTHER RESTRICTED NOT TO EXCEED THE LARGEST MACHINE
	// INTEGER, U3=machine.I1MACH[9). THUS, THE MAGNITUDE OF Z AND FNU+N-1 IS
	// RESTRICTED BY MIN(U2,U3). ON 32 BIT MACHINES, U1,U2, AND U3
	// ARE APPROXIMATELY 2.0E+3, 4.2E+6, 2.1E+9 IN SINGLE PRECISION
	// ARITHMETIC AND 1.3E+8, 1.8E+16, 2.1E+9 IN DOUBLE PRECISION
	// ARITHMETIC RESPECTIVELY. THIS MAKES U2 AND U3 LIMITING IN
	// THEIR RESPECTIVE ARITHMETICS. THIS MEANS THAT ONE CAN EXPECT
	// TO RETAIN, IN THE WORST CASES ON 32 BIT MACHINES, NO DIGITS
	// IN SINGLE AND ONLY 7 DIGITS IN DOUBLE PRECISION ARITHMETIC.
	// SIMILAR CONSIDERATIONS HOLD FOR OTHER MACHINES.
	//
	// THE APPROXIMATE RELATIVE ERROR IN THE MAGNITUDE OF A COMPLEX
	// BESSEL FUNCTION CAN BE EXPRESSED BY P*10**S WHERE P=MAX(UNIT
	// ROUNDOFF,1.0e-18) IS THE NOMINAL PRECISION AND 10**S REPRE-
	// SENTS THE INCREASE IN ERROR DUE TO ARGUMENT REDUCTION IN THE
	// ELEMENTARY FUNCTIONS. HERE, S=MAX(1,ABS(LOG10(CABS(Z))),
	// ABS(LOG10(FNU))) APPROXIMATELY (I.E. S=MAX(1,ABS(EXPONENT OF
	// CABS(Z),ABS(EXPONENT OF FNU)) ). HOWEVER, THE PHASE ANGLE MAY
	// HAVE ONLY ABSOLUTE ACCURACY. THIS IS MOST LIKELY TO OCCUR WHEN
	// ONE COMPONENT (IN ABSOLUTE VALUE) IS LARGER THAN THE OTHER BY
	// SEVERAL ORDERS OF MAGNITUDE. IF ONE COMPONENT IS 10**K LARGER
	// THAN THE OTHER, THEN ONE CAN EXPECT ONLY MAX(ABS(LOG10(P))-K,
	// 0) SIGNIFICANT DIGITS; OR, STATED ANOTHER WAY, WHEN K EXCEEDS
	// THE EXPONENT OF P, NO SIGNIFICANT DIGITS REMAIN IN THE SMALLER
	// COMPONENT. HOWEVER, THE PHASE ANGLE RETAINS ABSOLUTE ACCURACY
	// BECAUSE, IN COMPLEX ARITHMETIC WITH PRECISION P, THE SMALLER
	// COMPONENT WILL NOT (AS A RULE) DECREASE BELOW P TIMES THE
	// MAGNITUDE OF THE LARGER COMPONENT. IN THESE EXTREME CASES,
	// THE PRINCIPAL PHASE ANGLE IS ON THE ORDER OF +P, -P, PI/2-P,
	// OR -PI/2+P.
	//
	// REFERENCES  HANDBOOK OF MATHEMATICAL FUNCTIONS BY M. ABRAMOWITZ
	//         AND I. A. STEGUN, NBS AMS SERIES 55, U.S. DEPT. OF
	//         COMMERCE, 1955.
	//
	//       COMPUTATION OF BESSEL FUNCTIONS OF COMPLEX ARGUMENT
	//         BY D. E. AMOS, SAND83-0083, MAY, 1983.
	//
	//       COMPUTATION OF BESSEL FUNCTIONS OF COMPLEX ARGUMENT
	//         AND LARGE ORDER BY D. E. AMOS, SAND83-0643, MAY, 1983
	//
	//       A SUBROUTINE PACKAGE FOR BESSEL FUNCTIONS OF A COMPLEX
	//         ARGUMENT AND NONNEGATIVE ORDER BY D. E. AMOS, SAND85-
	//         1018, MAY, 1985
	//
	//       A PORTABLE PACKAGE FOR BESSEL FUNCTIONS OF A COMPLEX
	//         ARGUMENT AND NONNEGATIVE ORDER BY D. E. AMOS, TRANS.
	//         MATH. SOFTWARE, 1986

	const (
		HPI = 1.57079632679489662e0
	)

	var AA, ALIM, ALN, ARG, AZ, DIG, ELIM, FMM, FN, FNUL, RHPI, RL, R1M5, SGN, STR, TOL, UFL,
		ZNI, ZNR, ZTI, BB, ASCLE, RTOL, ATOL, STI, CSGNR, CSGNI float64

	var I, INU, INUH, IR, K, K1, K2, MM, MR, NN, NUF, NW int

	IERR = 0
	NZ = 0

	if ZR == 0.0e0 && ZI == 0.0e0 {
		IERR = 1
	}
	if FNU < 0.0e0 {
		IERR = 1
	}
	if M < 1 || M > 2 {
		IERR = 1
	}
	if KODE < 1 || KODE > 2 {
		IERR = 1
	}
	if N < 1 {
		IERR = 1
	}
	if IERR != 0 {
		return ZR, ZI, FNU, KODE, M, N, CYR, CYI, NZ, IERR
	}
	NN = N

	// SET PARAMETERS RELATED TO MACHINE CONSTANTS.
	// TOL IS THE APPROXIMATE UNIT ROUNDOFF LIMITED TO 1.0E-18.
	// ELIM IS THE APPROXIMATE EXPONENTIAL OVER- AND UNDERFLOW LIMIT.
	// EXP(-ELIM) < EXP(-ALIM)=EXP(-ELIM)/TOL    AND
	// EXP(ELIM) > EXP(ALIM)=EXP(ELIM)*TOL       ARE INTERVALS NEAR
	// UNDERFLOW AND OVERFLOW LIMITS WHERE SCALED ARITHMETIC IS DONE.
	// RL IS THE LOWER BOUNDARY OF THE ASYMPTOTIC EXPANSION FOR LARGE Z.
	// DIG = NUMBER OF BASE 10 DIGITS IN TOL = 10**(-DIG).
	// FNUL IS THE LOWER BOUNDARY OF THE ASYMPTOTIC SERIES FOR LARGE FNU
	TOL = math.Max(machine.D1MACH[4], 1.0e-18)
	K1 = machine.I1MACH[15]
	K2 = machine.I1MACH[16]
	R1M5 = machine.D1MACH[5]
	K = MIN(ABS(K1), ABS(K2))
	ELIM = 2.303e0 * (float64(float32(K))*R1M5 - 3.0e0)
	K1 = machine.I1MACH[14] - 1
	AA = R1M5 * float64(float32(K1))
	DIG = math.Min(AA, 18.0e0)
	AA = AA * 2.303e0
	ALIM = ELIM + math.Max(-AA, -41.45e0)
	FNUL = 10.0e0 + 6.0e0*(DIG-3.0e0)
	RL = 1.2e0*DIG + 3.0e0
	FN = FNU + float64(float32(NN-1))
	MM = 3 - M - M
	FMM = float64(float32(MM))
	ZNR = FMM * ZI
	ZNI = -FMM * ZR

	// TEST FOR PROPER RANGE
	AZ = ZABS(ZR, ZI)
	AA = 0.5e0 / TOL
	BB = float64(float32(machine.I1MACH[9])) * 0.5e0
	AA = math.Min(AA, BB)

	if AZ > AA {
		goto L260
	}
	if FN > AA {
		goto L260
	}
	AA = math.Sqrt(AA)
	if AZ > AA {
		IERR = 3
	}
	if FN > AA {
		IERR = 3
	}

	// OVERFLOW TEST ON THE LAST MEMBER OF THE SEQUENCE
	UFL = machine.D1MACH[1] * 1000e0
	if AZ < UFL {
		goto L230
	}
	if FNU > FNUL {
		goto L90
	}
	if FN <= 1.0e0 {
		goto L70
	}
	if FN > 2.0e0 {
		goto L60
	}
	if AZ > TOL {
		goto L70
	}
	ARG = 0.5e0 * AZ
	ALN = -FN * math.Log(ARG)
	if ALN > ELIM {
		goto L230
	}
	goto L70
L60:
	ZNR, ZNI, FNU, KODE, _, NN, CYR, CYI, NUF, TOL, ELIM, ALIM = ZUOIK(ZNR, ZNI, FNU, KODE, 2, NN, CYR, CYI, NUF, TOL, ELIM, ALIM)
	if NUF < 0 {
		goto L230
	}
	NZ = NZ + NUF
	NN = NN - NUF

	// HERE NN=N OR NN=0 SINCE NUF=0,NN, OR -1 ON RETURN FROM CUOIK
	// IF NUF=NN, THEN CY(I)=CZERO FOR ALL I
	if NN == 0 {
		goto L140
	}
L70:
	if (ZNR < 0.0e0) || (ZNR == 0.0e0 && ZNI < 0.0e0 && M == 2) {
		goto L80
	}
	// RIGHT HALF PLANE COMPUTATION, XN >= 0.  &&  (XN != 0.  ||
	// YN >= 0.  ||  M=1)
	ZNR, ZNI, FNU, KODE, NN, CYR, CYI, NZ, TOL, ELIM, ALIM = ZBKNU(ZNR, ZNI, FNU, KODE, NN, CYR, CYI, NZ, TOL, ELIM, ALIM)
	goto L110

	// LEFT HALF PLANE COMPUTATION
L80:
	MR = -MM
	ZNR, ZNI, FNU, KODE, MR, NN, CYR, CYI, NW, RL, FNUL, TOL, ELIM, ALIM = ZACON(ZNR, ZNI, FNU, KODE, MR, NN, CYR, CYI, NW, RL, FNUL, TOL, ELIM, ALIM)
	if NW < 0 {
		goto L240
	}
	NZ = NW
	goto L110
L90:
	// UNIFORM ASYMPTOTIC EXPANSIONS FOR FNU > FNUL
	MR = 0
	if (ZNR >= 0.0e0) && (ZNR != 0.0e0 || ZNI >= 0.0e0 || M != 2) {
		goto L100
	}
	MR = -MM
	if ZNR != 0.0e0 || ZNI >= 0.0e0 {
		goto L100
	}
	ZNR = -ZNR
	ZNI = -ZNI
L100:
	ZNR, ZNI, FNU, KODE, MR, NN, CYR, CYI, NW, TOL, ELIM, ALIM = ZBUNK(ZNR, ZNI, FNU, KODE, MR, NN, CYR, CYI, NW, TOL, ELIM, ALIM)
	if NW < 0 {
		goto L240
	}
	NZ = NZ + NW
L110:
	// H(M,FNU,Z) = -FMM*(I/HPI)*(ZT**FNU)*K(FNU,-Z*ZT)
	//
	// ZT=EXP(-FMM*HPI*I) = CMPLX(0.0,-FMM), FMM=3-2*M, M=1,2
	SGN = math.Copysign(HPI, -FMM)

	// CALCULATE EXP(FNU*HPI*I) TO MINIMIZE LOSSES OF SIGNIFICANCE
	// WHEN FNU IS LARGE
	INU = int(float32(FNU))
	INUH = INU / 2
	IR = INU - 2*INUH
	ARG = (FNU - float64(float32(INU-IR))) * SGN
	RHPI = 1.0e0 / SGN
	// ZNI = RHPI*math.Cos(ARG)
	// ZNR = -RHPI*math.Sin(ARG)
	CSGNI = RHPI * math.Cos(ARG)
	CSGNR = -RHPI * math.Sin(ARG)
	if INUH%2 == 0 {
		goto L120
	}
	// ZNR = -ZNR
	// ZNI = -ZNI
	CSGNR = -CSGNR
	CSGNI = -CSGNI
L120:
	ZTI = -FMM
	RTOL = 1.0e0 / TOL
	ASCLE = UFL * RTOL
	for I = 1; I <= NN; I++ {
		//   STR = CYR(I)*ZNR - CYI(I)*ZNI
		//   CYI(I) = CYR(I)*ZNI + CYI(I)*ZNR
		//   CYR(I) = STR
		//   STR = -ZNI*ZTI
		//   ZNI = ZNR*ZTI
		//   ZNR = STR
		AA = CYR[I]
		BB = CYI[I]
		ATOL = 1.0e0
		if math.Max(math.Abs(AA), math.Abs(BB)) > ASCLE {
			goto L135
		}
		AA = AA * RTOL
		BB = BB * RTOL
		ATOL = TOL
	L135:
		STR = AA*CSGNR - BB*CSGNI
		STI = AA*CSGNI + BB*CSGNR
		CYR[I] = STR * ATOL
		CYI[I] = STI * ATOL
		STR = -CSGNI * ZTI
		CSGNI = CSGNR * ZTI
		CSGNR = STR
	}
	return ZR, ZI, FNU, KODE, M, N, CYR, CYI, NZ, IERR
L140:
	if ZNR < 0.0e0 {
		goto L230
	}
	return ZR, ZI, FNU, KODE, M, N, CYR, CYI, NZ, IERR
L230:
	NZ = 0
	IERR = 2
	return ZR, ZI, FNU, KODE, M, N, CYR, CYI, NZ, IERR
L240:
	if NW == -1 {
		goto L230
	}
	NZ = 0
	IERR = 5
	return ZR, ZI, FNU, KODE, M, N, CYR, CYI, NZ, IERR
L260:
	NZ = 0
	IERR = 4
	return ZR, ZI, FNU, KODE, M, N, CYR, CYI, NZ, IERR
}

// ZACON APPLIES THE ANALYTIC CONTINUATION FORMULA
//
// K(FNU,ZN*EXP(MP))=K(FNU,ZN)*EXP(-MP*FNU) - MP*I(FNU,ZN)
//         MP=PI*MR*CMPLX(0.0,1.0)
//
// TO CONTINUE THE K FUNCTION FROM THE RIGHT HALF TO THE LEFT
// HALF Z PLANE
func ZACON(ZR float64, ZI float64, FNU float64, KODE int, MR int, N int, YR []float64, YI []float64, NZ int, RL float64,
	FNUL float64, TOL float64, ELIM float64, ALIM float64) (float64, float64, float64, int, int, int, []float64, []float64, int, float64, float64, float64, float64, float64) {

	const (
		ZEROR = 0.0e0
		CONER = 1.0e0
	)

	var ARG, ASCLE, AS2, AZN, BSCLE, CKI, CKR, CPN, CSCL, CSCR, CSGNI, CSGNR, CSPNI, CSPNR,
		CSR, C1I, C1M, C1R, C2I, C2R, FMR, FN, PTI, PTR, RAZN, RZI, RZR, SC1I, SC1R,
		SC2I, SC2R, SGN, SPN, STI, STR, S1I, S1R, S2I, S2R, YY, ZNI, ZNR float64
	var I, INU, IUF, KFLAG, NN, NW int

	CYR := []float64{math.NaN(), 0, 0}
	CYI := []float64{math.NaN(), 0, 0}
	CSSR := []float64{math.NaN(), 0, 0, 0}
	CSRR := []float64{math.NaN(), 0, 0, 0}
	BRY := []float64{math.NaN(), 0, 0, 0}

	NZ = 0
	ZNR = -ZR
	ZNI = -ZI
	NN = N
	ZNR, ZNI, FNU, KODE, NN, YR, YI, NW, RL, FNUL, TOL, ELIM, ALIM = ZBINU(ZNR, ZNI, FNU, KODE, NN, YR, YI, NW, RL, FNUL, TOL, ELIM, ALIM)

	if NW < 0 {
		goto L90
	}
	// ANALYTIC CONTINUATION TO THE LEFT HALF PLANE FOR THE K FUNCTION
	NN = MIN(2, N)
	ZNR, ZNI, FNU, KODE, NN, CYR, CYI, NW, TOL, ELIM, ALIM = ZBKNU(ZNR, ZNI, FNU, KODE, NN, CYR, CYI, NW, TOL, ELIM, ALIM)
	if NW != 0 {
		goto L90
	}
	S1R = CYR[1]
	S1I = CYI[1]
	FMR = float64(float32(MR))
	SGN = -math.Copysign(math.Pi, FMR)
	CSGNR = ZEROR
	CSGNI = SGN
	if KODE == 1 {
		goto L10
	}
	YY = -ZNI
	CPN = math.Cos(YY)
	SPN = math.Sin(YY)
	CSGNR, CSGNI = ZMLT(CSGNR, CSGNI, CPN, SPN)
L10:
	// CALCULATE CSPN=EXP(FNU*PI*I) TO MINIMIZE LOSSES OF SIGNIFICANCE
	// WHEN FNU IS LARGE
	INU = int(float32(FNU))
	ARG = (FNU - float64(float32(INU))) * SGN
	CPN = math.Cos(ARG)
	SPN = math.Sin(ARG)
	CSPNR = CPN
	CSPNI = SPN
	if INU%2 == 0 {
		goto L20
	}
	CSPNR = -CSPNR
	CSPNI = -CSPNI
L20:
	IUF = 0
	C1R = S1R
	C1I = S1I
	C2R = YR[1]
	C2I = YI[1]
	ASCLE = 1000e3 * machine.D1MACH[1] / TOL
	if KODE == 1 {
		goto L30
	}
	ZNR, ZNI, C1R, C1I, C2R, C2I, NW, ASCLE, ALIM, IUF = ZS1S2(ZNR, ZNI, C1R, C1I, C2R, C2I, NW, ASCLE, ALIM, IUF)
	NZ = NZ + NW
	SC1R = C1R
	SC1I = C1I
L30:
	STR, STI = ZMLT(CSPNR, CSPNI, C1R, C1I)
	PTR, PTI = ZMLT(CSGNR, CSGNI, C2R, C2I)
	YR[1] = STR + PTR
	YI[1] = STI + PTI
	if N == 1 {
		return ZR, ZI, FNU, KODE, MR, N, YR, YI, NZ, RL, FNUL, TOL, ELIM, ALIM
	}
	CSPNR = -CSPNR
	CSPNI = -CSPNI
	S2R = CYR[2]
	S2I = CYI[2]
	C1R = S2R
	C1I = S2I
	C2R = YR[2]
	C2I = YI[2]
	if KODE == 1 {
		goto L40
	}
	ZNR, ZNI, C1R, C1I, C2R, C2I, NW, ASCLE, ALIM, IUF = ZS1S2(ZNR, ZNI, C1R, C1I, C2R, C2I, NW, ASCLE, ALIM, IUF)
	NZ = NZ + NW
	SC2R = C1R
	SC2I = C1I
L40:
	STR, STI = ZMLT(CSPNR, CSPNI, C1R, C1I)
	PTR, PTI = ZMLT(CSGNR, CSGNI, C2R, C2I)
	YR[2] = STR + PTR
	YI[2] = STI + PTI
	if N == 2 {
		return ZR, ZI, FNU, KODE, MR, N, YR, YI, NZ, RL, FNUL, TOL, ELIM, ALIM
	}
	CSPNR = -CSPNR
	CSPNI = -CSPNI
	AZN = ZABS(ZNR, ZNI)
	RAZN = 1.0e0 / AZN
	STR = ZNR * RAZN
	STI = -ZNI * RAZN
	RZR = (STR + STR) * RAZN
	RZI = (STI + STI) * RAZN
	FN = FNU + 1.0e0
	CKR = FN * RZR
	CKI = FN * RZI

	// SCALE NEAR EXPONENT EXTREMES DURING RECURRENCE ON K FUNCTIONS
	CSCL = 1.0e0 / TOL
	CSCR = TOL
	CSSR[1] = CSCL
	CSSR[2] = CONER
	CSSR[3] = CSCR
	CSRR[1] = CSCR
	CSRR[2] = CONER
	CSRR[3] = CSCL
	BRY[1] = ASCLE
	BRY[2] = 1.0e0 / ASCLE
	BRY[3] = machine.D1MACH[2]
	AS2 = ZABS(S2R, S2I)
	KFLAG = 2
	if AS2 > BRY[1] {
		goto L50
	}
	KFLAG = 1
	goto L60
L50:
	if AS2 < BRY[2] {
		goto L60
	}
	KFLAG = 3
L60:
	BSCLE = BRY[KFLAG]
	S1R = S1R * CSSR[KFLAG]
	S1I = S1I * CSSR[KFLAG]
	S2R = S2R * CSSR[KFLAG]
	S2I = S2I * CSSR[KFLAG]
	CSR = CSRR[KFLAG]
	for I = 3; I <= N; I++ {
		STR = S2R
		STI = S2I
		S2R = CKR*STR - CKI*STI + S1R
		S2I = CKR*STI + CKI*STR + S1I
		S1R = STR
		S1I = STI
		C1R = S2R * CSR
		C1I = S2I * CSR
		STR = C1R
		STI = C1I
		C2R = YR[I]
		C2I = YI[I]
		if KODE == 1 {
			goto L70
		}
		if IUF < 0 {
			goto L70
		}
		ZNR, ZNI, C1R, C1I, C2R, C2I, NW, ASCLE, ALIM, IUF = ZS1S2(ZNR, ZNI, C1R, C1I, C2R, C2I, NW, ASCLE, ALIM, IUF)
		NZ = NZ + NW
		SC1R = SC2R
		SC1I = SC2I
		SC2R = C1R
		SC2I = C1I
		if IUF != 3 {
			goto L70
		}
		IUF = -4
		S1R = SC1R * CSSR[KFLAG]
		S1I = SC1I * CSSR[KFLAG]
		S2R = SC2R * CSSR[KFLAG]
		S2I = SC2I * CSSR[KFLAG]
		STR = SC2R
		STI = SC2I
	L70:
		PTR = CSPNR*C1R - CSPNI*C1I
		PTI = CSPNR*C1I + CSPNI*C1R
		YR[I] = PTR + CSGNR*C2R - CSGNI*C2I
		YI[I] = PTI + CSGNR*C2I + CSGNI*C2R
		CKR = CKR + RZR
		CKI = CKI + RZI
		CSPNR = -CSPNR
		CSPNI = -CSPNI
		if KFLAG >= 3 {
			continue
		}
		PTR = math.Abs(C1R)
		PTI = math.Abs(C1I)
		C1M = math.Max(PTR, PTI)
		if C1M <= BSCLE {
			continue
		}
		KFLAG = KFLAG + 1
		BSCLE = BRY[KFLAG]
		S1R = S1R * CSR
		S1I = S1I * CSR
		S2R = STR
		S2I = STI
		S1R = S1R * CSSR[KFLAG]
		S1I = S1I * CSSR[KFLAG]
		S2R = S2R * CSSR[KFLAG]
		S2I = S2I * CSSR[KFLAG]
		CSR = CSRR[KFLAG]
	}
	return ZR, ZI, FNU, KODE, MR, N, YR, YI, NZ, RL, FNUL, TOL, ELIM, ALIM
L90:
	NZ = -1
	if NW == (-2) {
		NZ = -2
	}
	return ZR, ZI, FNU, KODE, MR, N, YR, YI, NZ, RL, FNUL, TOL, ELIM, ALIM
}

// ZBUNK COMPUTES THE K BESSEL FUNCTION FOR FNU > FNUL.
// ACCORDING TO THE UNIFORM ASYMPTOTIC EXPANSION FOR K(FNU,Z)
// IN ZUNK1 AND THE EXPANSION FOR H(2,FNU,Z) IN ZUNK2
func ZBUNK(ZR float64, ZI float64, FNU float64, KODE int, MR int, N int, YR []float64, YI []float64, NZ int,
	TOL float64, ELIM float64, ALIM float64) (float64, float64, float64, int, int, int, []float64, []float64, int,
	float64, float64, float64) {

	var AX, AY float64
	NZ = 0
	AX = math.Abs(ZR) * 1.7321e0
	AY = math.Abs(ZI)
	if AY > AX {
		goto L10
	}

	// ASYMPTOTIC EXPANSION FOR K(FNU,Z) FOR LARGE FNU APPLIED IN
	// -PI/3 <=  ARG(Z) <=  PI/3
	ZR, ZI, FNU, KODE, MR, N, YR, YI, NZ, TOL, ELIM, ALIM = ZUNK1(ZR, ZI, FNU, KODE, MR, N, YR, YI, NZ, TOL, ELIM, ALIM)
	goto L20
L10:

	// ASYMPTOTIC EXPANSION FOR H(2,FNU,Z*EXP(M*HPI)) FOR LARGE FNU
	// APPLIED IN PI/3 < ABS(ARG(Z)) <=  PI/2 WHERE M=+I OR -I
	// AND HPI=PI/2
	ZR, ZI, FNU, KODE, MR, N, YR, YI, NZ, TOL, ELIM, ALIM = ZUNK2(ZR, ZI, FNU, KODE, MR, N, YR, YI, NZ, TOL, ELIM, ALIM)
L20:
	return ZR, ZI, FNU, KODE, MR, N, YR, YI, NZ, TOL, ELIM, ALIM
}

// ZBESI COMPUTE THE I-BESSEL FUNCTION OF A COMPLEX ARGUMENT
//
// FOR KODE=1  COMPUTES AN N MEMBER SEQUENCE OF COMPLEX
// BESSEL FUNCTIONS CY(J)=I(FNU+J-1,Z) FOR REAL, NONNEGATIVE
// ORDERS FNU+J-1, J=1,...,N AND COMPLEX Z IN THE CUT PLANE
// -PI < ARG(Z) <=  PI. ON KODE=2, ZBESI RETURNS THE SCALED
// FUNCTIONS
//
// CY(J)=EXP(-ABS(X))*I(FNU+J-1,Z)   J = 1,...,N , X=REAL(Z)
//
// WITH THE EXPONENTIAL GROWTH REMOVED IN BOTH THE LEFT AND
// RIGHT HALF PLANES FOR Z TO INFINITY. DEFINITIONS AND NOTATION
// ARE FOUND IN THE NBS HANDBOOK OF MATHEMATICAL FUNCTIONS
// (REF. 1).
//
// INPUT      ZR,ZI,FNU ARE DOUBLE PRECISION
//   ZR,ZI  - Z=CMPLX(ZR,ZI),  -PI < ARG(Z) <=  PI
//   FNU    - ORDER OF INITIAL I FUNCTION, FNU >= 0.0e0
//   KODE   - A PARAMETER TO INDICATE THE SCALING OPTION
//            KODE= 1  RETURNS
//                     CY(J)=I(FNU+J-1,Z), J=1,...,N
//                = 2  RETURNS
//                     CY(J)=I(FNU+J-1,Z)*EXP(-ABS(X)), J=1,...,N
//   N      - NUMBER OF MEMBERS OF THE SEQUENCE, N >= 1
//
// OUTPUT     CYR,CYI ARE DOUBLE PRECISION
//   CYR,CYI- DOUBLE PRECISION VECTORS WHOSE FIRST N COMPONENTS
//            CONTAIN REAL AND IMAGINARY PARTS FOR THE SEQUENCE
//            CY(J)=I(FNU+J-1,Z)  OR
//            CY(J)=I(FNU+J-1,Z)*EXP(-ABS(X))  J=1,...,N
//            DEPENDING ON KODE, X=REAL(Z)
//   NZ     - NUMBER OF COMPONENTS SET TO ZERO DUE TO UNDERFLOW,
//            NZ= 0   , NORMAL RETURN
//            NZ > 0 , LAST NZ COMPONENTS OF CY SET TO ZERO
//                      TO UNDERFLOW, CY(J)=CMPLX(0.0e0,0.0e0)
//                      J = N-NZ+1,...,N
//   IERR   - ERROR FLAG
//            IERR=0, NORMAL RETURN - COMPUTATION COMPLETED
//            IERR=1, INPUT ERROR   - NO COMPUTATION
//            IERR=2, OVERFLOW      - NO COMPUTATION, REAL(Z) TOO
//                    LARGE ON KODE=1
//            IERR=3, CABS(Z) OR FNU+N-1 LARGE - COMPUTATION DONE
//                    BUT LOSSES OF SIGNIFCANCE BY ARGUMENT
//                    REDUCTION PRODUCE LESS THAN HALF OF MACHINE
//                    ACCURACY
//            IERR=4, CABS(Z) OR FNU+N-1 TOO LARGE - NO COMPUTA-
//                    TION BECAUSE OF COMPLETE LOSSES OF SIGNIFI-
//                    CANCE BY ARGUMENT REDUCTION
//            IERR=5, ERROR              - NO COMPUTATION,
//                    ALGORITHM TERMINATION CONDITION NOT MET
func ZBESI(ZR float64, ZI float64, FNU float64, KODE int, N int, CYR []float64, CYI []float64, NZ int, IERR int) (float64, float64, float64, int, int, []float64, []float64, int, int) {

	// THE COMPUTATION IS CARRIED OUT BY THE POWER SERIES FOR
	// SMALL CABS(Z), THE ASYMPTOTIC EXPANSION FOR LARGE CABS(Z),
	// THE MILLER ALGORITHM NORMALIZED BY THE WRONSKIAN AND A
	// NEUMANN SERIES FOR IMTERMEDIATE MAGNITUDES, AND THE
	// UNIFORM ASYMPTOTIC EXPANSIONS FOR I(FNU,Z) AND J(FNU,Z)
	// FOR LARGE ORDERS. BACKWARD RECURRENCE IS USED TO GENERATE
	// SEQUENCES OR REDUCE ORDERS WHEN NECESSARY.
	//
	// THE CALCULATIONS ABOVE ARE DONE IN THE RIGHT HALF PLANE AND
	// CONTINUED INTO THE LEFT HALF PLANE BY THE FORMULA
	//
	// I(FNU,Z*EXP(M*PI)) = EXP(M*PI*FNU)*I(FNU,Z)  REAL(Z) > 0.0
	//               M = +I OR -I,  I**2=-1
	//
	// FOR NEGATIVE ORDERS,THE FORMULA
	//
	//      I(-FNU,Z) = I(FNU,Z) + (2/PI)*SIN(PI*FNU)*K(FNU,Z)
	//
	// CAN BE USED. HOWEVER,FOR LARGE ORDERS CLOSE TO INTEGERS, THE
	// THE FUNCTION CHANGES RADICALLY. WHEN FNU IS A LARGE POSITIVE
	// INTEGER,THE MAGNITUDE OF I(-FNU,Z)=I(FNU,Z) IS A LARGE
	// NEGATIVE POWER OF TEN. BUT WHEN FNU IS NOT AN INTEGER,
	// K(FNU,Z) DOMINATES IN MAGNITUDE WITH A LARGE POSITIVE POWER OF
	// TEN AND THE MOST THAT THE SECOND TERM CAN BE REDUCED IS BY
	// UNIT ROUNDOFF FROM THE COEFFICIENT. THUS, WIDE CHANGES CAN
	// OCCUR WITHIN UNIT ROUNDOFF OF A LARGE INTEGER FOR FNU. HERE,
	// LARGE MEANS FNU > CABS(Z).
	//
	// IN MOST COMPLEX VARIABLE COMPUTATION, ONE MUST EVALUATE ELE-
	// MENTARY FUNCTIONS. WHEN THE MAGNITUDE OF Z OR FNU+N-1 IS
	// LARGE, LOSSES OF SIGNIFICANCE BY ARGUMENT REDUCTION OCCUR.
	// CONSEQUENTLY, IF EITHER ONE EXCEEDS U1=SQRT(0.5/UR), THEN
	// LOSSES EXCEEDING HALF PRECISION ARE LIKELY AND AN ERROR FLAG
	// IERR=3 IS TRIGGERED WHERE UR=math.Max(machine.D1MACH[4),1.0e-18) IS
	// DOUBLE PRECISION UNIT ROUNDOFF LIMITED TO 18 DIGITS PRECISION.
	// IF EITHER IS LARGER THAN U2=0.5/UR, THEN ALL SIGNIFICANCE IS
	// LOST AND IERR=4. IN ORDER TO USE THE INT FUNCTION, ARGUMENTS
	// MUST BE FURTHER RESTRICTED NOT TO EXCEED THE LARGEST MACHINE
	// INTEGER, U3=machine.I1MACH[9). THUS, THE MAGNITUDE OF Z AND FNU+N-1 IS
	// RESTRICTED BY MIN(U2,U3). ON 32 BIT MACHINES, U1,U2, AND U3
	// ARE APPROXIMATELY 2.0E+3, 4.2E+6, 2.1E+9 IN SINGLE PRECISION
	// ARITHMETIC AND 1.3E+8, 1.8E+16, 2.1E+9 IN DOUBLE PRECISION
	// ARITHMETIC RESPECTIVELY. THIS MAKES U2 AND U3 LIMITING IN
	// THEIR RESPECTIVE ARITHMETICS. THIS MEANS THAT ONE CAN EXPECT
	// TO RETAIN, IN THE WORST CASES ON 32 BIT MACHINES, NO DIGITS
	// IN SINGLE AND ONLY 7 DIGITS IN DOUBLE PRECISION ARITHMETIC.
	// SIMILAR CONSIDERATIONS HOLD FOR OTHER MACHINES.
	//
	// THE APPROXIMATE RELATIVE ERROR IN THE MAGNITUDE OF A COMPLEX
	// BESSEL FUNCTION CAN BE EXPRESSED BY P*10**S WHERE P=MAX(UNIT
	// ROUNDOFF,1.0E-18) IS THE NOMINAL PRECISION AND 10**S REPRE-
	// SENTS THE INCREASE IN ERROR DUE TO ARGUMENT REDUCTION IN THE
	// ELEMENTARY FUNCTIONS. HERE, S=MAX(1,ABS(LOG10(CABS(Z))),
	// ABS(LOG10(FNU))) APPROXIMATELY (I.E. S=MAX(1,ABS(EXPONENT OF
	// CABS(Z),ABS(EXPONENT OF FNU)) ). HOWEVER, THE PHASE ANGLE MAY
	// HAVE ONLY ABSOLUTE ACCURACY. THIS IS MOST LIKELY TO OCCUR WHEN
	// ONE COMPONENT (IN ABSOLUTE VALUE) IS LARGER THAN THE OTHER BY
	// SEVERAL ORDERS OF MAGNITUDE. IF ONE COMPONENT IS 10**K LARGER
	// THAN THE OTHER, THEN ONE CAN EXPECT ONLY MAX(ABS(LOG10(P))-K,
	// 0) SIGNIFICANT DIGITS; OR, STATED ANOTHER WAY, WHEN K EXCEEDS
	// THE EXPONENT OF P, NO SIGNIFICANT DIGITS REMAIN IN THE SMALLER
	// COMPONENT. HOWEVER, THE PHASE ANGLE RETAINS ABSOLUTE ACCURACY
	// BECAUSE, IN COMPLEX ARITHMETIC WITH PRECISION P, THE SMALLER
	// COMPONENT WILL NOT (AS A RULE) DECREASE BELOW P TIMES THE
	// MAGNITUDE OF THE LARGER COMPONENT. IN THESE EXTREME CASES,
	// THE PRINCIPAL PHASE ANGLE IS ON THE ORDER OF +P, -P, PI/2-P,
	// OR -PI/2+P.
	//
	// REFERENCES  HANDBOOK OF MATHEMATICAL FUNCTIONS BY M. ABRAMOWITZ
	//         AND I. A. STEGUN, NBS AMS SERIES 55, U.S. DEPT. OF
	//         COMMERCE, 1955.
	//
	//       COMPUTATION OF BESSEL FUNCTIONS OF COMPLEX ARGUMENT
	//         BY D. E. AMOS, SAND83-0083, MAY, 1983.
	//
	//       COMPUTATION OF BESSEL FUNCTIONS OF COMPLEX ARGUMENT
	//         AND LARGE ORDER BY D. E. AMOS, SAND83-0643, MAY, 1983
	//
	//       A SUBROUTINE PACKAGE FOR BESSEL FUNCTIONS OF A COMPLEX
	//         ARGUMENT AND NONNEGATIVE ORDER BY D. E. AMOS, SAND85-
	//         1018, MAY, 1985
	//
	//       A PORTABLE PACKAGE FOR BESSEL FUNCTIONS OF A COMPLEX
	//         ARGUMENT AND NONNEGATIVE ORDER BY D. E. AMOS, TRANS.
	//         MATH. SOFTWARE, 1986
	//
	const (
		CONEI = 0.0e0
		CONER = 1.0e0
	)

	var AA, ALIM, ARG, CSGNI, CSGNR, DIG, ELIM, FNUL, RL, R1M5, STR, TOL, ZNI,
		ZNR, AZ, BB, FN, ASCLE, RTOL, ATOL, STI float64
	var I, INU, K, K1, K2, NN int

	IERR = 0
	NZ = 0
	if FNU < 0.0e0 {
		IERR = 1
	}
	if KODE < 1 || KODE > 2 {
		IERR = 1
	}
	if N < 1 {
		IERR = 1
	}
	if IERR != 0 {
		return ZR, ZI, FNU, KODE, N, CYR, CYI, NZ, IERR
	}

	// SET PARAMETERS RELATED TO MACHINE CONSTANTS.
	// TOL IS THE APPROXIMATE UNIT ROUNDOFF LIMITED TO 1.0E-18.
	// ELIM IS THE APPROXIMATE EXPONENTIAL OVER- AND UNDERFLOW LIMIT.
	// EXP(-ELIM) < EXP(-ALIM)=EXP(-ELIM)/TOL    AND
	// EXP(ELIM) > EXP(ALIM)=EXP(ELIM)*TOL       ARE INTERVALS NEAR
	// UNDERFLOW AND OVERFLOW LIMITS WHERE SCALED ARITHMETIC IS DONE.
	// RL IS THE LOWER BOUNDARY OF THE ASYMPTOTIC EXPANSION FOR LARGE Z.
	// DIG = NUMBER OF BASE 10 DIGITS IN TOL = 10**(-DIG).
	// FNUL IS THE LOWER BOUNDARY OF THE ASYMPTOTIC SERIES FOR LARGE FNU.
	TOL = math.Max(machine.D1MACH[4], 1.0e-18)
	K1 = machine.I1MACH[15]
	K2 = machine.I1MACH[16]
	R1M5 = machine.D1MACH[5]
	K = MIN(ABS(K1), ABS(K2))
	ELIM = 2.303e0 * (float64(float32(K))*R1M5 - 3.0e0)
	K1 = machine.I1MACH[14] - 1
	AA = R1M5 * float64(float32(K1))
	DIG = math.Min(AA, 18.0e0)
	AA = AA * 2.303e0
	ALIM = ELIM + math.Max(-AA, -41.45e0)
	RL = 1.2e0*DIG + 3.0e0
	FNUL = 10.0e0 + 6.0e0*(DIG-3.0e0)

	// TEST FOR PROPER RANGE
	AZ = ZABS(ZR, ZI)
	FN = FNU + float64(float32(N-1))
	AA = 0.5e0 / TOL
	BB = float64(float32(machine.I1MACH[9])) * 0.5e0
	AA = math.Min(AA, BB)
	if AZ > AA {
		goto L260
	}
	if FN > AA {
		goto L260
	}
	AA = math.Sqrt(AA)
	if AZ > AA {
		IERR = 3
	}
	if FN > AA {
		IERR = 3
	}
	ZNR = ZR
	ZNI = ZI
	CSGNR = CONER
	CSGNI = CONEI
	if ZR >= 0.0e0 {
		goto L40
	}
	ZNR = -ZR
	ZNI = -ZI

	// CALCULATE CSGN=EXP(FNU*PI*I) TO MINIMIZE LOSSES OF SIGNIFICANCE
	// WHEN FNU IS LARGE
	INU = int(float32(FNU))
	ARG = (FNU - float64(float32(INU))) * math.Pi
	if ZI < 0.0e0 {
		ARG = -ARG
	}
	CSGNR = math.Cos(ARG)
	CSGNI = math.Sin(ARG)
	if INU%2 == 0 {
		goto L40
	}
	CSGNR = -CSGNR
	CSGNI = -CSGNI
L40:
	ZNR, ZNI, FNU, KODE, N, CYR, CYI, NZ, RL, FNUL, TOL, ELIM, ALIM = ZBINU(ZNR, ZNI, FNU, KODE, N, CYR, CYI, NZ, RL, FNUL, TOL, ELIM, ALIM)
	if NZ < 0 {
		goto L120
	}
	if ZR >= 0.0e0 {
		return ZR, ZI, FNU, KODE, N, CYR, CYI, NZ, IERR
	}

	// ANALYTIC CONTINUATION TO THE LEFT HALF PLANE
	NN = N - NZ
	if NN == 0 {
		return ZR, ZI, FNU, KODE, N, CYR, CYI, NZ, IERR
	}
	RTOL = 1.0e0 / TOL
	ASCLE = machine.D1MACH[1] * RTOL * 1000.0e0
	for I = 1; I <= NN; I++ {
		//   STR = CYR(I)*CSGNR - CYI(I)*CSGNI
		//   CYI(I) = CYR(I)*CSGNI + CYI(I)*CSGNR
		//   CYR(I) = STR
		AA = CYR[I]
		BB = CYI[I]
		ATOL = 1.0e0
		if math.Max(math.Abs(AA), math.Abs(BB)) > ASCLE {
			goto L55
		}
		AA = AA * RTOL
		BB = BB * RTOL
		ATOL = TOL
	L55:

		STR = AA*CSGNR - BB*CSGNI
		STI = AA*CSGNI + BB*CSGNR
		CYR[I] = STR * ATOL
		CYI[I] = STI * ATOL
		CSGNR = -CSGNR
		CSGNI = -CSGNI
	}
	return ZR, ZI, FNU, KODE, N, CYR, CYI, NZ, IERR
L120:
	if NZ == -2 {
		goto L130
	}
	NZ = 0
	IERR = 2
	return ZR, ZI, FNU, KODE, N, CYR, CYI, NZ, IERR
L130:
	NZ = 0
	IERR = 5
	return ZR, ZI, FNU, KODE, N, CYR, CYI, NZ, IERR
L260:
	NZ = 0
	IERR = 4
	return ZR, ZI, FNU, KODE, N, CYR, CYI, NZ, IERR
}

// ZUNK1 COMPUTES K(FNU,Z) AND ITS ANALYTIC CONTINUATION FROM THE
// RIGHT HALF PLANE TO THE LEFT HALF PLANE BY MEANS OF THE
// UNIFORM ASYMPTOTIC EXPANSION.
// MR INDICATES THE DIRECTION OF ROTATION FOR ANALYTIC CONTINUATION.
// NZ=-1 MEANS AN OVERFLOW WILL OCCUR
func ZUNK1(ZR float64, ZI float64, FNU float64, KODE int, MR int, N int, YR []float64, YI []float64, NZ int, TOL float64, ELIM float64, ALIM float64) (float64, float64, float64, int, int, int, []float64, []float64, int, float64, float64, float64) {

	const (
		ZEROR = 0.0e0
		ZEROI = 0.0e0
		CONER = 1.0e0
	)

	var ANG, APHI, ASC, ASCLE, CKI, CKR, CRSC, CSCL, CSGNI, CSPNI, CSPNR, CSR,
		C1I, C1R, C2I, C2M, C2R, FMR, FN, FNF, PHIDI, PHIDR, PI, RAST, RAZR, RS1, RZI,
		RZR, SGN, STI, STR, SUMDI, SUMDR, S1I, S1R, S2I, S2R, ZET1DI, ZET1DR, ZET2DI, ZET2DR, ZRI, ZRR float64

	var I, IB, IFLAG, IFN, IL, INU, IUF, K, KDFLG, KFLAG, KK, NW, INITD, IC, IPARD, J, M int

	BRY := []float64{math.NaN(), 0, 0, 0}
	SUMR := []float64{math.NaN(), 0, 0}
	SUMI := []float64{math.NaN(), 0, 0}
	ZETA1R := []float64{math.NaN(), 0, 0}
	ZETA1I := []float64{math.NaN(), 0, 0}
	ZETA2R := []float64{math.NaN(), 0, 0}
	ZETA2I := []float64{math.NaN(), 0, 0}
	CYR := []float64{math.NaN(), 0, 0}
	CYI := []float64{math.NaN(), 0, 0}
	CSSR := []float64{math.NaN(), 0, 0, 0}
	CSRR := []float64{math.NaN(), 0, 0, 0}
	PHIR := []float64{math.NaN(), 0, 0}
	PHII := []float64{math.NaN(), 0, 0}
	INIT := []int{0, 0, 0}
	CWRKR1 := []float64{math.NaN(), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
	CWRKI1 := []float64{math.NaN(), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
	CWRKR2 := []float64{math.NaN(), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
	CWRKI2 := []float64{math.NaN(), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
	CWRKR3 := []float64{math.NaN(), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
	CWRKI3 := []float64{math.NaN(), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
	CWRKR := []float64{math.NaN(), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
	CWRKI := []float64{math.NaN(), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}

	KDFLG = 1
	NZ = 0
	// EXP(-ALIM)=EXP(-ELIM)/TOL=APPROX. ONE PRECISION GREATER THAN THE UNDERFLOW LIMIT
	CSCL = 1.0e0 / TOL
	CRSC = TOL
	CSSR[1] = CSCL
	CSSR[2] = CONER
	CSSR[3] = CRSC
	CSRR[1] = CRSC
	CSRR[2] = CONER
	CSRR[3] = CSCL
	BRY[1] = 1000.0e0 * machine.D1MACH[1] / TOL
	BRY[2] = 1.0e0 / BRY[1]
	BRY[3] = machine.D1MACH[2]
	ZRR = ZR
	ZRI = ZI
	if ZR >= 0.0e0 {
		goto L10
	}
	ZRR = -ZR
	ZRI = -ZI
L10:
	J = 2
	for I = 1; I <= N; I++ {
		// J FLIP FLOPS BETWEEN 1 AND 2 IN J = 3 - J
		J = 3 - J
		FN = FNU + float64(float32(I-1))
		INIT[J] = 0

		if J == 1 {
			CWRKR = CWRKR1
			CWRKI = CWRKI1
		} else if J == 2 {
			CWRKR = CWRKR2
			CWRKI = CWRKI2
		} else {
			CWRKR = CWRKR3
			CWRKI = CWRKI3
		}

		ZRR, ZRI, FN, _, _, TOL, INIT[J], PHIR[J], PHII[J], ZETA1R[J], ZETA1I[J], ZETA2R[J], ZETA2I[J], SUMR[J], SUMI[J], CWRKR, CWRKI = ZUNIK(ZRR, ZRI, FN, 2, 0, TOL, INIT[J], PHIR[J], PHII[J], ZETA1R[J], ZETA1I[J], ZETA2R[J], ZETA2I[J], SUMR[J], SUMI[J], CWRKR, CWRKI)
		if KODE == 1 {
			goto L20
		}
		STR = ZRR + ZETA2R[J]
		STI = ZRI + ZETA2I[J]
		RAST = FN / ZABS(STR, STI)
		STR = STR * RAST * RAST
		STI = -STI * RAST * RAST
		S1R = ZETA1R[J] - STR
		S1I = ZETA1I[J] - STI
		goto L30
	L20:
		S1R = ZETA1R[J] - ZETA2R[J]
		S1I = ZETA1I[J] - ZETA2I[J]
	L30:
		RS1 = S1R
		// TEST FOR UNDERFLOW AND OVERFLOW
		if math.Abs(RS1) > ELIM {
			goto L60
		}
		if KDFLG == 1 {
			KFLAG = 2
		}
		if math.Abs(RS1) < ALIM {
			goto L40
		}
		// REFINE  TEST AND SCALE
		APHI = ZABS(PHIR[J], PHII[J])
		RS1 = RS1 + math.Log(APHI)
		if math.Abs(RS1) > ELIM {
			goto L60
		}
		if KDFLG == 1 {
			KFLAG = 1
		}
		if RS1 < 0.0e0 {
			goto L40
		}
		if KDFLG == 1 {
			KFLAG = 3
		}
	L40:
		// SCALE S1 TO KEEP INTERMEDIATE ARITHMETIC ON SCALE NEAR
		// EXPONENT EXTREMES
		S2R = PHIR[J]*SUMR[J] - PHII[J]*SUMI[J]
		S2I = PHIR[J]*SUMI[J] + PHII[J]*SUMR[J]
		STR = math.Exp(S1R) * CSSR[KFLAG]
		S1R = STR * math.Cos(S1I)
		S1I = STR * math.Sin(S1I)
		STR = S2R*S1R - S2I*S1I
		S2I = S1R*S2I + S2R*S1I
		S2R = STR
		if KFLAG != 1 {
			goto L50
		}
		S2R, S2I, NW, BRY[1], TOL = ZUCHK(S2R, S2I, NW, BRY[1], TOL)
		if NW != 0 {
			goto L60
		}
	L50:
		CYR[KDFLG] = S2R
		CYI[KDFLG] = S2I
		YR[I] = S2R * CSRR[KFLAG]
		YI[I] = S2I * CSRR[KFLAG]
		if KDFLG == 2 {
			goto L75
		}
		KDFLG = 2
		continue
	L60:
		if RS1 > 0.0e0 {
			goto L300
		}
		// FOR ZR < 0.0, THE I FUNCTION TO BE ADDED WILL OVERFLOW
		if ZR < 0.0e0 {
			goto L300
		}
		KDFLG = 1
		YR[I] = ZEROR
		YI[I] = ZEROI
		NZ = NZ + 1
		if I == 1 {
			continue
		}
		if (YR[I-1] == ZEROR) && (YI[I-1] == ZEROI) {
			continue
		}
		YR[I-1] = ZEROR
		YI[I-1] = ZEROI
		NZ = NZ + 1
	}

	I = N
L75:
	RAZR = 1.0e0 / ZABS(ZRR, ZRI)
	STR = ZRR * RAZR
	STI = -ZRI * RAZR
	RZR = (STR + STR) * RAZR
	RZI = (STI + STI) * RAZR
	CKR = FN * RZR
	CKI = FN * RZI
	IB = I + 1
	if N < IB {
		goto L160
	}

	// TEST LAST MEMBER FOR UNDERFLOW AND OVERFLOW. SET SEQUENCE TO ZERO
	// ON UNDERFLOW.
	FN = FNU + float64(float32(N-1))
	IPARD = 1
	if MR != 0 {
		IPARD = 0
	}
	INITD = 0
	ZRR, ZRI, FN, _, IPARD, TOL, INITD, PHIDR, PHIDI, ZET1DR, ZET1DI, ZET2DR, ZET2DI, SUMDR, SUMDI, CWRKR3, CWRKI3 = ZUNIK(ZRR, ZRI, FN, 2, IPARD, TOL, INITD, PHIDR, PHIDI, ZET1DR, ZET1DI, ZET2DR, ZET2DI, SUMDR, SUMDI, CWRKR3, CWRKI3)
	if KODE == 1 {
		goto L80
	}
	STR = ZRR + ZET2DR
	STI = ZRI + ZET2DI
	RAST = FN / ZABS(STR, STI)
	STR = STR * RAST * RAST
	STI = -STI * RAST * RAST
	S1R = ZET1DR - STR
	S1I = ZET1DI - STI
	goto L90
L80:
	S1R = ZET1DR - ZET2DR
	S1I = ZET1DI - ZET2DI
L90:
	RS1 = S1R
	if math.Abs(RS1) > ELIM {
		goto L95
	}
	if math.Abs(RS1) < ALIM {
		goto L100
	}

	// REFINE ESTIMATE AND TEST
	APHI = ZABS(PHIDR, PHIDI)
	RS1 = RS1 + math.Log(APHI)
	if math.Abs(RS1) < ELIM {
		goto L100
	}
L95:
	if math.Abs(RS1) > 0.0e0 {
		goto L300
	}

	// FOR ZR < 0.0, THE I FUNCTION TO BE ADDED WILL OVERFLOW
	if ZR < 0.0e0 {
		goto L300
	}
	NZ = N
	for I = 1; I <= N; I++ {

		YR[I] = ZEROR
		YI[I] = ZEROI

	}
	return ZR, ZI, FNU, KODE, MR, N, YR, YI, NZ, TOL, ELIM, ALIM

	// FORWARD RECUR FOR REMAINDER OF THE SEQUENCE
L100:
	S1R = CYR[1]
	S1I = CYI[1]
	S2R = CYR[2]
	S2I = CYI[2]
	C1R = CSRR[KFLAG]
	ASCLE = BRY[KFLAG]
	for I = IB; I <= N; I++ {
		C2R = S2R
		C2I = S2I
		S2R = CKR*C2R - CKI*C2I + S1R
		S2I = CKR*C2I + CKI*C2R + S1I
		S1R = C2R
		S1I = C2I
		CKR = CKR + RZR
		CKI = CKI + RZI
		C2R = S2R * C1R
		C2I = S2I * C1R
		YR[I] = C2R
		YI[I] = C2I
		if KFLAG >= 3 {
			continue
		}
		STR = math.Abs(C2R)
		STI = math.Abs(C2I)
		C2M = math.Max(STR, STI)
		if C2M <= ASCLE {
			continue
		}
		KFLAG = KFLAG + 1
		ASCLE = BRY[KFLAG]
		S1R = S1R * C1R
		S1I = S1I * C1R
		S2R = C2R
		S2I = C2I
		S1R = S1R * CSSR[KFLAG]
		S1I = S1I * CSSR[KFLAG]
		S2R = S2R * CSSR[KFLAG]
		S2I = S2I * CSSR[KFLAG]
		C1R = CSRR[KFLAG]
	}
L160:
	if MR == 0 {
		return ZR, ZI, FNU, KODE, MR, N, YR, YI, NZ, TOL, ELIM, ALIM
	}

	// ANALYTIC CONTINUATION FOR RE(Z) < 0.0e0
	NZ = 0
	FMR = float64(float32(MR))
	SGN = -math.Copysign(PI, FMR)

	// CSPN AND CSGN ARE COEFF OF K AND I FUNCTIONS RESP.
	CSGNI = SGN
	INU = int(float32(FNU))
	FNF = FNU - float64(float32(INU))
	IFN = INU + N - 1
	ANG = FNF * SGN
	CSPNR = math.Cos(ANG)
	CSPNI = math.Sin(ANG)
	if IFN%2 == 0 {
		goto L170
	}
	CSPNR = -CSPNR
	CSPNI = -CSPNI
L170:
	ASC = BRY[1]
	IUF = 0
	KK = N
	KDFLG = 1
	IB = IB - 1
	IC = IB - 1
	for K = 1; K <= N; K++ {
		FN = FNU + float64(float32(KK-1))
		// LOGIC TO SORT OUT CASES WHOSE PARAMETERS WERE SET FOR THE K
		// FUNCTION ABOVE
		M = 3
		if N > 2 {
			goto L175
		}
	L172:
		INITD = INIT[J]
		PHIDR = PHIR[J]
		PHIDI = PHII[J]
		ZET1DR = ZETA1R[J]
		ZET1DI = ZETA1I[J]
		ZET2DR = ZETA2R[J]
		ZET2DI = ZETA2I[J]
		SUMDR = SUMR[J]
		SUMDI = SUMI[J]
		M = J
		J = 3 - J
		goto L180
	L175:
		if (KK == N) && (IB < N) {
			goto L180
		}
		if (KK == IB) || (KK == IC) {
			goto L172
		}
		INITD = 0
	L180:
		if M == 1 {
			CWRKR = CWRKR1
			CWRKI = CWRKI1
		} else if M == 2 {
			CWRKR = CWRKR2
			CWRKI = CWRKI2
		} else {
			CWRKR = CWRKR3
			CWRKI = CWRKI3
		}
		ZRR, ZRI, FN, _, _, TOL, INITD, PHIDR, PHIDI, ZET1DR, ZET1DI, ZET2DR, ZET2DI, SUMDR, SUMDI, CWRKR, CWRKI = ZUNIK(ZRR, ZRI, FN, 1, 0, TOL, INITD, PHIDR, PHIDI, ZET1DR, ZET1DI, ZET2DR, ZET2DI, SUMDR, SUMDI, CWRKR, CWRKI)
		if KODE == 1 {
			goto L200
		}
		STR = ZRR + ZET2DR
		STI = ZRI + ZET2DI
		RAST = FN / ZABS(STR, STI)
		STR = STR * RAST * RAST
		STI = -STI * RAST * RAST
		S1R = -ZET1DR + STR
		S1I = -ZET1DI + STI
		goto L210
	L200:
		S1R = -ZET1DR + ZET2DR
		S1I = -ZET1DI + ZET2DI
	L210:
		// TEST FOR UNDERFLOW AND OVERFLOW
		RS1 = S1R
		if math.Abs(RS1) > ELIM {
			goto L260
		}
		if KDFLG == 1 {
			IFLAG = 2
		}
		if math.Abs(RS1) < ALIM {
			goto L220
		}

		// REFINE  TEST AND SCALE
		APHI = ZABS(PHIDR, PHIDI)
		RS1 = RS1 + math.Log(APHI)
		if math.Abs(RS1) > ELIM {
			goto L260
		}
		if KDFLG == 1 {
			IFLAG = 1
		}
		if RS1 < 0.0e0 {
			goto L220
		}
		if KDFLG == 1 {
			IFLAG = 3
		}
	L220:
		STR = PHIDR*SUMDR - PHIDI*SUMDI
		STI = PHIDR*SUMDI + PHIDI*SUMDR
		S2R = -CSGNI * STI
		S2I = CSGNI * STR
		STR = math.Exp(S1R) * CSSR[IFLAG]
		S1R = STR * math.Cos(S1I)
		S1I = STR * math.Sin(S1I)
		STR = S2R*S1R - S2I*S1I
		S2I = S2R*S1I + S2I*S1R
		S2R = STR
		if IFLAG != 1 {
			goto L230
		}
		S2R, S2I, NW, BRY[1], TOL = ZUCHK(S2R, S2I, NW, BRY[1], TOL)
		if NW == 0 {
			goto L230
		}
		S2R = ZEROR
		S2I = ZEROI
	L230:
		CYR[KDFLG] = S2R
		CYI[KDFLG] = S2I
		C2R = S2R
		C2I = S2I
		S2R = S2R * CSRR[IFLAG]
		S2I = S2I * CSRR[IFLAG]

		// ADD I AND K FUNCTIONS, K SEQUENCE IN Y(I), I=1,N
		S1R = YR[KK]
		S1I = YI[KK]
		if KODE == 1 {
			goto L250
		}
		ZRR, ZRI, S1R, S1I, S2R, S2I, NW, ASC, ALIM, IUF = ZS1S2(ZRR, ZRI, S1R, S1I, S2R, S2I, NW, ASC, ALIM, IUF)
		NZ = NZ + NW
	L250:
		YR[KK] = S1R*CSPNR - S1I*CSPNI + S2R
		YI[KK] = CSPNR*S1I + CSPNI*S1R + S2I
		KK = KK - 1
		CSPNR = -CSPNR
		CSPNI = -CSPNI
		if C2R != 0.0e0 || C2I != 0.0e0 {
			goto L255
		}
		KDFLG = 1
		continue
	L255:
		if KDFLG == 2 {
			goto L275
		}
		KDFLG = 2
		continue
	L260:
		if RS1 > 0.0e0 {
			goto L300
		}
		S2R = ZEROR
		S2I = ZEROI
		goto L230
	}
	K = N
L275:
	IL = N - K
	if IL == 0 {
		return ZR, ZI, FNU, KODE, MR, N, YR, YI, NZ, TOL, ELIM, ALIM
	}
	// RECUR BACKWARD FOR REMAINDER OF I SEQUENCE AND ADD IN THE
	// K FUNCTIONS, SCALING THE I SEQUENCE DURING RECURRENCE TO KEEP
	// INTERMEDIATE ARITHMETIC ON SCALE NEAR EXPONENT EXTREMES.
	S1R = CYR[1]
	S1I = CYI[1]
	S2R = CYR[2]
	S2I = CYI[2]
	CSR = CSRR[IFLAG]
	ASCLE = BRY[IFLAG]
	FN = float64(float32(INU + IL))
	for I = 1; I <= IL; I++ {
		C2R = S2R
		C2I = S2I
		S2R = S1R + (FN+FNF)*(RZR*C2R-RZI*C2I)
		S2I = S1I + (FN+FNF)*(RZR*C2I+RZI*C2R)
		S1R = C2R
		S1I = C2I
		FN = FN - 1.0e0
		C2R = S2R * CSR
		C2I = S2I * CSR
		CKR = C2R
		CKI = C2I
		C1R = YR[KK]
		C1I = YI[KK]
		if KODE == 1 {
			goto L280
		}
		ZRR, ZRI, C1R, C1I, C2R, C2I, NW, ASC, ALIM, IUF = ZS1S2(ZRR, ZRI, C1R, C1I, C2R, C2I, NW, ASC, ALIM, IUF)
		NZ = NZ + NW
	L280:
		YR[KK] = C1R*CSPNR - C1I*CSPNI + C2R
		YI[KK] = C1R*CSPNI + C1I*CSPNR + C2I
		KK = KK - 1
		CSPNR = -CSPNR
		CSPNI = -CSPNI
		if IFLAG >= 3 {
			continue
		}
		C2R = math.Abs(CKR)
		C2I = math.Abs(CKI)
		C2M = math.Max(C2R, C2I)
		if C2M <= ASCLE {
			continue
		}
		IFLAG = IFLAG + 1
		ASCLE = BRY[IFLAG]
		S1R = S1R * CSR
		S1I = S1I * CSR
		S2R = CKR
		S2I = CKI
		S1R = S1R * CSSR[IFLAG]
		S1I = S1I * CSSR[IFLAG]
		S2R = S2R * CSSR[IFLAG]
		S2I = S2I * CSSR[IFLAG]
		CSR = CSRR[IFLAG]
	}
	return ZR, ZI, FNU, KODE, MR, N, YR, YI, NZ, TOL, ELIM, ALIM
L300:
	NZ = -1
	return ZR, ZI, FNU, KODE, MR, N, YR, YI, NZ, TOL, ELIM, ALIM

}

// ZUNK2 COMPUTES K(FNU,Z) AND ITS ANALYTIC CONTINUATION FROM THE
// RIGHT HALF PLANE TO THE LEFT HALF PLANE BY MEANS OF THE
// UNIFORM ASYMPTOTIC EXPANSIONS FOR H(KIND,FNU,ZN) AND J(FNU,ZN)
// WHERE ZN IS IN THE RIGHT HALF PLANE, KIND=(3-MR)/2, MR=+1 OR
// -1. HERE ZN=ZR*I OR -ZR*I WHERE ZR=Z IF Z IS IN THE RIGHT
// HALF PLANE OR ZR=-Z IF Z IS IN THE LEFT HALF PLANE. MR INDIC-
// ATES THE DIRECTION OF ROTATION FOR ANALYTIC CONTINUATION.
// NZ=-1 MEANS AN OVERFLOW WILL OCCUR
func ZUNK2(ZR float64, ZI float64, FNU float64, KODE int, MR int, N int, YR []float64, YI []float64, NZ int, TOL float64, ELIM float64, ALIM float64) (float64, float64, float64, int, int, int, []float64, []float64, int, float64, float64, float64) {

	const (
		ZEROR = 0.0e0
		ZEROI = 0.0e0
		CONER = 1.0e0
		CR1R  = 1.0e0
		CR1I  = 1.73205080756887729e0
		CR2R  = -0.5e0
		CR2I  = -8.66025403784438647e-01
		HPI   = 1.57079632679489662e+00
		AIC   = 1.26551212348464539e+00
	)

	var AARG, AII, AIR, ANG, APHI, ARGDI,
		ARGDR, ASC, ASCLE, ASUMDI, ASUMDR,
		BSUMDI, BSUMDR, CAR, CKI, CKR,
		CRSC, CSCL, CSGNI, CSI,
		CSPNI, CSPNR, CSR, C1I, C1R, C2I, C2M,
		C2R, DAII, DAIR, FMR, FN, FNF, PHIDI, PHIDR,
		PTI, PTR, RAST, RAZR, RS1, RZI, RZR, SAR, SGN,
		STI, STR, S1I, S1R, S2I, S2R, YY, ZBI, ZBR,
		ZET1DI, ZET1DR, ZET2DI, ZET2DR, ZNI, ZNR, ZRI, ZRR float64

	var I, IB, IFLAG, IFN, IL, IN, INU, IUF, K, KDFLG, KFLAG, KK, NAI, NDAI, NW, IDUM, J, IPARD, IC int

	BRY := []float64{math.NaN(), 0, 0, 0}
	ASUMR := []float64{math.NaN(), 0, 0}
	ASUMI := []float64{math.NaN(), 0, 0}
	BSUMR := []float64{math.NaN(), 0, 0}
	BSUMI := []float64{math.NaN(), 0, 0}
	PHIR := []float64{math.NaN(), 0, 0}
	PHII := []float64{math.NaN(), 0, 0}
	ARGR := []float64{math.NaN(), 0, 0}
	ARGI := []float64{math.NaN(), 0, 0}

	ZETA1R := []float64{math.NaN(), 0, 0}
	ZETA1I := []float64{math.NaN(), 0, 0}
	ZETA2R := []float64{math.NaN(), 0, 0}
	ZETA2I := []float64{math.NaN(), 0, 0}
	CYR := []float64{math.NaN(), 0, 0}
	CYI := []float64{math.NaN(), 0, 0}
	CSSR := []float64{math.NaN(), 0, 0, 0}
	CSRR := []float64{math.NaN(), 0, 0, 0}
	CIPR := []float64{math.NaN(), 1.0e0, 0.0e0, -1.0e0, 0.0e0}
	CIPI := []float64{math.NaN(), 0.0e0, -1.0e0, 0.0e0, 1.0e0}

	KDFLG = 1
	NZ = 0

	// EXP(-ALIM)=EXP(-ELIM)/TOL=APPROX. ONE PRECISION GREATER THAN
	// THE UNDERFLOW LIMIT
	CSCL = 1.0e0 / TOL
	CRSC = TOL
	CSSR[1] = CSCL
	CSSR[2] = CONER
	CSSR[3] = CRSC
	CSRR[1] = CRSC
	CSRR[2] = CONER
	CSRR[3] = CSCL
	BRY[1] = 1000e0 * machine.D1MACH[1] / TOL
	BRY[2] = 1.0e0 / BRY[1]
	BRY[3] = machine.D1MACH[2]
	ZRR = ZR
	ZRI = ZI
	if ZR >= 0.0e0 {
		goto L10
	}
	ZRR = -ZR
	ZRI = -ZI
L10:
	YY = ZRI
	ZNR = ZRI
	ZNI = -ZRR
	ZBR = ZRR
	ZBI = ZRI
	INU = int(float32(FNU))
	FNF = FNU - float64(float32(INU))
	ANG = -HPI * FNF
	CAR = math.Cos(ANG)
	SAR = math.Sin(ANG)
	C2R = HPI * SAR
	C2I = -HPI * CAR
	KK = INU%4 + 1
	STR = C2R*CIPR[KK] - C2I*CIPI[KK]
	STI = C2R*CIPI[KK] + C2I*CIPR[KK]
	CSR = CR1R*STR - CR1I*STI
	CSI = CR1R*STI + CR1I*STR
	if YY > 0.0e0 {
		goto L20
	}
	ZNR = -ZNR
	ZBI = -ZBI
L20:
	// K(FNU,Z) IS COMPUTED FROM H(2,FNU,-I*Z) WHERE Z IS IN THE FIRST
	// QUADRANT. FOURTH QUADRANT VALUES (YY <= 0.0E0) ARE COMPUTED BY
	// CONJUGATION SINCE THE K FUNCTION IS REAL ON THE POSITIVE REAL AXIS
	J = 2
	for I = 1; I <= N; I++ {
		// J FLIP FLOPS BETWEEN 1 AND 2 IN J = 3 - J
		J = 3 - J
		FN = FNU + float64(float32(I-1))
		ZNR, ZNI, FN, _, TOL, PHIR[J], PHII[J], ARGR[J], ARGI[J], ZETA1R[J], ZETA1I[J], ZETA2R[J], ZETA2I[J], ASUMR[J], ASUMI[J], BSUMR[J], BSUMI[J] = ZUNHJ(ZNR, ZNI, FN, 0, TOL, PHIR[J], PHII[J], ARGR[J], ARGI[J], ZETA1R[J], ZETA1I[J], ZETA2R[J], ZETA2I[J], ASUMR[J], ASUMI[J], BSUMR[J], BSUMI[J])
		if KODE == 1 {
			goto L30
		}
		STR = ZBR + ZETA2R[J]
		STI = ZBI + ZETA2I[J]
		RAST = FN / ZABS(STR, STI)
		STR = STR * RAST * RAST
		STI = -STI * RAST * RAST
		S1R = ZETA1R[J] - STR
		S1I = ZETA1I[J] - STI
		goto L40
	L30:
		S1R = ZETA1R[J] - ZETA2R[J]
		S1I = ZETA1I[J] - ZETA2I[J]
	L40:
		// TEST FOR UNDERFLOW AND OVERFLOW
		RS1 = S1R
		if math.Abs(RS1) > ELIM {
			goto L70
		}
		if KDFLG == 1 {
			KFLAG = 2
		}
		if math.Abs(RS1) < ALIM {
			goto L50
		}
		// REFINE  TEST AND SCALE
		APHI = ZABS(PHIR[J], PHII[J])
		AARG = ZABS(ARGR[J], ARGI[J])
		RS1 = RS1 + math.Log(APHI) - 0.25e0*math.Log(AARG) - AIC
		if math.Abs(RS1) > ELIM {
			goto L70
		}
		if KDFLG == 1 {
			KFLAG = 1
		}
		if RS1 < 0.0e0 {
			goto L50
		}
		if KDFLG == 1 {
			KFLAG = 3
		}
	L50:
		// SCALE S1 TO KEEP INTERMEDIATE ARITHMETIC ON SCALE NEAR
		// EXPONENT EXTREMES
		C2R = ARGR[J]*CR2R - ARGI[J]*CR2I
		C2I = ARGR[J]*CR2I + ARGI[J]*CR2R
		AIR, AII, NAI, IDUM = ZAIRY(C2R, C2I, 0, 2)
		DAIR, DAII, NDAI, IDUM = ZAIRY(C2R, C2I, 1, 2)
		STR = DAIR*BSUMR[J] - DAII*BSUMI[J]
		STI = DAIR*BSUMI[J] + DAII*BSUMR[J]
		PTR = STR*CR2R - STI*CR2I
		PTI = STR*CR2I + STI*CR2R
		STR = PTR + (AIR*ASUMR[J] - AII*ASUMI[J])
		STI = PTI + (AIR*ASUMI[J] + AII*ASUMR[J])
		PTR = STR*PHIR[J] - STI*PHII[J]
		PTI = STR*PHII[J] + STI*PHIR[J]
		S2R = PTR*CSR - PTI*CSI
		S2I = PTR*CSI + PTI*CSR
		STR = math.Exp(S1R) * CSSR[KFLAG]
		S1R = STR * math.Cos(S1I)
		S1I = STR * math.Sin(S1I)
		STR = S2R*S1R - S2I*S1I
		S2I = S1R*S2I + S2R*S1I
		S2R = STR
		if KFLAG != 1 {
			goto L60
		}
		S2R, S2I, NW, BRY[1], TOL = ZUCHK(S2R, S2I, NW, BRY[1], TOL)
		if NW != 0 {
			goto L70
		}
	L60:
		if YY <= 0.0e0 {
			S2I = -S2I
		}
		CYR[KDFLG] = S2R
		CYI[KDFLG] = S2I
		YR[I] = S2R * CSRR[KFLAG]
		YI[I] = S2I * CSRR[KFLAG]
		STR = CSI
		CSI = -CSR
		CSR = STR
		if KDFLG == 2 {
			goto L85
		}
		KDFLG = 2
		continue
	L70:
		if RS1 > 0.0e0 {
			goto L320
		}
		// FOR ZR < 0.0, THE I FUNCTION TO BE ADDED WILL OVERFLOW
		if ZR < 0.0e0 {
			goto L320
		}
		KDFLG = 1
		YR[I] = ZEROR
		YI[I] = ZEROI
		NZ = NZ + 1
		STR = CSI
		CSI = -CSR
		CSR = STR
		if I == 1 {
			continue
		}
		if (YR[I-1] == ZEROR) && (YI[I-1] == ZEROI) {
			continue
		}
		YR[I-1] = ZEROR
		YI[I-1] = ZEROI
		NZ = NZ + 1
	}
	I = N
L85:
	RAZR = 1.0e0 / ZABS(ZRR, ZRI)
	STR = ZRR * RAZR
	STI = -ZRI * RAZR
	RZR = (STR + STR) * RAZR
	RZI = (STI + STI) * RAZR
	CKR = FN * RZR
	CKI = FN * RZI
	IB = I + 1
	if N < IB {
		goto L180
	}

	// TEST LAST MEMBER FOR UNDERFLOW AND OVERFLOW. SET SEQUENCE TO ZERO
	// ON UNDERFLOW.
	FN = FNU + float64(float32(N-1))
	IPARD = 1
	if MR != 0 {
		IPARD = 0
	}
	ZNR, ZNI, FN, IPARD, TOL, PHIDR, PHIDI, ARGDR, ARGDI, ZET1DR, ZET1DI, ZET2DR, ZET2DI, ASUMDR, ASUMDI, BSUMDR, BSUMDI = ZUNHJ(ZNR, ZNI, FN, IPARD, TOL, PHIDR, PHIDI, ARGDR, ARGDI, ZET1DR, ZET1DI, ZET2DR, ZET2DI, ASUMDR, ASUMDI, BSUMDR, BSUMDI)
	if KODE == 1 {
		goto L90
	}
	STR = ZBR + ZET2DR
	STI = ZBI + ZET2DI
	RAST = FN / ZABS(STR, STI)
	STR = STR * RAST * RAST
	STI = -STI * RAST * RAST
	S1R = ZET1DR - STR
	S1I = ZET1DI - STI
	goto L100
L90:
	S1R = ZET1DR - ZET2DR
	S1I = ZET1DI - ZET2DI
L100:
	RS1 = S1R
	if math.Abs(RS1) > ELIM {
		goto L105
	}
	if math.Abs(RS1) < ALIM {
		goto L120
	}

	// REFINE ESTIMATE AND TEST
	APHI = ZABS(PHIDR, PHIDI)
	RS1 = RS1 + math.Log(APHI)
	if math.Abs(RS1) < ELIM {
		goto L120
	}
L105:
	if RS1 > 0.0e0 {
		goto L320
	}
	// FOR ZR < 0.0, THE I FUNCTION TO BE ADDED WILL OVERFLOW
	if ZR < 0.0e0 {
		goto L320
	}
	NZ = N
	for I = 1; I <= N; I++ {
		YR[I] = ZEROR
		YI[I] = ZEROI
	}
	return ZR, ZI, FNU, KODE, MR, N, YR, YI, NZ, TOL, ELIM, ALIM
L120:
	S1R = CYR[1]
	S1I = CYI[1]
	S2R = CYR[2]
	S2I = CYI[2]
	C1R = CSRR[KFLAG]
	ASCLE = BRY[KFLAG]
	for I = IB; I <= N; I++ {
		C2R = S2R
		C2I = S2I
		S2R = CKR*C2R - CKI*C2I + S1R
		S2I = CKR*C2I + CKI*C2R + S1I
		S1R = C2R
		S1I = C2I
		CKR = CKR + RZR
		CKI = CKI + RZI
		C2R = S2R * C1R
		C2I = S2I * C1R
		YR[I] = C2R
		YI[I] = C2I
		if KFLAG >= 3 {
			continue
		}
		STR = math.Abs(C2R)
		STI = math.Abs(C2I)
		C2M = math.Max(STR, STI)
		if C2M <= ASCLE {
			continue
		}
		KFLAG = KFLAG + 1
		ASCLE = BRY[KFLAG]
		S1R = S1R * C1R
		S1I = S1I * C1R
		S2R = C2R
		S2I = C2I
		S1R = S1R * CSSR[KFLAG]
		S1I = S1I * CSSR[KFLAG]
		S2R = S2R * CSSR[KFLAG]
		S2I = S2I * CSSR[KFLAG]
		C1R = CSRR[KFLAG]
	}
L180:
	if MR == 0 {
		return ZR, ZI, FNU, KODE, MR, N, YR, YI, NZ, TOL, ELIM, ALIM
	}

	// ANALYTIC CONTINUATION FOR RE(Z) < 0.0e0
	NZ = 0
	FMR = float64(float32(MR))
	SGN = -math.Copysign(math.Pi, FMR)

	// CSPN AND CSGN ARE COEFF OF K AND I FUNCIONS RESP.
	CSGNI = SGN
	if YY <= 0.0e0 {
		CSGNI = -CSGNI
	}
	IFN = INU + N - 1
	ANG = FNF * SGN
	CSPNR = math.Cos(ANG)
	CSPNI = math.Sin(ANG)
	if IFN%2 == 0 {
		goto L190
	}
	CSPNR = -CSPNR
	CSPNI = -CSPNI
L190:
	// CS=COEFF OF THE J FUNCTION TO GET THE I FUNCTION. I(FNU,Z) IS
	// COMPUTED FROM EXP(I*FNU*HPI)*J(FNU,-I*Z) WHERE Z IS IN THE FIRST
	// QUADRANT. FOURTH QUADRANT VALUES (YY <= 0.0E0) ARE COMPUTED BY
	// CONJUGATION SINCE THE I FUNCTION IS REAL ON THE POSITIVE REAL AXIS
	CSR = SAR * CSGNI
	CSI = CAR * CSGNI
	IN = IFN%4 + 1
	C2R = CIPR[IN]
	C2I = CIPI[IN]
	STR = CSR*C2R + CSI*C2I
	CSI = -CSR*C2I + CSI*C2R
	CSR = STR
	ASC = BRY[1]
	IUF = 0
	KK = N
	KDFLG = 1
	IB = IB - 1
	IC = IB - 1
	for K = 1; K <= N; K++ {
		FN = FNU + float64(float32(KK-1))
		// LOGIC TO SORT OUT CASES WHOSE PARAMETERS WERE SET FOR THE K
		// FUNCTION ABOVE
		if N > 2 {
			goto L175
		}
	L172:
		PHIDR = PHIR[J]
		PHIDI = PHII[J]
		ARGDR = ARGR[J]
		ARGDI = ARGI[J]
		ZET1DR = ZETA1R[J]
		ZET1DI = ZETA1I[J]
		ZET2DR = ZETA2R[J]
		ZET2DI = ZETA2I[J]
		ASUMDR = ASUMR[J]
		ASUMDI = ASUMI[J]
		BSUMDR = BSUMR[J]
		BSUMDI = BSUMI[J]
		J = 3 - J
		goto L210
	L175:
		if (KK == N) && (IB < N) {
			goto L210
		}
		if (KK == IB) || (KK == IC) {
			goto L172
		}
		ZNR, ZNI, FN, _, TOL, PHIDR, PHIDI, ARGDR, ARGDI, ZET1DR, ZET1DI, ZET2DR, ZET2DI, ASUMDR, ASUMDI, BSUMDR, BSUMDI = ZUNHJ(ZNR, ZNI, FN, 0, TOL, PHIDR, PHIDI, ARGDR, ARGDI, ZET1DR, ZET1DI, ZET2DR, ZET2DI, ASUMDR, ASUMDI, BSUMDR, BSUMDI)
	L210:
		if KODE == 1 {
			goto L220
		}
		STR = ZBR + ZET2DR
		STI = ZBI + ZET2DI
		RAST = FN / ZABS(STR, STI)
		STR = STR * RAST * RAST
		STI = -STI * RAST * RAST
		S1R = -ZET1DR + STR
		S1I = -ZET1DI + STI
		goto L230
	L220:
		S1R = -ZET1DR + ZET2DR
		S1I = -ZET1DI + ZET2DI
	L230:
		// TEST FOR UNDERFLOW AND OVERFLOW
		RS1 = S1R
		if math.Abs(RS1) > ELIM {
			goto L280
		}
		if KDFLG == 1 {
			IFLAG = 2
		}
		if math.Abs(RS1) < ALIM {
			goto L240
		}
		// REFINE  TEST AND SCALE
		APHI = ZABS(PHIDR, PHIDI)
		AARG = ZABS(ARGDR, ARGDI)
		RS1 = RS1 + math.Log(APHI) - 0.25e0*math.Log(AARG) - AIC
		if math.Abs(RS1) > ELIM {
			goto L280
		}
		if KDFLG == 1 {
			IFLAG = 1
		}
		if RS1 < 0.0e0 {
			goto L240
		}
		if KDFLG == 1 {
			IFLAG = 3
		}
	L240:
		AIR, AII, NAI, IDUM = ZAIRY(AIR, AII, NAI, IDUM)
		DAIR, DAII, NDAI, IDUM = ZAIRY(DAIR, DAII, NDAI, IDUM)
		STR = DAIR*BSUMDR - DAII*BSUMDI
		STI = DAIR*BSUMDI + DAII*BSUMDR
		STR = STR + (AIR*ASUMDR - AII*ASUMDI)
		STI = STI + (AIR*ASUMDI + AII*ASUMDR)
		PTR = STR*PHIDR - STI*PHIDI
		PTI = STR*PHIDI + STI*PHIDR
		S2R = PTR*CSR - PTI*CSI
		S2I = PTR*CSI + PTI*CSR
		STR = math.Exp(S1R) * CSSR[IFLAG]
		S1R = STR * math.Cos(S1I)
		S1I = STR * math.Sin(S1I)
		STR = S2R*S1R - S2I*S1I
		S2I = S2R*S1I + S2I*S1R
		S2R = STR
		if IFLAG != 1 {
			goto L250
		}
		S2R, S2I, NW, BRY[1], TOL = ZUCHK(S2R, S2I, NW, BRY[1], TOL)
		if NW == 0 {
			goto L250
		}
		S2R = ZEROR
		S2I = ZEROI
	L250:
		if YY <= 0.0e0 {
			S2I = -S2I
		}
		CYR[KDFLG] = S2R
		CYI[KDFLG] = S2I
		C2R = S2R
		C2I = S2I
		S2R = S2R * CSRR[IFLAG]
		S2I = S2I * CSRR[IFLAG]

		// ADD I AND K FUNCTIONS, K SEQUENCE IN Y(I), I=1,N
		S1R = YR[KK]
		S1I = YI[KK]
		if KODE == 1 {
			goto L270
		}
		ZRR, ZRI, S1R, S1I, S2R, S2I, NW, ASC, ALIM, IUF = ZS1S2(ZRR, ZRI, S1R, S1I, S2R, S2I, NW, ASC, ALIM, IUF)
		NZ = NZ + NW
	L270:
		YR[KK] = S1R*CSPNR - S1I*CSPNI + S2R
		YI[KK] = S1R*CSPNI + S1I*CSPNR + S2I
		KK = KK - 1
		CSPNR = -CSPNR
		CSPNI = -CSPNI
		STR = CSI
		CSI = -CSR
		CSR = STR
		if C2R != 0.0e0 || C2I != 0.0e0 {
			goto L255
		}
		KDFLG = 1
		continue
	L255:
		if KDFLG == 2 {
			goto L295
		}
		KDFLG = 2
		continue
	L280:
		if RS1 > 0.0e0 {
			goto L320
		}
		S2R = ZEROR
		S2I = ZEROI
		goto L250
	}
	K = N
L295:
	IL = N - K
	if IL == 0 {
		return ZR, ZI, FNU, KODE, MR, N, YR, YI, NZ, TOL, ELIM, ALIM
	}

	// RECUR BACKWARD FOR REMAINDER OF I SEQUENCE AND ADD IN THE
	// K FUNCTIONS, SCALING THE I SEQUENCE DURING RECURRENCE TO KEEP
	// INTERMEDIATE ARITHMETIC ON SCALE NEAR EXPONENT EXTREMES.
	S1R = CYR[1]
	S1I = CYI[1]
	S2R = CYR[2]
	S2I = CYI[2]
	CSR = CSRR[IFLAG]
	ASCLE = BRY[IFLAG]
	FN = float64(float32(INU + IL))
	for I = 1; I < IL; I++ {
		C2R = S2R
		C2I = S2I
		S2R = S1R + (FN+FNF)*(RZR*C2R-RZI*C2I)
		S2I = S1I + (FN+FNF)*(RZR*C2I+RZI*C2R)
		S1R = C2R
		S1I = C2I
		FN = FN - 1.0e0
		C2R = S2R * CSR
		C2I = S2I * CSR
		CKR = C2R
		CKI = C2I
		C1R = YR[KK]
		C1I = YI[KK]
		if KODE == 1 {
			goto L300
		}
		ZRR, ZRI, C1R, C1I, C2R, C2I, NW, ASC, ALIM, IUF = ZS1S2(ZRR, ZRI, C1R, C1I, C2R, C2I, NW, ASC, ALIM, IUF)
		NZ = NZ + NW
	L300:
		YR[KK] = C1R*CSPNR - C1I*CSPNI + C2R
		YI[KK] = C1R*CSPNI + C1I*CSPNR + C2I
		KK = KK - 1
		CSPNR = -CSPNR
		CSPNI = -CSPNI
		if IFLAG >= 3 {
			continue
		}
		C2R = math.Abs(CKR)
		C2I = math.Abs(CKI)
		C2M = math.Max(C2R, C2I)
		if C2M <= ASCLE {
			continue
		}
		IFLAG = IFLAG + 1
		ASCLE = BRY[IFLAG]
		S1R = S1R * CSR
		S1I = S1I * CSR
		S2R = CKR
		S2I = CKI
		S1R = S1R * CSSR[IFLAG]
		S1I = S1I * CSSR[IFLAG]
		S2R = S2R * CSSR[IFLAG]
		S2I = S2I * CSSR[IFLAG]
		CSR = CSRR[IFLAG]
	}
	return ZR, ZI, FNU, KODE, MR, N, YR, YI, NZ, TOL, ELIM, ALIM
L320:
	NZ = -1
	return ZR, ZI, FNU, KODE, MR, N, YR, YI, NZ, TOL, ELIM, ALIM
}

// ZBESJ COMPUTE THE J-BESSEL FUNCTION OF A COMPLEX ARGUMENT
//
// ON KODE=1, CBESJ COMPUTES AN N MEMBER  SEQUENCE OF COMPLEX
// BESSEL FUNCTIONS CY(I)=J(FNU+I-1,Z) FOR REAL, NONNEGATIVE
// ORDERS FNU+I-1, I=1,...,N AND COMPLEX Z IN THE CUT PLANE
// -PI < ARG(Z) <=  PI. ON KODE=2, CBESJ RETURNS THE SCALED
// FUNCTIONS
//
// CY(I)=EXP(-ABS(Y))*J(FNU+I-1,Z)   I = 1,...,N , Y=AIMAG(Z)
//
// WHICH REMOVE THE EXPONENTIAL GROWTH IN BOTH THE UPPER AND
// LOWER HALF PLANES FOR Z TO INFINITY. DEFINITIONS AND NOTATION
// ARE FOUND IN THE NBS HANDBOOK OF MATHEMATICAL FUNCTIONS
// (REF. 1).
//
// INPUT      ZR,ZI,FNU ARE DOUBLE PRECISION
//   ZR,ZI  - Z=CMPLX(ZR,ZI),  -PI < ARG(Z) <=  PI
//   FNU    - ORDER OF INITIAL J FUNCTION, FNU >= 0.0e0
//   KODE   - A PARAMETER TO INDICATE THE SCALING OPTION
//            KODE= 1  RETURNS
//                     CY(I)=J(FNU+I-1,Z), I=1,...,N
//                = 2  RETURNS
//                     CY(I)=J(FNU+I-1,Z)EXP(-ABS(Y)), I=1,...,N
//   N      - NUMBER OF MEMBERS OF THE SEQUENCE, N >= 1
//
// OUTPUT     CYR,CYI ARE DOUBLE PRECISION
//   CYR,CYI- DOUBLE PRECISION VECTORS WHOSE FIRST N COMPONENTS
//            CONTAIN REAL AND IMAGINARY PARTS FOR THE SEQUENCE
//            CY(I)=J(FNU+I-1,Z)  OR
//            CY(I)=J(FNU+I-1,Z)EXP(-ABS(Y))  I=1,...,N
//            DEPENDING ON KODE, Y=AIMAG(Z).
//   NZ     - NUMBER OF COMPONENTS SET TO ZERO DUE TO UNDERFLOW,
//            NZ= 0   , NORMAL RETURN
//            NZ > 0 , LAST NZ COMPONENTS OF CY SET  ZERO DUE
//                      TO UNDERFLOW, CY(I)=CMPLX(0.0e0,0.0e0),
//                      I = N-NZ+1,...,N
//   IERR   - ERROR FLAG
//            IERR=0, NORMAL RETURN - COMPUTATION COMPLETED
//            IERR=1, INPUT ERROR   - NO COMPUTATION
//            IERR=2, OVERFLOW      - NO COMPUTATION, AIMAG(Z)
//                    TOO LARGE ON KODE=1
//            IERR=3, CABS(Z) OR FNU+N-1 LARGE - COMPUTATION DONE
//                    BUT LOSSES OF SIGNIFCANCE BY ARGUMENT
//                    REDUCTION PRODUCE LESS THAN HALF OF MACHINE
//                    ACCURACY
//            IERR=4, CABS(Z) OR FNU+N-1 TOO LARGE - NO COMPUTA-
//                    TION BECAUSE OF COMPLETE LOSSES OF SIGNIFI-
//                    CANCE BY ARGUMENT REDUCTION
//            IERR=5, ERROR              - NO COMPUTATION,
//                    ALGORITHM TERMINATION CONDITION NOT MET
func ZBESJ(ZR float64, ZI float64, FNU float64, KODE int, N int, CYR []float64, CYI []float64, NZ int, IERR int) (float64, float64, float64, int, int, []float64, []float64, int, int) {

	// THE COMPUTATION IS CARRIED OUT BY THE FORMULA
	//
	// J(FNU,Z)=EXP( FNU*PI*I/2)*I(FNU,-I*Z)    AIMAG(Z) >= 0.0
	//
	// J(FNU,Z)=EXP(-FNU*PI*I/2)*I(FNU, I*Z)    AIMAG(Z) < 0.0
	//
	// WHERE I**2 = -1 AND I(FNU,Z) IS THE I BESSEL FUNCTION.
	//
	// FOR NEGATIVE ORDERS,THE FORMULA
	//
	//      J(-FNU,Z) = J(FNU,Z)*COS(PI*FNU) - Y(FNU,Z)*SIN(PI*FNU)
	//
	// CAN BE USED. HOWEVER,FOR LARGE ORDERS CLOSE TO INTEGERS, THE
	// THE FUNCTION CHANGES RADICALLY. WHEN FNU IS A LARGE POSITIVE
	// INTEGER,THE MAGNITUDE OF J(-FNU,Z)=J(FNU,Z)*COS(PI*FNU) IS A
	// LARGE NEGATIVE POWER OF TEN. BUT WHEN FNU IS NOT AN INTEGER,
	// Y(FNU,Z) DOMINATES IN MAGNITUDE WITH A LARGE POSITIVE POWER OF
	// TEN AND THE MOST THAT THE SECOND TERM CAN BE REDUCED IS BY
	// UNIT ROUNDOFF FROM THE COEFFICIENT. THUS, WIDE CHANGES CAN
	// OCCUR WITHIN UNIT ROUNDOFF OF A LARGE INTEGER FOR FNU. HERE,
	// LARGE MEANS FNU > CABS(Z).
	//
	// IN MOST COMPLEX VARIABLE COMPUTATION, ONE MUST EVALUATE ELE-
	// MENTARY FUNCTIONS. WHEN THE MAGNITUDE OF Z OR FNU+N-1 IS
	// LARGE, LOSSES OF SIGNIFICANCE BY ARGUMENT REDUCTION OCCUR.
	// CONSEQUENTLY, IF EITHER ONE EXCEEDS U1=SQRT(0.5/UR), THEN
	// LOSSES EXCEEDING HALF PRECISION ARE LIKELY AND AN ERROR FLAG
	// IERR=3 IS TRIGGERED WHERE UR=math.Max(machine.D1MACH[4),1.0e-18) IS
	// DOUBLE PRECISION UNIT ROUNDOFF LIMITED TO 18 DIGITS PRECISION.
	// IF EITHER IS LARGER THAN U2=0.5/UR, THEN ALL SIGNIFICANCE IS
	// LOST AND IERR=4. IN ORDER TO USE THE INT FUNCTION, ARGUMENTS
	// MUST BE FURTHER RESTRICTED NOT TO EXCEED THE LARGEST MACHINE
	// INTEGER, U3=machine.I1MACH[9). THUS, THE MAGNITUDE OF Z AND FNU+N-1 IS
	// RESTRICTED BY MIN(U2,U3). ON 32 BIT MACHINES, U1,U2, AND U3
	// ARE APPROXIMATELY 2.0E+3, 4.2E+6, 2.1E+9 IN SINGLE PRECISION
	// ARITHMETIC AND 1.3E+8, 1.8E+16, 2.1E+9 IN DOUBLE PRECISION
	// ARITHMETIC RESPECTIVELY. THIS MAKES U2 AND U3 LIMITING IN
	// THEIR RESPECTIVE ARITHMETICS. THIS MEANS THAT ONE CAN EXPECT
	// TO RETAIN, IN THE WORST CASES ON 32 BIT MACHINES, NO DIGITS
	// IN SINGLE AND ONLY 7 DIGITS IN DOUBLE PRECISION ARITHMETIC.
	// SIMILAR CONSIDERATIONS HOLD FOR OTHER MACHINES.
	//
	// THE APPROXIMATE RELATIVE ERROR IN THE MAGNITUDE OF A COMPLEX
	// BESSEL FUNCTION CAN BE EXPRESSED BY P*10**S WHERE P=MAX(UNIT
	// ROUNDOFF,1.0E-18) IS THE NOMINAL PRECISION AND 10**S REPRE-
	// SENTS THE INCREASE IN ERROR DUE TO ARGUMENT REDUCTION IN THE
	// ELEMENTARY FUNCTIONS. HERE, S=MAX(1,ABS(LOG10(CABS(Z))),
	// ABS(LOG10(FNU))) APPROXIMATELY (I.E. S=MAX(1,ABS(EXPONENT OF
	// CABS(Z),ABS(EXPONENT OF FNU)) ). HOWEVER, THE PHASE ANGLE MAY
	// HAVE ONLY ABSOLUTE ACCURACY. THIS IS MOST LIKELY TO OCCUR WHEN
	// ONE COMPONENT (IN ABSOLUTE VALUE) IS LARGER THAN THE OTHER BY
	// SEVERAL ORDERS OF MAGNITUDE. IF ONE COMPONENT IS 10**K LARGER
	// THAN THE OTHER, THEN ONE CAN EXPECT ONLY MAX(ABS(LOG10(P))-K,
	// 0) SIGNIFICANT DIGITS; OR, STATED ANOTHER WAY, WHEN K EXCEEDS
	// THE EXPONENT OF P, NO SIGNIFICANT DIGITS REMAIN IN THE SMALLER
	// COMPONENT. HOWEVER, THE PHASE ANGLE RETAINS ABSOLUTE ACCURACY
	// BECAUSE, IN COMPLEX ARITHMETIC WITH PRECISION P, THE SMALLER
	// COMPONENT WILL NOT (AS A RULE) DECREASE BELOW P TIMES THE
	// MAGNITUDE OF THE LARGER COMPONENT. IN THESE EXTREME CASES,
	// THE PRINCIPAL PHASE ANGLE IS ON THE ORDER OF +P, -P, PI/2-P,
	// OR -PI/2+P.
	//
	// REFERENCES  HANDBOOK OF MATHEMATICAL FUNCTIONS BY M. ABRAMOWITZ
	//         AND I. A. STEGUN, NBS AMS SERIES 55, U.S. DEPT. OF
	//         COMMERCE, 1955.
	//
	//       COMPUTATION OF BESSEL FUNCTIONS OF COMPLEX ARGUMENT
	//         BY D. E. AMOS, SAND83-0083, MAY, 1983.
	//
	//       COMPUTATION OF BESSEL FUNCTIONS OF COMPLEX ARGUMENT
	//         AND LARGE ORDER BY D. E. AMOS, SAND83-0643, MAY, 1983
	//
	//       A SUBROUTINE PACKAGE FOR BESSEL FUNCTIONS OF A COMPLEX
	//         ARGUMENT AND NONNEGATIVE ORDER BY D. E. AMOS, SAND85-
	//         1018, MAY, 1985
	//
	//       A PORTABLE PACKAGE FOR BESSEL FUNCTIONS OF A COMPLEX
	//         ARGUMENT AND NONNEGATIVE ORDER BY D. E. AMOS, TRANS.
	//         MATH. SOFTWARE, 1986

	const (
		HPI = 1.57079632679489662e+00
	)
	var AA, ALIM, ARG, CII, CSGNI, CSGNR, DIG,
		ELIM, FNUL, RL, R1M5, STR, TOL, ZNI, ZNR,
		BB, FN, AZ, ASCLE, RTOL, ATOL, STI float64

	var I, INU, INUH, IR, K, K1, K2, NL int

	IERR = 0
	NZ = 0
	if FNU < 0.0e0 {
		IERR = 1
	}
	if KODE < 1 || KODE > 2 {
		IERR = 1
	}
	if N < 1 {
		IERR = 1
	}
	if IERR != 0 {
		return ZR, ZI, FNU, KODE, N, CYR, CYI, NZ, IERR
	}

	// SET PARAMETERS RELATED TO MACHINE CONSTANTS.
	// TOL IS THE APPROXIMATE UNIT ROUNDOFF LIMITED TO 1.0E-18.
	// ELIM IS THE APPROXIMATE EXPONENTIAL OVER- AND UNDERFLOW LIMIT.
	// EXP(-ELIM) < EXP(-ALIM)=EXP(-ELIM)/TOL    AND
	// EXP(ELIM) > EXP(ALIM)=EXP(ELIM)*TOL       ARE INTERVALS NEAR
	// UNDERFLOW AND OVERFLOW LIMITS WHERE SCALED ARITHMETIC IS DONE.
	// RL IS THE LOWER BOUNDARY OF THE ASYMPTOTIC EXPANSION FOR LARGE Z.
	// DIG = NUMBER OF BASE 10 DIGITS IN TOL = 10**(-DIG).
	// FNUL IS THE LOWER BOUNDARY OF THE ASYMPTOTIC SERIES FOR LARGE FNU.

	TOL = math.Max(machine.D1MACH[4], 1.0e-18)
	K1 = machine.I1MACH[15]
	K2 = machine.I1MACH[16]
	R1M5 = machine.D1MACH[5]
	K = MIN(ABS(K1), ABS(K2))
	ELIM = 2.303e0 * (float64(float32(K))*R1M5 - 3.0e0)
	K1 = machine.I1MACH[14] - 1
	AA = R1M5 * float64(float32(K1))
	DIG = math.Min(AA, 18.0e0)
	AA = AA * 2.303e0
	ALIM = ELIM + math.Max(-AA, -41.45e0)
	RL = 1.2e0*DIG + 3.0e0
	FNUL = 10.0e0 + 6.0e0*(DIG-3.0e0)

	// TEST FOR PROPER RANGE
	AZ = ZABS(ZR, ZI)
	FN = FNU + float64(float32(N-1))
	AA = 0.5e0 / TOL
	BB = float64(float32(machine.I1MACH[9])) * 0.5e0
	AA = math.Min(AA, BB)
	if AZ > AA {
		goto L260
	}
	if FN > AA {
		goto L260
	}
	AA = math.Sqrt(AA)
	if AZ > AA {
		IERR = 3
	}
	if FN > AA {
		IERR = 3
	}

	// CALCULATE CSGN=EXP(FNU*HPI*I) TO MINIMIZE LOSSES OF SIGNIFICANCE
	// WHEN FNU IS LARGE
	CII = 1.0e0
	INU = int(float32(FNU))
	INUH = INU / 2
	IR = INU - 2*INUH
	ARG = (FNU - float64(float32(INU-IR))) * HPI
	CSGNR = math.Cos(ARG)
	CSGNI = math.Sin(ARG)
	if INUH%2 == 0 {
		goto L40
	}
	CSGNR = -CSGNR
	CSGNI = -CSGNI
L40:
	// ZN IS IN THE RIGHT HALF PLANE
	ZNR = ZI
	ZNI = -ZR
	if ZI >= 0.0e0 {
		goto L50
	}
	ZNR = -ZNR
	ZNI = -ZNI
	CSGNI = -CSGNI
	CII = -CII
L50:
	ZNR, ZNI, FNU, KODE, N, CYR, CYI, NZ, RL, FNUL, TOL, ELIM, ALIM = ZBINU(ZNR, ZNI, FNU, KODE, N, CYR, CYI, NZ, RL, FNUL, TOL, ELIM, ALIM)
	if NZ < 0 {
		goto L130
	}
	NL = N - NZ
	if NL == 0 {
		return ZR, ZI, FNU, KODE, N, CYR, CYI, NZ, IERR
	}
	RTOL = 1.0e0 / TOL
	ASCLE = machine.D1MACH[1] * RTOL * 1000e0
	for I = 1; I <= NL; I++ {

		//   STR = CYR(I)*CSGNR - CYI(I)*CSGNI
		//   CYI(I) = CYR(I)*CSGNI + CYI(I)*CSGNR
		//   CYR(I) = STR
		AA = CYR[I]
		BB = CYI[I]
		ATOL = 1.0e0
		if math.Max(math.Abs(AA), math.Abs(BB)) > ASCLE {
			goto L55
		}
		AA = AA * RTOL
		BB = BB * RTOL
		ATOL = TOL
	L55:
		STR = AA*CSGNR - BB*CSGNI
		STI = AA*CSGNI + BB*CSGNR
		CYR[I] = STR * ATOL
		CYI[I] = STI * ATOL
		STR = -CSGNI * CII
		CSGNI = CSGNR * CII
		CSGNR = STR
	}

	return ZR, ZI, FNU, KODE, N, CYR, CYI, NZ, IERR
L130:
	if NZ == -2 {
		goto L140
	}
	NZ = 0
	IERR = 2
	return ZR, ZI, FNU, KODE, N, CYR, CYI, NZ, IERR
L140:
	NZ = 0
	IERR = 5
	return ZR, ZI, FNU, KODE, N, CYR, CYI, NZ, IERR
L260:
	NZ = 0
	IERR = 4
	return ZR, ZI, FNU, KODE, N, CYR, CYI, NZ, IERR
}

// ZBESK COMPUTES K-BESSEL FUNCTIONS OF COMPLEX ARGUMENT
//
// ON KODE=1, CBESK COMPUTES AN N MEMBER SEQUENCE OF COMPLEX
// BESSEL FUNCTIONS CY(J)=K(FNU+J-1,Z) FOR REAL, NONNEGATIVE
// ORDERS FNU+J-1, J=1,...,N AND COMPLEX Z != CMPLX(0.0,0.0)
// IN THE CUT PLANE -PI < ARG(Z) <=  PI. ON KODE=2, CBESK
// RETURNS THE SCALED K FUNCTIONS,
//
// CY(J)=EXP(Z)*K(FNU+J-1,Z) , J=1,...,N,
//
// WHICH REMOVE THE EXPONENTIAL BEHAVIOR IN BOTH THE LEFT AND
// RIGHT HALF PLANES FOR Z TO INFINITY. DEFINITIONS AND
// NOTATION ARE FOUND IN THE NBS HANDBOOK OF MATHEMATICAL
// FUNCTIONS (REF. 1).
//
// INPUT      ZR,ZI,FNU ARE DOUBLE PRECISION
//   ZR,ZI  - Z=CMPLX(ZR,ZI), Z != CMPLX(0.0e0,0.0e0),
//            -PI < ARG(Z) <=  PI
//   FNU    - ORDER OF INITIAL K FUNCTION, FNU >= 0.0e0
//   N      - NUMBER OF MEMBERS OF THE SEQUENCE, N >= 1
//   KODE   - A PARAMETER TO INDICATE THE SCALING OPTION
//            KODE= 1  RETURNS
//                     CY(I)=K(FNU+I-1,Z), I=1,...,N
//                = 2  RETURNS
//                     CY(I)=K(FNU+I-1,Z)*EXP(Z), I=1,...,N
//
// OUTPUT     CYR,CYI ARE DOUBLE PRECISION
//   CYR,CYI- DOUBLE PRECISION VECTORS WHOSE FIRST N COMPONENTS
//            CONTAIN REAL AND IMAGINARY PARTS FOR THE SEQUENCE
//            CY(I)=K(FNU+I-1,Z), I=1,...,N OR
//            CY(I)=K(FNU+I-1,Z)*EXP(Z), I=1,...,N
//            DEPENDING ON KODE
//   NZ     - NUMBER OF COMPONENTS SET TO ZERO DUE TO UNDERFLOW.
//            NZ= 0   , NORMAL RETURN
//            NZ > 0 , FIRST NZ COMPONENTS OF CY SET TO ZERO DUE
//                      TO UNDERFLOW, CY(I)=CMPLX(0.0e0,0.0e0),
//                      I=1,...,N WHEN X >= 0.0. WHEN X < 0.0
//                      NZ STATES ONLY THE NUMBER OF UNDERFLOWS
//                      IN THE SEQUENCE.
//
//   IERR   - ERROR FLAG
//            IERR=0, NORMAL RETURN - COMPUTATION COMPLETED
//            IERR=1, INPUT ERROR   - NO COMPUTATION
//            IERR=2, OVERFLOW      - NO COMPUTATION, FNU IS
//                    TOO LARGE OR CABS(Z) IS TOO SMALL OR BOTH
//            IERR=3, CABS(Z) OR FNU+N-1 LARGE - COMPUTATION DONE
//                    BUT LOSSES OF SIGNIFCANCE BY ARGUMENT
//                    REDUCTION PRODUCE LESS THAN HALF OF MACHINE
//                    ACCURACY
//            IERR=4, CABS(Z) OR FNU+N-1 TOO LARGE - NO COMPUTA-
//                    TION BECAUSE OF COMPLETE LOSSES OF SIGNIFI-
//                    CANCE BY ARGUMENT REDUCTION
//            IERR=5, ERROR              - NO COMPUTATION,
//                    ALGORITHM TERMINATION CONDITION NOT MET
func ZBESK(ZR float64, ZI float64, FNU float64, KODE int, N int, CYR []float64, CYI []float64, NZ int, IERR int) (float64, float64, float64, int, int, []float64, []float64, int, int) {

	// EQUATIONS OF THE REFERENCE ARE IMPLEMENTED FOR SMALL ORDERS
	// DNU AND DNU+1.0 IN THE RIGHT HALF PLANE X >= 0.0. FORWARD
	// RECURRENCE GENERATES HIGHER ORDERS. K IS CONTINUED TO THE LEFT
	// HALF PLANE BY THE RELATION
	//
	// K(FNU,Z*EXP(MP)) = EXP(-MP*FNU)*K(FNU,Z)-MP*I(FNU,Z)
	// MP=MR*PI*I, MR=+1 OR -1, RE(Z) > 0, I**2=-1
	//
	// WHERE I(FNU,Z) IS THE I BESSEL FUNCTION.
	//
	// FOR LARGE ORDERS, FNU > FNUL, THE K FUNCTION IS COMPUTED
	// BY MEANS OF ITS UNIFORM ASYMPTOTIC EXPANSIONS.
	//
	// FOR NEGATIVE ORDERS, THE FORMULA
	//
	//               K(-FNU,Z) = K(FNU,Z)
	//
	// CAN BE USED.
	//
	// CBESK ASSUMES THAT A SIGNIFICANT DIGIT SINH(X) FUNCTION IS
	// AVAILABLE.
	//
	// IN MOST COMPLEX VARIABLE COMPUTATION, ONE MUST EVALUATE ELE-
	// MENTARY FUNCTIONS. WHEN THE MAGNITUDE OF Z OR FNU+N-1 IS
	// LARGE, LOSSES OF SIGNIFICANCE BY ARGUMENT REDUCTION OCCUR.
	// CONSEQUENTLY, IF EITHER ONE EXCEEDS U1=SQRT(0.5/UR), THEN
	// LOSSES EXCEEDING HALF PRECISION ARE LIKELY AND AN ERROR FLAG
	// IERR=3 IS TRIGGERED WHERE UR=math.Max(machine.D1MACH[4),1.0e-18) IS
	// DOUBLE PRECISION UNIT ROUNDOFF LIMITED TO 18 DIGITS PRECISION.
	// IF EITHER IS LARGER THAN U2=0.5/UR, THEN ALL SIGNIFICANCE IS
	// LOST AND IERR=4. IN ORDER TO USE THE INT FUNCTION, ARGUMENTS
	// MUST BE FURTHER RESTRICTED NOT TO EXCEED THE LARGEST MACHINE
	// INTEGER, U3=machine.I1MACH[9). THUS, THE MAGNITUDE OF Z AND FNU+N-1 IS
	// RESTRICTED BY MIN(U2,U3). ON 32 BIT MACHINES, U1,U2, AND U3
	// ARE APPROXIMATELY 2.0E+3, 4.2E+6, 2.1E+9 IN SINGLE PRECISION
	// ARITHMETIC AND 1.3E+8, 1.8E+16, 2.1E+9 IN DOUBLE PRECISION
	// ARITHMETIC RESPECTIVELY. THIS MAKES U2 AND U3 LIMITING IN
	// THEIR RESPECTIVE ARITHMETICS. THIS MEANS THAT ONE CAN EXPECT
	// TO RETAIN, IN THE WORST CASES ON 32 BIT MACHINES, NO DIGITS
	// IN SINGLE AND ONLY 7 DIGITS IN DOUBLE PRECISION ARITHMETIC.
	// SIMILAR CONSIDERATIONS HOLD FOR OTHER MACHINES.
	//
	// THE APPROXIMATE RELATIVE ERROR IN THE MAGNITUDE OF A COMPLEX
	// BESSEL FUNCTION CAN BE EXPRESSED BY P*10**S WHERE P=MAX(UNIT
	// ROUNDOFF,1.0E-18) IS THE NOMINAL PRECISION AND 10**S REPRE-
	// SENTS THE INCREASE IN ERROR DUE TO ARGUMENT REDUCTION IN THE
	// ELEMENTARY FUNCTIONS. HERE, S=MAX(1,ABS(LOG10(CABS(Z))),
	// ABS(LOG10(FNU))) APPROXIMATELY (I.E. S=MAX(1,ABS(EXPONENT OF
	// CABS(Z),ABS(EXPONENT OF FNU)) ). HOWEVER, THE PHASE ANGLE MAY
	// HAVE ONLY ABSOLUTE ACCURACY. THIS IS MOST LIKELY TO OCCUR WHEN
	// ONE COMPONENT (IN ABSOLUTE VALUE) IS LARGER THAN THE OTHER BY
	// SEVERAL ORDERS OF MAGNITUDE. IF ONE COMPONENT IS 10**K LARGER
	// THAN THE OTHER, THEN ONE CAN EXPECT ONLY MAX(ABS(LOG10(P))-K,
	// 0) SIGNIFICANT DIGITS; OR, STATED ANOTHER WAY, WHEN K EXCEEDS
	// THE EXPONENT OF P, NO SIGNIFICANT DIGITS REMAIN IN THE SMALLER
	// COMPONENT. HOWEVER, THE PHASE ANGLE RETAINS ABSOLUTE ACCURACY
	// BECAUSE, IN COMPLEX ARITHMETIC WITH PRECISION P, THE SMALLER
	// COMPONENT WILL NOT (AS A RULE) DECREASE BELOW P TIMES THE
	// MAGNITUDE OF THE LARGER COMPONENT. IN THESE EXTREME CASES,
	// THE PRINCIPAL PHASE ANGLE IS ON THE ORDER OF +P, -P, PI/2-P,
	// OR -PI/2+P.
	//
	// REFERENCES  HANDBOOK OF MATHEMATICAL FUNCTIONS BY M. ABRAMOWITZ
	//         AND I. A. STEGUN, NBS AMS SERIES 55, U.S. DEPT. OF
	//         COMMERCE, 1955.
	//
	//       COMPUTATION OF BESSEL FUNCTIONS OF COMPLEX ARGUMENT
	//         BY D. E. AMOS, SAND83-0083, MAY, 1983.
	//
	//       COMPUTATION OF BESSEL FUNCTIONS OF COMPLEX ARGUMENT
	//         AND LARGE ORDER BY D. E. AMOS, SAND83-0643, MAY, 1983.
	//
	//       A SUBROUTINE PACKAGE FOR BESSEL FUNCTIONS OF A COMPLEX
	//         ARGUMENT AND NONNEGATIVE ORDER BY D. E. AMOS, SAND85-
	//         1018, MAY, 1985
	//
	//       A PORTABLE PACKAGE FOR BESSEL FUNCTIONS OF A COMPLEX
	//         ARGUMENT AND NONNEGATIVE ORDER BY D. E. AMOS, TRANS.
	//         MATH. SOFTWARE, 1986

	var AA, ALIM, ALN, ARG, AZ, DIG, ELIM, FN,
		FNUL, RL, R1M5, TOL, UFL, BB float64
	var K, K1, K2, MR, NN, NUF, NW int

	IERR = 0
	NZ = 0
	if ZI == 0.0e0 && ZR == 0.0e0 {
		IERR = 1
	}
	if FNU < 0.0e0 {
		IERR = 1
	}
	if KODE < 1 || KODE > 2 {
		IERR = 1
	}
	if N < 1 {
		IERR = 1
	}
	if IERR != 0 {
		return ZR, ZI, FNU, KODE, N, CYR, CYI, NZ, IERR
	}
	NN = N

	// SET PARAMETERS RELATED TO MACHINE CONSTANTS.
	// TOL IS THE APPROXIMATE UNIT ROUNDOFF LIMITED TO 1.0E-18.
	// ELIM IS THE APPROXIMATE EXPONENTIAL OVER- AND UNDERFLOW LIMIT.
	// EXP(-ELIM) < EXP(-ALIM)=EXP(-ELIM)/TOL    AND
	// EXP(ELIM) > EXP(ALIM)=EXP(ELIM)*TOL       ARE INTERVALS NEAR
	// UNDERFLOW AND OVERFLOW LIMITS WHERE SCALED ARITHMETIC IS DONE.
	// RL IS THE LOWER BOUNDARY OF THE ASYMPTOTIC EXPANSION FOR LARGE Z.
	// DIG = NUMBER OF BASE 10 DIGITS IN TOL = 10**(-DIG).
	// FNUL IS THE LOWER BOUNDARY OF THE ASYMPTOTIC SERIES FOR LARGE FNU
	TOL = math.Max(machine.D1MACH[4], 1.0e-18)
	K1 = machine.I1MACH[15]
	K2 = machine.I1MACH[16]
	R1M5 = machine.D1MACH[5]
	K = MIN(ABS(K1), ABS(K2))
	ELIM = 2.303e0 * (float64(float32(K))*R1M5 - 3.0e0)
	K1 = machine.I1MACH[14] - 1
	AA = R1M5 * float64(float32(K1))
	DIG = math.Min(AA, 18.0e0)
	AA = AA * 2.303e0
	ALIM = ELIM + math.Max(-AA, -41.45e0)
	FNUL = 10.0e0 + 6.0e0*(DIG-3.0e0)
	RL = 1.2e0*DIG + 3.0e0

	// TEST FOR PROPER RANGE
	AZ = ZABS(ZR, ZI)
	FN = FNU + float64(float32(NN-1))
	AA = 0.5e0 / TOL
	BB = float64(float32(machine.I1MACH[9])) * 0.5e0
	AA = math.Min(AA, BB)
	if AZ > AA {
		goto L260
	}
	if FN > AA {
		goto L260
	}
	AA = math.Sqrt(AA)
	if AZ > AA {
		IERR = 3
	}
	if FN > AA {
		IERR = 3
	}

	// OVERFLOW TEST ON THE LAST MEMBER OF THE SEQUENCE

	// UFL = DEXP(-ELIM)
	UFL = machine.D1MACH[1] * 1000.0e0
	if AZ < UFL {
		goto L180
	}
	if FNU > FNUL {
		goto L80
	}
	if FN <= 1.0e0 {
		goto L60
	}
	if FN > 2.0e0 {
		goto L50
	}
	if AZ > TOL {
		goto L60
	}
	ARG = 0.5e0 * AZ
	ALN = -FN * math.Log(ARG)
	if ALN > ELIM {
		goto L180
	}
	goto L60
L50:
	ZR, ZI, FNU, KODE, _, NN, CYR, CYI, NUF, TOL, ELIM, ALIM = ZUOIK(ZR, ZI, FNU, KODE, 2, NN, CYR, CYI, NUF, TOL, ELIM, ALIM)
	if NUF < 0 {
		goto L180
	}
	NZ = NZ + NUF
	NN = NN - NUF

	// HERE NN=N OR NN=0 SINCE NUF=0,NN, OR -1 ON RETURN FROM CUOIK
	// IF NUF=NN, THEN CY(I)=CZERO FOR ALL I
	if NN == 0 {
		goto L100
	}
L60:
	if ZR < 0.0e0 {
		goto L70
	}

	// RIGHT HALF PLANE COMPUTATION, REAL(Z) >= 0.
	ZR, ZI, FNU, KODE, NN, CYR, CYI, NW, TOL, ELIM, ALIM = ZBKNU(ZR, ZI, FNU, KODE, NN, CYR, CYI, NW, TOL, ELIM, ALIM)
	if NW < 0 {
		goto L200
	}
	NZ = NW
	return ZR, ZI, FNU, KODE, N, CYR, CYI, NZ, IERR

	// LEFT HALF PLANE COMPUTATION
	// PI/2 < ARG(Z) <=  PI AND -PI < ARG(Z) < -PI/2.
L70:
	if NZ != 0 {
		goto L180
	}
	MR = 1
	if ZI < 0.0e0 {
		MR = -1
	}
	ZR, ZI, FNU, KODE, MR, NN, CYR, CYI, NW, RL, FNUL, TOL, ELIM, ALIM = ZACON(ZR, ZI, FNU, KODE, MR, NN, CYR, CYI, NW, RL, FNUL, TOL, ELIM, ALIM)
	if NW < 0 {
		goto L200
	}
	NZ = NW
	return ZR, ZI, FNU, KODE, N, CYR, CYI, NZ, IERR

	// UNIFORM ASYMPTOTIC EXPANSIONS FOR FNU > FNUL
L80:
	MR = 0
	if ZR >= 0.0e0 {
		goto L90
	}
	MR = 1
	if ZI < 0.0e0 {
		MR = -1
	}
L90:
	ZR, ZI, FNU, KODE, MR, NN, CYR, CYI, NW, TOL, ELIM, ALIM = ZBUNK(ZR, ZI, FNU, KODE, MR, NN, CYR, CYI, NW, TOL, ELIM, ALIM)
	if NW < 0 {
		goto L200
	}
	NZ = NZ + NW
	return ZR, ZI, FNU, KODE, N, CYR, CYI, NZ, IERR
L100:
	if ZR < 0.0e0 {
		goto L180
	}
	return ZR, ZI, FNU, KODE, N, CYR, CYI, NZ, IERR
L180:
	NZ = 0
	IERR = 2
	return ZR, ZI, FNU, KODE, N, CYR, CYI, NZ, IERR
L200:
	if NW == (-1) {
		goto L180
	}
	NZ = 0
	IERR = 5
	return ZR, ZI, FNU, KODE, N, CYR, CYI, NZ, IERR
L260:
	NZ = 0
	IERR = 4
	return ZR, ZI, FNU, KODE, N, CYR, CYI, NZ, IERR
}

// ZBESY COMPUTEs THE Y-BESSEL FUNCTION OF A COMPLEX ARGUMENT
//
// ON KODE=1, CBESY COMPUTES AN N MEMBER SEQUENCE OF COMPLEX
// BESSEL FUNCTIONS CY(I)=Y(FNU+I-1,Z) FOR REAL, NONNEGATIVE
// ORDERS FNU+I-1, I=1,...,N AND COMPLEX Z IN THE CUT PLANE
// -PI < ARG(Z) <=  PI. ON KODE=2, CBESY RETURNS THE SCALED
// FUNCTIONS
//
// CY(I)=EXP(-ABS(Y))*Y(FNU+I-1,Z)   I = 1,...,N , Y=AIMAG(Z)
//
// WHICH REMOVE THE EXPONENTIAL GROWTH IN BOTH THE UPPER AND
// LOWER HALF PLANES FOR Z TO INFINITY. DEFINITIONS AND NOTATION
// ARE FOUND IN THE NBS HANDBOOK OF MATHEMATICAL FUNCTIONS
// (REF. 1).
//
// INPUT      ZR,ZI,FNU ARE DOUBLE PRECISION
//   ZR,ZI  - Z=CMPLX(ZR,ZI), Z != CMPLX(0.0e0,0.0e0),
//            -PI < ARG(Z) <=  PI
//   FNU    - ORDER OF INITIAL Y FUNCTION, FNU >= 0.0e0
//   KODE   - A PARAMETER TO INDICATE THE SCALING OPTION
//            KODE= 1  RETURNS
//                     CY(I)=Y(FNU+I-1,Z), I=1,...,N
//                = 2  RETURNS
//                     CY(I)=Y(FNU+I-1,Z)*EXP(-ABS(Y)), I=1,...,N
//                     WHERE Y=AIMAG(Z)
//   N      - NUMBER OF MEMBERS OF THE SEQUENCE, N >= 1
//   CWRKR, - DOUBLE PRECISION WORK VECTORS OF DIMENSION AT
//   CWRKI    AT LEAST N
//
// OUTPUT     CYR,CYI ARE DOUBLE PRECISION
//   CYR,CYI- DOUBLE PRECISION VECTORS WHOSE FIRST N COMPONENTS
//            CONTAIN REAL AND IMAGINARY PARTS FOR THE SEQUENCE
//            CY(I)=Y(FNU+I-1,Z)  OR
//            CY(I)=Y(FNU+I-1,Z)*EXP(-ABS(Y))  I=1,...,N
//            DEPENDING ON KODE.
//   NZ     - NZ=0 , A NORMAL RETURN
//            NZ > 0 , NZ COMPONENTS OF CY SET TO ZERO DUE TO
//            UNDERFLOW (GENERALLY ON KODE=2)
//   IERR   - ERROR FLAG
//            IERR=0, NORMAL RETURN - COMPUTATION COMPLETED
//            IERR=1, INPUT ERROR   - NO COMPUTATION
//            IERR=2, OVERFLOW      - NO COMPUTATION, FNU IS
//                    TOO LARGE OR CABS(Z) IS TOO SMALL OR BOTH
//            IERR=3, CABS(Z) OR FNU+N-1 LARGE - COMPUTATION DONE
//                    BUT LOSSES OF SIGNIFCANCE BY ARGUMENT
//                    REDUCTION PRODUCE LESS THAN HALF OF MACHINE
//                    ACCURACY
//            IERR=4, CABS(Z) OR FNU+N-1 TOO LARGE - NO COMPUTA-
//                    TION BECAUSE OF COMPLETE LOSSES OF SIGNIFI-
//                    CANCE BY ARGUMENT REDUCTION
//            IERR=5, ERROR              - NO COMPUTATION,
//                    ALGORITHM TERMINATION CONDITION NOT MET
func ZBESY(ZR float64, ZI float64, FNU float64, KODE int, N int, CYR []float64, CYI []float64, NZ int, CWRKR []float64, CWRKI []float64, IERR int) (float64, float64, float64, int, int, []float64, []float64, int, []float64, []float64, int) {

	// THE COMPUTATION IS CARRIED OUT BY THE FORMULA
	//
	// Y(FNU,Z)=0.5*(H(1,FNU,Z)-H(2,FNU,Z))/I
	//
	// WHERE I**2 = -1 AND THE HANKEL BESSEL FUNCTIONS H(1,FNU,Z)
	// AND H(2,FNU,Z) ARE CALCULATED IN CBESH.
	//
	// FOR NEGATIVE ORDERS,THE FORMULA
	//
	//      Y(-FNU,Z) = Y(FNU,Z)*COS(PI*FNU) + J(FNU,Z)*SIN(PI*FNU)
	//
	// CAN BE USED. HOWEVER,FOR LARGE ORDERS CLOSE TO HALF ODD
	// INTEGERS THE FUNCTION CHANGES RADICALLY. WHEN FNU IS A LARGE
	// POSITIVE HALF ODD INTEGER,THE MAGNITUDE OF Y(-FNU,Z)=J(FNU,Z)*
	// SIN(PI*FNU) IS A LARGE NEGATIVE POWER OF TEN. BUT WHEN FNU IS
	// NOT A HALF ODD INTEGER, Y(FNU,Z) DOMINATES IN MAGNITUDE WITH A
	// LARGE POSITIVE POWER OF TEN AND THE MOST THAT THE SECOND TERM
	// CAN BE REDUCED IS BY UNIT ROUNDOFF FROM THE COEFFICIENT. THUS,
	// WIDE CHANGES CAN OCCUR WITHIN UNIT ROUNDOFF OF A LARGE HALF
	// ODD INTEGER. HERE, LARGE MEANS FNU > CABS(Z).
	//
	// IN MOST COMPLEX VARIABLE COMPUTATION, ONE MUST EVALUATE ELE-
	// MENTARY FUNCTIONS. WHEN THE MAGNITUDE OF Z OR FNU+N-1 IS
	// LARGE, LOSSES OF SIGNIFICANCE BY ARGUMENT REDUCTION OCCUR.
	// CONSEQUENTLY, IF EITHER ONE EXCEEDS U1=SQRT(0.5/UR), THEN
	// LOSSES EXCEEDING HALF PRECISION ARE LIKELY AND AN ERROR FLAG
	// IERR=3 IS TRIGGERED WHERE UR=math.Max(machine.D1MACH[4),1.0e-18) IS
	// DOUBLE PRECISION UNIT ROUNDOFF LIMITED TO 18 DIGITS PRECISION.
	// IF EITHER IS LARGER THAN U2=0.5/UR, THEN ALL SIGNIFICANCE IS
	// LOST AND IERR=4. IN ORDER TO USE THE INT FUNCTION, ARGUMENTS
	// MUST BE FURTHER RESTRICTED NOT TO EXCEED THE LARGEST MACHINE
	// INTEGER, U3=machine.I1MACH[9). THUS, THE MAGNITUDE OF Z AND FNU+N-1 IS
	// RESTRICTED BY MIN(U2,U3). ON 32 BIT MACHINES, U1,U2, AND U3
	// ARE APPROXIMATELY 2.0E+3, 4.2E+6, 2.1E+9 IN SINGLE PRECISION
	// ARITHMETIC AND 1.3E+8, 1.8E+16, 2.1E+9 IN DOUBLE PRECISION
	// ARITHMETIC RESPECTIVELY. THIS MAKES U2 AND U3 LIMITING IN
	// THEIR RESPECTIVE ARITHMETICS. THIS MEANS THAT ONE CAN EXPECT
	// TO RETAIN, IN THE WORST CASES ON 32 BIT MACHINES, NO DIGITS
	// IN SINGLE AND ONLY 7 DIGITS IN DOUBLE PRECISION ARITHMETIC.
	// SIMILAR CONSIDERATIONS HOLD FOR OTHER MACHINES.
	//
	// THE APPROXIMATE RELATIVE ERROR IN THE MAGNITUDE OF A COMPLEX
	// BESSEL FUNCTION CAN BE EXPRESSED BY P*10**S WHERE P=MAX(UNIT
	// ROUNDOFF,1.0E-18) IS THE NOMINAL PRECISION AND 10**S REPRE-
	// SENTS THE INCREASE IN ERROR DUE TO ARGUMENT REDUCTION IN THE
	// ELEMENTARY FUNCTIONS. HERE, S=MAX(1,ABS(LOG10(CABS(Z))),
	// ABS(LOG10(FNU))) APPROXIMATELY (I.E. S=MAX(1,ABS(EXPONENT OF
	// CABS(Z),ABS(EXPONENT OF FNU)) ). HOWEVER, THE PHASE ANGLE MAY
	// HAVE ONLY ABSOLUTE ACCURACY. THIS IS MOST LIKELY TO OCCUR WHEN
	// ONE COMPONENT (IN ABSOLUTE VALUE) IS LARGER THAN THE OTHER BY
	// SEVERAL ORDERS OF MAGNITUDE. IF ONE COMPONENT IS 10**K LARGER
	// THAN THE OTHER, THEN ONE CAN EXPECT ONLY MAX(ABS(LOG10(P))-K,
	// 0) SIGNIFICANT DIGITS; OR, STATED ANOTHER WAY, WHEN K EXCEEDS
	// THE EXPONENT OF P, NO SIGNIFICANT DIGITS REMAIN IN THE SMALLER
	// COMPONENT. HOWEVER, THE PHASE ANGLE RETAINS ABSOLUTE ACCURACY
	// BECAUSE, IN COMPLEX ARITHMETIC WITH PRECISION P, THE SMALLER
	// COMPONENT WILL NOT (AS A RULE) DECREASE BELOW P TIMES THE
	// MAGNITUDE OF THE LARGER COMPONENT. IN THESE EXTREME CASES,
	// THE PRINCIPAL PHASE ANGLE IS ON THE ORDER OF +P, -P, PI/2-P,
	// OR -PI/2+P.
	//
	// REFERENCES  HANDBOOK OF MATHEMATICAL FUNCTIONS BY M. ABRAMOWITZ
	//         AND I. A. STEGUN, NBS AMS SERIES 55, U.S. DEPT. OF
	//         COMMERCE, 1955.
	//
	//       COMPUTATION OF BESSEL FUNCTIONS OF COMPLEX ARGUMENT
	//         BY D. E. AMOS, SAND83-0083, MAY, 1983.
	//
	//       COMPUTATION OF BESSEL FUNCTIONS OF COMPLEX ARGUMENT
	//         AND LARGE ORDER BY D. E. AMOS, SAND83-0643, MAY, 1983
	//
	//       A SUBROUTINE PACKAGE FOR BESSEL FUNCTIONS OF A COMPLEX
	//         ARGUMENT AND NONNEGATIVE ORDER BY D. E. AMOS, SAND85-
	//         1018, MAY, 1985
	//
	//       A PORTABLE PACKAGE FOR BESSEL FUNCTIONS OF A COMPLEX
	//         ARGUMENT AND NONNEGATIVE ORDER BY D. E. AMOS, TRANS.
	//         MATH. SOFTWARE, 1986

	var C1I, C1R, C2I, C2R, ELIM, EXI, EXR, EY, HCII, R1M5, STI, STR, TAY, ASCLE, RTOL, ATOL, AA, BB, TOL float64
	var I, K, K1, K2, NZ1, NZ2 int

	IERR = 0
	NZ = 0
	if ZR == 0.0e0 && ZI == 0.0e0 {
		IERR = 1
	}
	if FNU < 0.0e0 {
		IERR = 1
	}
	if KODE < 1 || KODE > 2 {
		IERR = 1
	}
	if N < 1 {
		IERR = 1
	}
	if IERR != 0 {
		return ZR, ZI, FNU, KODE, N, CYR, CYI, NZ, CWRKR, CWRKI, IERR
	}
	HCII = 0.5e0
	ZR, ZI, FNU, KODE, _, N, CYR, CYI, NZ1, IERR = ZBESH(ZR, ZI, FNU, KODE, 1, N, CYR, CYI, NZ1, IERR)
	if IERR != 0 && IERR != 3 {
		goto L170
	}
	ZR, ZI, FNU, KODE, _, N, CWRKR, CWRKI, NZ2, IERR = ZBESH(ZR, ZI, FNU, KODE, 2, N, CWRKR, CWRKI, NZ2, IERR)
	if IERR != 0 && IERR != 3 {
		goto L170
	}
	NZ = MIN(NZ1, NZ2)
	if KODE == 2 {
		goto L60
	}
	for I = 1; I <= N; I++ {
		STR = CWRKR[I] - CYR[I]
		STI = CWRKI[I] - CYI[I]
		CYR[I] = -STI * HCII
		CYI[I] = STR * HCII
	}
	return ZR, ZI, FNU, KODE, N, CYR, CYI, NZ, CWRKR, CWRKI, IERR
L60:
	TOL = math.Max(machine.D1MACH[4], 1.0e-18)
	K1 = machine.I1MACH[15]
	K2 = machine.I1MACH[16]
	K = MIN(ABS(K1), ABS(K2))
	R1M5 = machine.D1MACH[5]

	// ELIM IS THE APPROXIMATE EXPONENTIAL UNDER- AND OVERFLOW LIMIT
	ELIM = 2.303e0 * (float64(float32(K))*R1M5 - 3.0e0)
	EXR = math.Cos(ZR)
	EXI = math.Sin(ZR)
	EY = 0.0e0
	TAY = math.Abs(ZI + ZI)
	if TAY < ELIM {
		EY = math.Exp(-TAY)
	}
	if ZI < 0.0e0 {
		goto L90
	}
	C1R = EXR * EY
	C1I = EXI * EY
	C2R = EXR
	C2I = -EXI
L70:
	NZ = 0
	RTOL = 1.0e0 / TOL
	ASCLE = machine.D1MACH[1] * RTOL * 1000.0e0
	for I = 1; I <= N; I++ {
		//   STR = C1R*CYR(I) - C1I*CYI(I)
		//   STI = C1R*CYI(I) + C1I*CYR(I)
		//   STR = -STR + C2R*CWRKR(I) - C2I*CWRKI(I)
		//   STI = -STI + C2R*CWRKI(I) + C2I*CWRKR(I)
		//   CYR(I) = -STI*HCII
		//   CYI(I) = STR*HCII
		AA = CWRKR[I]
		BB = CWRKI[I]
		ATOL = 1.0e0
		if math.Max(math.Abs(AA), math.Abs(BB)) > ASCLE {
			goto L75
		}
		AA = AA * RTOL
		BB = BB * RTOL
		ATOL = TOL
	L75:
		STR = (AA*C2R - BB*C2I) * ATOL
		STI = (AA*C2I + BB*C2R) * ATOL
		AA = CYR[I]
		BB = CYI[I]
		ATOL = 1.0e0
		if math.Max(math.Abs(AA), math.Abs(BB)) > ASCLE {
			goto L85
		}
		AA = AA * RTOL
		BB = BB * RTOL
		ATOL = TOL
	L85:
		STR = STR - (AA*C1R-BB*C1I)*ATOL
		STI = STI - (AA*C1I+BB*C1R)*ATOL
		CYR[I] = -STI * HCII
		CYI[I] = STR * HCII
		if STR == 0.0e0 && STI == 0.0e0 && EY == 0.0e0 {
			NZ = NZ + 1
		}
	}
	return ZR, ZI, FNU, KODE, N, CYR, CYI, NZ, CWRKR, CWRKI, IERR
L90:
	C1R = EXR
	C1I = EXI
	C2R = EXR * EY
	C2I = -EXI * EY
	goto L70
L170:
	NZ = 0
	return ZR, ZI, FNU, KODE, N, CYR, CYI, NZ, CWRKR, CWRKI, IERR
}
