// Copyright 2019 Infin IT Pty Ltd. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package amos_test

import (
	. "github.com/dreading/gospecfunc/bessel/internal/amos"
	"math"
	"testing"
)

func TestZBESH(t *testing.T) {
	testCases := []struct {
		α          float64
		kode, m, n int
		x, y       complex128
	}{
		// extended precision values computed using Mathematica
		{0.00, 1, 1, 1, 1, 0.7651976865579665514497175261026632209092742897553252418 + 0.08825696421567695798292676602351516282781752309067554671i},
		{2.00, 1, 1, 1, 0.75 - 0.75i, 1.0798261992096498876295467929919458008519826441628797726 - 0.54090933484017059182686757461203629371839519480775444538i},
		{2.00, 1, 1, 1, 0.75 + 0.75i, -1.053476390787392933122805327012746855287254952784286092 - 0.2605861026050603823088046945658155986159626229320885120i},
		{1.25, 1, 1, 1, 75 + 75i, -1.9247251946295874088544114732839933719832641099026e-34 + 7.9990631314254957714076851577823797996920648281887e-35i},
		{0.50, 1, 1, 1, -1 - 1i, 0.323099244779188375242885442046800758630027408670702 - 1.794951464930692261137043373938578831872923335613907i},
		{2.50, 1, 1, 1, 0.75 - 0.75i, 1.9460186316088613793436289685117901696545662575971048949 + 0.31385846950840913303716441049258209193668876274758270688i},
		{0.00, 1, 1, 1, 1e-19, 0.99999999999999999999999999999999999999750000000000000000 - 27.9253570525269413784402661820401607251961941715595049764i},
		{0.00, 1, 1, 2, 1, 0.7651976865579665514497175261026632209092742897553252418 + 0.08825696421567695798292676602351516282781752309067554671i},
		{2.00, 1, 1, 2, 0.75 - 0.75i, 1.0798261992096498876295467929919458008519826441628797726 - 0.54090933484017059182686757461203629371839519480775444538i},
		{2.00, 1, 1, 2, 0.75 + 0.75i, -1.053476390787392933122805327012746855287254952784286092 - 0.2605861026050603823088046945658155986159626229320885120i},
		{1.25, 1, 1, 2, 75 + 75i, -1.9247251946295874088544114732839933719832641099026e-34 + 7.9990631314254957714076851577823797996920648281887e-35i},
		{0.50, 1, 1, 2, -1 - 1i, 0.323099244779188375242885442046800758630027408670702 - 1.794951464930692261137043373938578831872923335613907i},
		{2.50, 1, 1, 2, 0.75 - 0.75i, 1.9460186316088613793436289685117901696545662575971048949 + 0.31385846950840913303716441049258209193668876274758270688i},
		{0.00, 1, 1, 2, 1e-19, 0.99999999999999999999999999999999999999750000000000000000 - 27.9253570525269413784402661820401607251961941715595049764i},
		{0.00, 1, 1, 3, 1, 0.7651976865579665514497175261026632209092742897553252418 + 0.08825696421567695798292676602351516282781752309067554671i},
		{2.00, 1, 1, 3, 0.75 - 0.75i, 1.0798261992096498876295467929919458008519826441628797726 - 0.54090933484017059182686757461203629371839519480775444538i},
		{2.00, 1, 1, 3, 0.75 + 0.75i, -1.053476390787392933122805327012746855287254952784286092 - 0.2605861026050603823088046945658155986159626229320885120i},
		{1.25, 1, 1, 3, 75 + 75i, -1.9247251946295874088544114732839933719832641099026e-34 + 7.9990631314254957714076851577823797996920648281887e-35i},
		{0.50, 1, 1, 3, -1 - 1i, 0.323099244779188375242885442046800758630027408670702 - 1.794951464930692261137043373938578831872923335613907i},
		{2.50, 1, 1, 3, 0.75 - 0.75i, 1.9460186316088613793436289685117901696545662575971048949 + 0.31385846950840913303716441049258209193668876274758270688i},
		{0.00, 1, 1, 3, 1e-19, 0.99999999999999999999999999999999999999750000000000000000 - 27.9253570525269413784402661820401607251961941715595049764i},
		{0.00, 2, 1, 1, 1, 0.48770374908695631836308738133058745712258693077093166555 - 0.59620620960600407144981219216668717558529366315691036762i},
		{2.00, 2, 1, 1, 1, -1.326918900901948524727452213317969542394493645112173208 - 0.9885555673427596851350488773161207595226003330752383517i},
		{2.00, 2, 1, 1, 0.75 - 0.75i, 0.19905150622945094148807297673110791707463556268369924020 - 0.53463803588129573648193110763794857626578041708802159850i},
		{2.00, 2, 1, 1, 0.75 - 0.75i, 0.19905150622945094148807297673110791707463556268369924020 - 0.53463803588129573648193110763794857626578041708802159850i},
		{0.00, 2, 1, 3, 1, 0.48770374908695631836308738133058745712258693077093166555 - 0.59620620960600407144981219216668717558529366315691036762i},
		{2.00, 2, 1, 3, 1, -1.326918900901948524727452213317969542394493645112173208 - 0.9885555673427596851350488773161207595226003330752383517i},
		{2.00, 2, 1, 3, 0.75 - 0.75i, 0.19905150622945094148807297673110791707463556268369924020 - 0.53463803588129573648193110763794857626578041708802159850i},
		{2.00, 2, 1, 3, 0.75 - 0.75i, 0.19905150622945094148807297673110791707463556268369924020 - 0.53463803588129573648193110763794857626578041708802159850i},

		// not extended precision
		{1.00, 1, 1, 1, 5e100, 0},
		{32769, 1, 1, 1, 1, 0},
		{1.00, 1, 1, 1, 32769, 0.004345932945920784 + -0.0007350969971507587i},
		{1.2e9, 1, 1, 1, 1, 0},
		{0, 1, 1, 1, 1e-306, 0},
		{2, 1, 1, 1, 1e-306, 0},
		{1.5, 1, 1, 1, 1e-19, 0 - 2.52313252202016004824714952236568394660659571899739e28i},
	}

	for _, tc := range testCases {
		CYR := []float64{math.NaN(), 0, 0, 0}
		CYI := []float64{math.NaN(), 0, 0, 0}
		var NZ, IERR int
		_, _, _, _, _, _, CYR, CYI, NZ, IERR = ZBESH(real(tc.x), imag(tc.x), tc.α, tc.kode, tc.m, tc.n, CYR, CYI, NZ, IERR)

		if close(CYR[1], real(tc.y)) == false {
			t.Fatalf("real(ZBESH(%v, %v, %v, %v, %v)): expected %v, got %v", tc.α, tc.x, tc.kode, tc.m, tc.n, real(tc.y), CYR[1])
		}
		if close(CYI[1], imag(tc.y)) == false {
			t.Fatalf("imag(ZBESH(%v,%v, %v, %v, %v)): expected %v, got %v", tc.α, tc.x, tc.kode, tc.m, tc.n, imag(tc.y), CYI[1])
		}
	}
}

func TestZBESHErr(t *testing.T) {
	testCases := []struct {
		α          float64
		kode, m, n int
		x          complex128
		ierr       int
	}{
		// extended precision values computed using Mathematica
		{0.00, 1, 1, 1, 0, 1},
		{-1.00, 1, 1, 1, 1, 1},
		{0.00, 1, 3, 1, 1, 1},
		{0.00, 1, 0, 1, 1, 1},
		{0.00, 3, 1, 1, 1, 1},
		{0.00, 0, 1, 1, 1, 1},
		{0.00, 1, 1, 0, 1, 1},
	}

	for _, tc := range testCases {
		CYR := []float64{math.NaN(), 0, 0, 0}
		CYI := []float64{math.NaN(), 0, 0, 0}
		var NZ, IERR int
		_, _, _, _, _, _, CYR, CYI, NZ, IERR = ZBESH(real(tc.x), imag(tc.x), tc.α, tc.kode, tc.m, tc.n, CYR, CYI, NZ, IERR)
		if IERR != tc.ierr {
			t.Fatalf("ZBESH(%v, %v, %v, %v, %v)): expected error flag %v, got %v", tc.α, tc.x, tc.kode, tc.m, tc.n, tc.ierr, IERR)
		}
	}
}

func TestZBESK(t *testing.T) {
	testCases := []struct {
		α       float64
		kode, n int
		x, y    complex128
	}{
		// extended precision values computed using Mathematica
		{0.00, 1, 1, 1, 0.421024438240708333335627379212609036136219748226660472298},
		{0.00, 1, 1, 0.4 + 0.1i, 1.0826035097235081563303065645729426351352961828491217647 - 0.21324459634740555852107854608689805665579172058695006929i},
		{2.50, 1, 1, -1 - 1i, 0.81740838955020351274340488272166961021804282493424837140 - 1.1762814200405309189093806024582991851908631533909975900i},
		{2.50, 1, 1, -1 + 1i, 0.81740838955020351274340488272166961021804282493424837140 + 1.1762814200405309189093806024582991851908631533909975900i},
		{2.50, 1, 1, 1 + 1i, -0.9730203208880581731806799234864631370588047705275199210 - 1.160002999791696943340858523335033177428742515466007164i},
		{25.00, 1, 1, 1 + 1i, 1.243920310213260987851496108498392250170999248421594e27 - 1.296860880863851282936708596501597343689035562826055e27i},
		{0.00, 1, 2, 1, 0.421024438240708333335627379212609036136219748226660472298},
		{0.00, 1, 2, 0.4 + 0.1i, 1.0826035097235081563303065645729426351352961828491217647 - 0.21324459634740555852107854608689805665579172058695006929i},
		{2.50, 1, 2, -1 - 1i, 0.81740838955020351274340488272166961021804282493424837140 - 1.1762814200405309189093806024582991851908631533909975900i},
		{2.50, 1, 2, -1 + 1i, 0.81740838955020351274340488272166961021804282493424837140 + 1.1762814200405309189093806024582991851908631533909975900i},
		{2.50, 1, 2, 1 + 1i, -0.9730203208880581731806799234864631370588047705275199210 - 1.160002999791696943340858523335033177428742515466007164i},
		{25.00, 1, 2, 1 + 1i, 1.243920310213260987851496108498392250170999248421594e27 - 1.296860880863851282936708596501597343689035562826055e27i},
		{0.00, 1, 3, 1, 0.421024438240708333335627379212609036136219748226660472298},
		{0.00, 1, 3, 0.4 + 0.1i, 1.0826035097235081563303065645729426351352961828491217647 - 0.21324459634740555852107854608689805665579172058695006929i},
		{2.50, 1, 3, -1 - 1i, 0.81740838955020351274340488272166961021804282493424837140 - 1.1762814200405309189093806024582991851908631533909975900i},
		{2.50, 1, 3, -1 + 1i, 0.81740838955020351274340488272166961021804282493424837140 + 1.1762814200405309189093806024582991851908631533909975900i},
		{2.50, 1, 3, 1 + 1i, -0.9730203208880581731806799234864631370588047705275199210 - 1.160002999791696943340858523335033177428742515466007164i},
		{25.00, 1, 3, 1 + 1i, 1.243920310213260987851496108498392250170999248421594e27 - 1.296860880863851282936708596501597343689035562826055e27i},
	}

	for _, tc := range testCases {
		CYR := []float64{math.NaN(), 0, 0, 0}
		CYI := []float64{math.NaN(), 0, 0, 0}
		var NZ, IERR int
		_, _, _, _, _, CYR, CYI, NZ, IERR = ZBESK(real(tc.x), imag(tc.x), tc.α, 1, 1, CYR, CYI, NZ, IERR)

		if close(CYR[1], real(tc.y)) == false {
			t.Fatalf("real(ZBESK(%v, %v, %v, %v)): expected %v, got %v", tc.α, tc.x, tc.kode, tc.n, real(tc.y), CYR[1])
		}
		if close(CYI[1], imag(tc.y)) == false {
			t.Fatalf("imag(ZBESK(%v,%v, %v, %v)): expected %v, got %v", tc.α, tc.x, tc.kode, tc.n, imag(tc.y), CYI[1])
		}
	}
}

// The floating point comparison tests are copied from from math/all_test.go.
func tolerance(a, b, e float64) bool {
	// Multiplying by e here can underflow denormal values to zero.
	// Check a==b so that at least if a and b are small and identical
	// we say they match.
	if a == b {
		return true
	}
	d := a - b
	if d < 0 {
		d = -d
	}
	// note: b is correct (expected) value, a is actual value.
	// make error tolerance a fraction of b, not a.
	if b != 0 {
		e = e * b
		if e < 0 {
			e = -e
		}
	}
	return d < e
}

func close(a, b float64) bool      { return tolerance(a, b, 1e-14) }
func veryclose(a, b float64) bool  { return tolerance(a, b, 5e-16) }
func soclose(a, b, e float64) bool { return tolerance(a, b, e) }
