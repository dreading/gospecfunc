package erf_test

import (
	. "github.com/dreading/gospecfunc/erf"
	"testing"
)


func TestErf(t *testing.T) {
	testCases := []struct {
		x, y complex128
	}{
		{0.5 + 0.5i, 0.64261291485482052831942135847199581467891706129770675079 + 0.45788139443519221584208890063522927648352418879876980026i},
	}

	for _, tc := range testCases {
		y := Erf(tc.x)
		if veryclose(real(y), real(tc.y)) == false {
			t.Fatalf("real(Feaddeyeva(%v)): expected %v, got %v", tc.x, real(tc.y), real(y))
		}
		if veryclose(imag(y), imag(tc.y)) == false {
			t.Fatalf("imag(Feaddeyeva(%v)): expected %v, got %v", tc.x, imag(tc.y), imag(y))
		}
	}
}


func TestDawson(t *testing.T) {
	testCases := []struct {
		x, y complex128
	}{
		{0.5 + 0.5i, 0.62914469771362783370956774548491213744194694694642085904 + 0.30523946561753882091323070230974006125244937735067903082i},
	}

	for _, tc := range testCases {
		y := Dawson(tc.x)
		if veryclose(real(y), real(tc.y)) == false {
			t.Fatalf("real(Feaddeyeva(%v)): expected %v, got %v", tc.x, real(tc.y), real(y))
		}
		if veryclose(imag(y), imag(tc.y)) == false {
			t.Fatalf("imag(Feaddeyeva(%v)): expected %v, got %v", tc.x, imag(tc.y), imag(y))
		}
	}
}

func TestErfi(t *testing.T) {
	testCases := []struct {
		x, y complex128
	}{
		{0.5 + 0.5i, 0.45788139443519221584208890063522927648352418879876980026 + 0.64261291485482052831942135847199581467891706129770675079i},
	}

	for _, tc := range testCases {
		y := Erfi(tc.x)
		if veryclose(real(y), real(tc.y)) == false {
			t.Fatalf("real(Feaddeyeva(%v)): expected %v, got %v", tc.x, real(tc.y), real(y))
		}
		if veryclose(imag(y), imag(tc.y)) == false {
			t.Fatalf("imag(Feaddeyeva(%v)): expected %v, got %v", tc.x, imag(tc.y), imag(y))
		}
	}
}


func TestErfc(t *testing.T) {
	testCases := []struct {
		x, y complex128
	}{
		{0.5 + 0.5i, 0.35738708514517947168057864152800418532108293870229324920 - 0.45788139443519221584208890063522927648352418879876980026i},
	}

	for _, tc := range testCases {
		y := Erfc(tc.x)
		if veryclose(real(y), real(tc.y)) == false {
			t.Fatalf("real(Feaddeyeva(%v)): expected %v, got %v", tc.x, real(tc.y), real(y))
		}
		if veryclose(imag(y), imag(tc.y)) == false {
			t.Fatalf("imag(Feaddeyeva(%v)): expected %v, got %v", tc.x, imag(tc.y), imag(y))
		}
	}
}

func TestFaddeyeva(t *testing.T) {
	testCases := []struct {
		x, y complex128
	}{
		{0.5 + 0.5i, 0.53315670791217491376822891204271112100489475433534083731 + 0.23048823138445840870767807113455955862989744369028872730i},
		{0.5 - 0.5i, 1.22200841586857051846433425316494818297839563988414726868 + 1.18933930859286440925425394156570233479350417957149007767i},
	}

	for _, tc := range testCases {
		y := Faddeyeva(tc.x)
		if veryclose(real(y), real(tc.y)) == false {
			t.Fatalf("real(Feaddeyeva(%v)): expected %v, got %v", tc.x, real(tc.y), real(y))
		}
		if veryclose(imag(y), imag(tc.y)) == false {
			t.Fatalf("imag(Feaddeyeva(%v)): expected %v, got %v", tc.x, imag(tc.y), imag(y))
		}
	}
}

func TestErfcxLargeNegative(t *testing.T) {

	testCases := []struct {
		x, y float64
	}{
		{-24.6438055098077, 1.1363627998302537408199038021823478437489991303892970e264},
		{-18.3606202026281, 5.0941755016494381919909749370853183247108146946632678e+146},
		{-9.72124040525614, 2.2026768805395279137105540037081856761793654217012477e+41},
		{-6.57964775166634, 1.2659147073374019834469401791473064878069367955720208e+19},
		{-5.7942495882689, 7.6162503596169089643842718139903640837346133123846494e14},
		{-3.43805509807655, 271948.8992883505292945176350662819469190070229287071247260},

		/*
			{-26.2146018366026,5.630165962410217e+298},
			{-25.4292036732051,1.3649741661779386e+281},
			{-24.6438055098077,1.1363627998278e+264},
			{-23.8584073464102,3.2486200893007e+247},
			{-23.0730091830128,3.1891150302566e+231},
			{-22.2876110196153,1.0750552499099e+216},
			{-21.5022128562179,1.2444593802227e+201},
			{-20.7168146928204,4.9467505195909e+186},
			{-19.931416529423,6.7522518383983e+172},
			{-19.1460183660255,3.1649481295467e+159},
			{-18.3606202026281,5.0941755016438e+146},
			{-17.5752220392306,2.8155973670315e+134},
			{-16.7898238758332,5.3438780542487e+122},
			{-16.0044257124357,3.4828267310187e+111},
			{-15.2190275490383,7.7946485861832e+100},
			{-14.4336293856408,5.99032730854946e+90},
			{-13.6482312222434,1.58086180392743e+81},
			{-12.8628330588459,1.43260545754338e+72},
			{-12.0774348954485,4.45808800521289e+63},
			{-11.292036732051,4.76387124217827e+55},
			{-10.5066385686536,1.74807770370323e+48},
			{-9.72124040525614,2.20267688053951e+41},
			{-8.93584224185869,9.53081839989605e+34},
			{-8.15044407846124,1.41611634983222e+29},
			{-7.36504591506379,7.22531890911847e+23},
			{-6.57964775166634,12659147073374500000},
			{-5.7942495882689,761625035961667},
			{-5.00885142487145,157350207157.572},
			{-4.223453261474,111630473.564352},
			{-3.43805509807655,271948.899288357},
		*/
	}

	for _, tc := range testCases {
		if y := Erfcx(complex(tc.x,0)); soclose(real(y), tc.y, 1e-13) == false {
			t.Fatalf("Erfcx(%v): expected %v, got %v", tc.x, tc.y, y)
		}
	}
}

func TestErfcx(t *testing.T) {

	testCases := []struct {
		x, y float64
	}{
		{-2.1, 164.2938078850581786033535756010373886889407300324149511047},
		{-2, 108.9409043899779724123554338248132140422788747719728953862},
		{-1.86725877128166, 65.08259822571413624464960190629088108079118255820727492512},
		{-1.08186060788421, 6.040496719420559069042337844922667141609211183706177952338},
		{-0.296462444486757, 1.446697524293911950679978694884888005694830774823915998041},
		{0.488935718910689, 0.621407170543139014621201513672065153966191496240882991744},
		{1.27433388230814, 0.362803991242338377291710601242918924966030832510719387918},
		{2.05973204570559, 0.249162426872206342991325437388674726308559083733372555711},
		{2.84513020910303, 0.187820125319619076448476381651127670262889920476862189097},
		/*
			//extract from matlab not accurate enough
			{3.63052837250048,0.150075636070996},
			{4.41592653589793,0.124710983013253},
			{5.20132469929538,0.106567671231406},
			{5.98672286269283,0.0929769527031294},
			{6.77212102609028,0.0824305354995751},
			{7.55751918948772,0.0740156858196208},
			{8.34291735288517,0.0671493044858869},
			{9.12831551628262,0.0614421511214345},
			{9.91371367968007,0.0566247992313237},
			{10.6991118430775,0.0525049990205521},
			{11.484510006475,0.0489419799652537},
			{12.2699081698724,0.0458303508315342},
			{13.0553063332699,0.0430896708455744},
			{13.8407044966673,0.0406574959597344},
			{14.6261026600648,0.0384846231086445},
			{15.4115008234622,0.0365317639875922},
			{16.1968989868597,0.0347671718140846},
			{16.9822971502571,0.0331649175487991},
			{17.7676953136545,0.031703617567769},
			{18.553093477052,0.0303654807999256},
			{19.3384916404494,0.0291355856217727},
			{20.1238898038469,0.0280013244472394},
			{20.9092879672443,0.0269519723776485},
			{21.6946861306418,0.0259783487748952},
			{22.4800842940392,0.0250725492347538},
			{23.2654824574367,0.0242277314621347},
			{24.0508806208341,0.0234379428220445},
			{24.8362787842316,0.0226979804074787},
			{25.621676947629,0.022003276694092},
			{26.4070751110265,0.0213498054884549},
			{27.1924732744239,0.0207340040914222},
			{27.9778714378214,0.0201527085081836},
			{28.7632696012188,0.0196030992245012},
			{29.5486677646163,0.0190826555930651},
			{30.3340659280137,0.0185891172768698},
			{31.1194640914112,0.0181204515084825},
			{31.9048622548086,0.0176748251673026},
			{32.6902604182061,0.0172505808678267},
			{33.4756585816035,0.0168462164027294},
			{34.261056745001,0.0164603670044058},
			{35.0464549083984,0.0160917899843943},
			{35.8318530717959,0.0157393513870612},
			{36.6172512351933,0.0154020143560913},
			{37.4026493985908,0.015078828962796},
			{38.1880475619882,0.0147689232864049},
			{38.9734457253857,0.0144714955702288},
			{39.7588438887831,0.0141858073053275},
			{40.5442420521806,0.0139111771162403},
			{41.329640215578,0.0136469753423525},
			{42.1150383789754,0.0133926192243075},
			{42.9004365423729,0.0131475686181052},
			{43.6858347057703,0.0129113221706272},
			{44.4712328691678,0.0126834138996661},
			{45.2566310325652,0.0124634101294228},
			{46.0420291959627,0.0122509067391098},
			{46.8274273593601,0.0120455266879728},
			{47.6128255227576,0.0118469177848704},
			{48.398223686155,0.0116547506746838},
			{49.1836218495525,0.0114687170173598},
			{49.9690200129499,0.0112885278384298},
			{50.7544181763474,0.0111139120324594},
			{51.5398163397448,0.010944615003143},
			{52.3252145031423,0.0107803974257066},
			{53.1106126665397,0.0106210341189781},
			{53.8960108299372,0.0104663130159534},
			{54.6814089933346,0.0103160342229703},
			{55.4668071567321,0.0101700091587187},
			{56.2522053201295,0.0100280597652947},
			{57.037603483527,0.00989001778436436},
			{57.8230016469244,0.00975572409225254},
			{58.6083998103219,0.00962502808843782},
			{59.3937979737193,0.00949778713251466},
			{60.1791961371168,0.00937386602520056},
			{60.9645943005142,0.00925313652942073},
			{61.7499924639117,0.00913547692790577},
			{62.5353906273091,0.00902077161409589},
			{63.3207887907066,0.00890891071346291},
			{64.106186954104,0.00879978973264383},
			{64.8915851175014,0.00869330923403226},
			{65.6769832808989,0.0085893745336986},
			{66.4623814442963,0.00848789542071103},
			{67.2477796076938,0.0083887858961093},
			{68.0331777710912,0.0082919639299447},
			{68.8185759344887,0.00819735123494402},
			{69.6039740978861,0.00810487305548583},
			{70.3893722612836,0.00801445797069374},
			{71.174770424681,0.00792603771055748},
			{71.9601685880785,0.00783954698408697},
			{72.7455667514759,0.00775492331859084},
			{73.5309649148734,0.00767210690924823},
			{74.3163630782708,0.00759104047821305},
			{75.1017612416683,0.00751166914255322},
			{75.8871594050657,0.00743394029038545},
			{76.6725575684632,0.00735780346461829},
			{77.4579557318606,0.0072832102537637},
			{78.2433538952581,0.00721011418932091},
			{79.0287520586555,0.00713847064927561},
			{79.814150222053,0.00706823676729357},
			{80.5995483854504,0.0069993713472204},
			{81.3849465488479,0.00693183478252929},
			{82.1703447122453,0.00686558898038599},
			{82.9557428756428,0.00680059729002494},
			{83.7411410390402,0.00673682443515397},
			{84.5265392024376,0.0066742364501255},
			{85.3119373658351,0.00661280061963175},
			{86.0973355292326,0.00655248542169905},
			{86.88273369263,0.00649326047377248},
			{87.6681318560274,0.00643509648169738},
			{88.4535300194249,0.00637796519141752},
			{89.2389281828223,0.00632183934322287},
			{90.0243263462198,0.00626669262839113},
			{90.8097245096172,0.0062124996480784},
			{91.5951226730147,0.00615923587432384},
			{92.3805208364121,0.00610687761304273},
			{93.1659189998096,0.00605540196889058},
			{93.951317163207,0.00600478681188879},
			{94.7367153266045,0.00595501074570993},
			{95.5221134900019,0.00590605307752674},
			{96.3075116533994,0.0058578937893361},
			{97.0929098167968,0.0058105135106741},
			{97.8783079801943,0.00576389349264431},
			{98.6637061435917,0.00571801558318612},*/
		{99.4491043069892, 0.005672862203514460617907910565771973977540996637069157954},
	}

	for _, tc := range testCases {
		if y := Erfcx(complex(tc.x,0)); veryclose(real(y), tc.y) == false {
			t.Fatalf("Erfcx(%v): expected %v, got %v", tc.x, tc.y, y)
		}
	}
}
 
// The floating point comparison tests are copied from from math/all_test.go.
func tolerance(a, b, e float64) bool {
	// Multiplying by e here can underflow denormal values to zero.
	// Check a==b so that at least if a and b are small and identical
	// we say they match.
	if a == b {
		return true
	}
	d := a - b
	if d < 0 {
		d = -d
	}
	// note: b is correct (expected) value, a is actual value.
	// make error tolerance a fraction of b, not a.
	if b != 0 {
		e = e * b
		if e < 0 {
			e = -e
		}
	}
	return d < e
}

func close(a, b float64) bool      { return tolerance(a, b, 1e-14) }
func veryclose(a, b float64) bool  { return tolerance(a, b, 5e-16) }
func soclose(a, b, e float64) bool { return tolerance(a, b, e) }
