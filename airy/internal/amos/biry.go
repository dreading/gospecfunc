// Copyright 2019 Infin IT Pty Ltd. All rights reserved.
//
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//
// The original Fortran code are from
//  ALGORITHM 644, TRANSACTIONS ON MATHEMATICAL SOFTWARE,
//	VOL. 21, NO. 4, December, 1995, P.  388--393.
//  AMOS, DONALD E., SANDIA NATIONAL LABORATORIES

package amos

import (
	"github.com/dreading/gospecfunc/machine"
	"math"
)

// ZBIRY COMPUTES THE COMPLEX AIRY FUNCTION BI(Z) OR ITS DERIVATIVE DBI(Z)/DZ
// ON ID=0 OR ID=1 RESPECTIVELY FOR KODE=1
// FOR KODE=2, A SCALING OPTION CEXP(-AXZTA)*BI(Z) OR CEXP(-AXZTA)*
// DBI(Z)/DZ IS PROVIDED TO REMOVE THE EXPONENTIAL BEHAVIOR IN
// BOTH THE LEFT AND RIGHT HALF PLANES WHERE
// ZTA=(2/3)*Z*CSQRT(Z)=CMPLX(XZTA,YZTA) AND AXZTA=ABS(XZTA).
// DEFINTIONS AND NOTATION ARE FOUND IN THE NBS HANDBOOK OF
// MATHEMATICAL FUNCTIONS (REF. 1).
// INPUTS
//    ZR,ZI  - Z=CMPLX(ZR,ZI)
//    ID     - ORDER OF DERIVATIVE, ID=0 OR ID=1
//    KODE   - A PARAMETER TO INDICATE THE SCALING OPTION
//             KODE= 1  return S
//                      BI=BI(Z)                 ON ID=0 OR
//                      BI=DBI(Z)/DZ             ON ID=1
//                 = 2  return S
//                      BI=CEXP(-AXZTA)*BI(Z)     ON ID=0 OR
//                      BI=CEXP(-AXZTA)*DBI(Z)/DZ ON ID=1 WHERE
//                      ZTA=(2/3)*Z*CSQRT(Z)=CMPLX(XZTA,YZTA)
//                      AND AXZTA=ABS(XZTA)
// OUTPUT
//    BIR,BII- COMPLEX ANSWER DEPENDING ON THE CHOICES FOR ID AND
//             KODE
//    IERR   - ERROR FLAG
//             IERR=0, NORMAL return  - COMPUTATION COMPLETED
//             IERR=1, INPUT ERROR   - NO COMPUTATION
//             IERR=2, OVERFLOW      - NO COMPUTATION, REAL(Z)
//                     TOO LARGE ON KODE=1
//             IERR=3, CABS(Z) LARGE      - COMPUTATION COMPLETED
//                     LOSSES OF SIGNIFCANCE BY ARGUMENT REDUCTION
//                     PRODUCE LESS THAN HALF OF MACHINE ACCURACY
//             IERR=4, CABS(Z) TOO LARGE  - NO COMPUTATION
//                     COMPLETE LOSS OF ACCURACY BY ARGUMENT
//                     REDUCTION
//             IERR=5, ERROR              - NO COMPUTATION,
//                     ALGORITHM TERMINATION CONDITION NOT MET
func ZBIRY(ZR float64, ZI float64, ID int, KODE int) (float64, float64, int) {

	//  BI AND DBI ARE COMPUTED FOR CABS(Z) > 1.0 FROM THE I BESSEL
	//  FUNCTIONS BY
	//
	//         BI(Z)=C*SQRT(Z)*( I(-1/3,ZTA) + I(1/3,ZTA) )
	//        DBI(Z)=C *  Z  * ( I(-2/3,ZTA) + I(2/3,ZTA) )
	//                        C=1.0/SQRT(3.0)
	//                      ZTA=(2/3)*Z**(3/2)
	//
	//  WITH THE POWER SERIES FOR CABS(Z) <= 1.0.
	//
	//  IN MOST COMPLEX VARIABLE COMPUTATION, ONE MUST EVALUATE ELE-
	//  MENTARY FUNCTIONS. WHEN THE MAGNITUDE OF Z IS LARGE, LOSSES
	//  OF SIGNIFICANCE BY ARGUMENT REDUCTION OCCUR. CONSEQUENTLY, IF
	//  THE MAGNITUDE OF ZETA=(2/3)*Z**1.5 EXCEEDS U1=SQRT(0.5/UR),
	//  THEN LOSSES EXCEEDING HALF PRECISION ARE LIKELY AND AN ERROR
	//  FLAG IERR=3 IS TRIGGERED WHERE UR=math.Max(D1MACH(4),1.0e-18) IS
	//  DOUBLE PRECISION UNIT ROUNDOFF LIMITED TO 18 DIGITS PRECISION.
	//  ALSO, if THE MAGNITUDE OF ZETA IS LARGER THAN U2=0.5/UR, THEN
	//  ALL SIGNIFICANCE IS LOST AND IERR=4. IN ORDER TO USE THE INT
	//  FUNCTION, ZETA MUST BE FURTHER RESTRICTED NOT TO EXCEED THE
	//  LARGEST INTEGER, U3=I1MACH(9). THUS, THE MAGNITUDE OF ZETA
	//  MUST BE RESTRICTED BY MIN(U2,U3). ON 32 BIT MACHINES, U1,U2,
	//  AND U3 ARE APPROXIMATELY 2.0E+3, 4.2E+6, 2.1E+9 IN SINGLE
	//  PRECISION ARITHMETIC AND 1.3E+8, 1.8E+16, 2.1E+9 IN DOUBLE
	//  PRECISION ARITHMETIC RESPECTIVELY. THIS MAKES U2 AND U3 LIMIT-
	//  ING IN THEIR RESPECTIVE ARITHMETICS. THIS MEANS THAT THE MAG-
	//  NITUDE OF Z CANNOT EXCEED 3.1E+4 IN SINGLE AND 2.1E+6 IN
	//  DOUBLE PRECISION ARITHMETIC. THIS ALSO MEANS THAT ONE CAN
	//  EXPECT TO RETAIN, IN THE WORST CASES ON 32 BIT MACHINES,
	//  NO DIGITS IN SINGLE PRECISION AND ONLY 7 DIGITS IN DOUBLE
	//  PRECISION ARITHMETIC. SIMILAR CONSIDERATIONS HOLD FOR OTHER
	//  MACHINES.
	//
	//  THE APPROXIMATE RELATIVE ERROR IN THE MAGNITUDE OF A COMPLEX
	//  BESSEL FUNCTION CAN BE EXPRESSED BY P*10**S WHERE P=MAX(UNIT
	//  ROUNDOFF,1.0E-18) IS THE NOMINAL PRECISION AND 10**S REPRE-
	//  SENTS THE INCREASE IN ERROR DUE TO ARGUMENT REDUCTION IN THE
	//  ELEMENTARY FUNCTIONS. HERE, S=MAX(1,ABS(LOG10(CABS(Z))),
	//  ABS(LOG10(FNU))) APPROXIMATELY (I.E. S=MAX(1,ABS(EXPONENT OF
	//  CABS(Z),ABS(EXPONENT OF FNU)) ). HOWEVER, THE PHASE ANGLE MAY
	//  HAVE ONLY ABSOLUTE ACCURACY. THIS IS MOST LIKELY TO OCCUR WHEN
	//  ONE COMPONENT (IN ABSOLUTE VALUE) IS LARGER THAN THE OTHER BY
	//  SEVERAL ORDERS OF MAGNITUDE. if ONE COMPONENT IS 10**K LARGER
	//  THAN THE OTHER, THEN ONE CAN EXPECT ONLY MAX(ABS(LOG10(P))-K,
	//  0) SIGNIFICANT DIGITS; OR, STATED ANOTHER WAY, WHEN K EXCEEDS
	//  THE EXPONENT OF P, NO SIGNIFICANT DIGITS REMAIN IN THE SMALLER
	//  COMPONENT. HOWEVER, THE PHASE ANGLE RETAINS ABSOLUTE ACCURACY
	//  BECAUSE, IN COMPLEX ARITHMETIC WITH PRECISION P, THE SMALLER
	//  COMPONENT WILL NOT (AS A RULE) DECREASE BELOW P TIMES THE
	//  MAGNITUDE OF THE LARGER COMPONENT. IN THESE EXTREME CASES,
	//  THE PRINCIPAL PHASE ANGLE IS ON THE ORDER OF +P, -P, PI/2-P,
	//  OR -PI/2+P.
	//
	//        HANDBOOK OF MATHEMATICAL FUNCTIONS BY M. ABRAMOWITZ
	//          AND I. A. STEGUN, NBS AMS SERIES 55, U.S. DEPT. OF
	//          COMMERCE, 1955.
	//
	//        COMPUTATION OF BESSEL FUNCTIONS OF COMPLEX ARGUMENT
	//          AND LARGE ORDER BY D. E. AMOS, SAND83-0643, MAY, 1983
	//
	//        A SUBROUTINE PACKAGE FOR BESSEL FUNCTIONS OF A COMPLEX
	//          ARGUMENT AND NONNEGATIVE ORDER BY D. E. AMOS, SAND85-
	//          1018, MAY, 1985
	//
	//        A PORTABLE PACKAGE FOR BESSEL FUNCTIONS OF A COMPLEX
	//          ARGUMENT AND NONNEGATIVE ORDER BY D. E. AMOS, TRANS.
	//          MATH. SOFTWARE, 1986

	const (
		CONER = 1.0e0
		CONEI = 0.0e0
		TTH   = 6.66666666666666667e-01
		C1    = 6.14926627446000736e-01
		C2    = 4.48288357353826359e-01
		COEF  = 5.77350269189625765e-01
	)
	var AA, AD, AK, ALIM, ATRM, AZ, AZ3, BB, BII, BIR, BK, CC, CK, CSQI, CSQR, DIG, DK,
		D1, D2, EAA, ELIM, FID, FMR, FNU, FNUL, RL, R1M5, SFAC, STI, STR, S1I, S1R, S2I, S2R,
		TOL, TRM1I, TRM1R, TRM2I, TRM2R, ZTAI, ZTAR, Z3I, Z3R float64
	var IERR, K, K1, K2, NZ int

	CYR := []float64{math.NaN(), 0, 0}
	CYI := []float64{math.NaN(), 0, 0}

	IERR = 0
	NZ = 0
	if ID < 0 || ID > 1 {
		IERR = 1
	}
	if KODE < 1 || KODE > 2 {
		IERR = 1
	}
	if IERR != 0 {
		return BIR, BII, IERR
	}
	AZ = ZABS(ZR, ZI)
	TOL = math.Max(machine.D1MACH[4], 1.0e-18)
	FID = float64(float32(ID))
	if AZ > 1.0e0 {
		goto L70
	}

	// POWER SERIES FOR CABS(Z) <= 1.
	S1R = CONER
	S1I = CONEI
	S2R = CONER
	S2I = CONEI
	if AZ < TOL {
		goto L130
	}
	AA = AZ * AZ
	if AA < TOL/AZ {
		goto L40
	}
	TRM1R = CONER
	TRM1I = CONEI
	TRM2R = CONER
	TRM2I = CONEI
	ATRM = 1.0e0
	STR = ZR*ZR - ZI*ZI
	STI = ZR*ZI + ZI*ZR
	Z3R = STR*ZR - STI*ZI
	Z3I = STR*ZI + STI*ZR
	AZ3 = AZ * AA
	AK = 2.0e0 + FID
	BK = 3.0e0 - FID - FID
	CK = 4.0e0 - FID
	DK = 3.0e0 + FID + FID
	D1 = AK * DK
	D2 = BK * CK
	AD = math.Min(D1, D2)
	AK = 24.0e0 + 9.0e0*FID
	BK = 30.0e0 - 9.0e0*FID
	for K = 1; K <= 25; K++ {
		STR = (TRM1R*Z3R - TRM1I*Z3I) / D1
		TRM1I = (TRM1R*Z3I + TRM1I*Z3R) / D1
		TRM1R = STR
		S1R = S1R + TRM1R
		S1I = S1I + TRM1I
		STR = (TRM2R*Z3R - TRM2I*Z3I) / D2
		TRM2I = (TRM2R*Z3I + TRM2I*Z3R) / D2
		TRM2R = STR
		S2R = S2R + TRM2R
		S2I = S2I + TRM2I
		ATRM = ATRM * AZ3 / AD
		D1 = D1 + AK
		D2 = D2 + BK
		AD = math.Min(D1, D2)
		if ATRM < TOL*AD {
			goto L40
		}
		AK = AK + 18.0e0
		BK = BK + 18.0e0
	}
L40:
	if ID == 1 {
		goto L50
	}
	BIR = C1*S1R + C2*(ZR*S2R-ZI*S2I)
	BII = C1*S1I + C2*(ZR*S2I+ZI*S2R)
	if KODE == 1 {
		return BIR, BII, IERR
	}
	STR, STI = ZSQRT(ZR, ZI)
	ZTAR = TTH * (ZR*STR - ZI*STI)
	ZTAI = TTH * (ZR*STI + ZI*STR)
	AA = ZTAR
	AA = -math.Abs(AA)
	EAA = math.Exp(AA)
	BIR = BIR * EAA
	BII = BII * EAA
	return BIR, BII, IERR
L50:
	BIR = S2R * C2
	BII = S2I * C2
	if AZ <= TOL {
		goto L60
	}
	CC = C1 / (1.0e0 + FID)
	STR = S1R*ZR - S1I*ZI
	STI = S1R*ZI + S1I*ZR
	BIR = BIR + CC*(STR*ZR-STI*ZI)
	BII = BII + CC*(STR*ZI+STI*ZR)
L60:
	if KODE == 1 {
		return BIR, BII, IERR
	}
	STR, STI = ZSQRT(ZR, ZI)
	ZTAR = TTH * (ZR*STR - ZI*STI)
	ZTAI = TTH * (ZR*STI + ZI*STR)
	AA = ZTAR
	AA = -math.Abs(AA)
	EAA = math.Exp(AA)
	BIR = BIR * EAA
	BII = BII * EAA
	return BIR, BII, IERR

	// CASE FOR CABS(Z) > 1.0
L70:
	FNU = (1.0e0 + FID) / 3.0e0

	// SET PARAMETERS RELATED TO MACHINE CONSTANTS.
	// TOL IS THE APPROXIMATE UNIT ROUNDOFF LIMITED TO 1.0E-18.
	// ELIM IS THE APPROXIMATE EXPONENTIAL OVER- AND UNDERFLOW LIMIT.
	// EXP(-ELIM) < EXP(-ALIM)=EXP(-ELIM)/TOL    AND
	// EXP(ELIM) > EXP(ALIM)=EXP(ELIM)*TOL       ARE INTERVALS NEAR
	// UNDERFLOW AND OVERFLOW LIMITS WHERE SCALED ARITHMETIC IS DONE.
	// RL IS THE LOWER BOUNDARY OF THE ASYMPTOTIC EXPANSION FOR LARGE Z.
	// DIG = NUMBER OF BASE 10 DIGITS IN TOL = 10**(-DIG).
	// FNUL IS THE LOWER BOUNDARY OF THE ASYMPTOTIC SERIES FOR LARGE FNU.
	K1 = machine.I1MACH[15]
	K2 = machine.I1MACH[16]
	R1M5 = machine.D1MACH[5]
	K = MIN(ABS(K1), ABS(K2))
	ELIM = 2.303e0 * (float64(float32(K))*R1M5 - 3.0e0)
	K1 = machine.I1MACH[14] - 1
	AA = R1M5 * float64(float32(K1))
	DIG = math.Min(AA, 18.0e0)
	AA = AA * 2.303e0
	ALIM = ELIM + math.Max(-AA, -41.45e0)
	RL = 1.2e0*DIG + 3.0e0
	FNUL = 10.0e0 + 6.0e0*(DIG-3.0e0)

	// TEST FOR RANGE
	AA = 0.5e0 / TOL
	BB = float64(float32(machine.I1MACH[9])) * 0.5e0
	AA = math.Min(AA, BB)
	AA = math.Pow(AA, TTH)
	if AZ > AA {
		goto L260
	}
	AA = math.Sqrt(AA)
	if AZ > AA {
		IERR = 3
	}
	CSQR, CSQI = ZSQRT(ZR, ZI)
	ZTAR = TTH * (ZR*CSQR - ZI*CSQI)
	ZTAI = TTH * (ZR*CSQI + ZI*CSQR)

	// RE(ZTA) <= 0 WHEN RE(Z) < 0, ESPECIALLY WHEN IM(Z) IS SMALL
	SFAC = 1.0e0
	AK = ZTAI
	if ZR >= 0.0e0 {
		goto L80
	}
	BK = ZTAR
	CK = -math.Abs(BK)
	ZTAR = CK
	ZTAI = AK
L80:
	if ZI != 0.0e0 || ZR > 0.0e0 {
		goto L90
	}
	ZTAR = 0.0e0
	ZTAI = AK
L90:
	AA = ZTAR
	if KODE == 2 {
		goto L100
	}

	// OVERFLOW TEST
	BB = math.Abs(AA)
	if BB < ALIM {
		goto L100
	}
	BB = BB + 0.25e0*math.Log(AZ)
	SFAC = TOL
	if BB > ELIM {
		goto L190
	}
L100:
	FMR = 0.0e0
	if AA >= 0.0e0 && ZR > 0.0e0 {
		goto L110
	}
	FMR = math.Pi
	if ZI < 0.0e0 {
		FMR = -math.Pi
	}
	ZTAR = -ZTAR
	ZTAI = -ZTAI

L110:
	// AA=FACTOR FOR ANALYTIC CONTINUATION OF I(FNU,ZTA)
	// KODE=2 return S EXP(-ABS(XZTA))*I(FNU,ZTA) FROM CBESI
	ZTAR, ZTAI, FNU, KODE, _, CYR, CYI, NZ, RL, FNUL, TOL, ELIM, ALIM = ZBINU(ZTAR, ZTAI, FNU, KODE, 1, CYR, CYI, NZ, RL, FNUL, TOL, ELIM, ALIM)
	if NZ < 0 {
		goto L200
	}
	AA = FMR * FNU
	Z3R = SFAC
	STR = math.Cos(AA)
	STI = math.Sin(AA)
	S1R = (STR*CYR[1] - STI*CYI[1]) * Z3R
	S1I = (STR*CYI[1] + STI*CYR[1]) * Z3R
	FNU = (2.0e0 - FID) / 3.0e0
	ZTAR, ZTAI, FNU, KODE, _, CYR, CYI, NZ, RL, FNUL, TOL, ELIM, ALIM = ZBINU(ZTAR, ZTAI, FNU, KODE, 2, CYR, CYI, NZ, RL, FNUL, TOL, ELIM, ALIM)
	CYR[1] = CYR[1] * Z3R
	CYI[1] = CYI[1] * Z3R
	CYR[2] = CYR[2] * Z3R
	CYI[2] = CYI[2] * Z3R

	// BACKWARD RECUR ONE STEP FOR ORDERS -1/3 OR -2/3
	STR, STI = ZDIV(CYR[1], CYI[1], ZTAR, ZTAI)
	S2R = (FNU+FNU)*STR + CYR[2]
	S2I = (FNU+FNU)*STI + CYI[2]
	AA = FMR * (FNU - 1.0e0)
	STR = math.Cos(AA)
	STI = math.Sin(AA)
	S1R = COEF * (S1R + S2R*STR - S2I*STI)
	S1I = COEF * (S1I + S2R*STI + S2I*STR)
	if ID == 1 {
		goto L120
	}
	STR = CSQR*S1R - CSQI*S1I
	S1I = CSQR*S1I + CSQI*S1R
	S1R = STR
	BIR = S1R / SFAC
	BII = S1I / SFAC
	return BIR, BII, IERR
L120:
	STR = ZR*S1R - ZI*S1I
	S1I = ZR*S1I + ZI*S1R
	S1R = STR
	BIR = S1R / SFAC
	BII = S1I / SFAC
	return BIR, BII, IERR
L130:
	AA = C1*(1.0e0-FID) + FID*C2
	BIR = AA
	BII = 0.0e0
	return BIR, BII, IERR
L190:
	IERR = 2
	NZ = 0
	return BIR, BII, IERR
L200:
	if NZ == -1 {
		goto L190
	}
	NZ = 0
	IERR = 5
	return BIR, BII, IERR
L260:
	IERR = 4
	NZ = 0
	return BIR, BII, IERR
}

// ZUNIK COMPUTES PARAMETERS FOR THE UNIFORM ASYMPTOTIC
// EXPANSIONS OF THE I AND K FUNCTIONS ON IKFLG= 1 OR 2
// RESPECTIVELY BY
//
// W(FNU,ZR) = PHI*EXP(ZETA)*SUM
//
// WHERE       ZETA=-ZETA1 + ZETA2       OR
//                   ZETA1 - ZETA2
//
// THE FIRST CALL MUST HAVE INIT=0. SUBSEQUENT CALLS WITH THE
// SAME ZR AND FNU WILL return  THE I OR K FUNCTION ON IKFLG=
// 1 OR 2 WITH NO CHANGE IN INIT. CWRK IS A COMPLEX WORK
// ARRAY. IPMTR=0 COMPUTES ALL PARAMETERS. IPMTR=1 COMPUTES PHI,
// ZETA1,ZETA2.
func ZUNIK(ZRR float64, ZRI float64, FNU float64, IKFLG int, IPMTR int, TOL float64, INIT int, PHIR float64,
	PHII float64, ZETA1R float64, ZETA1I float64, ZETA2R float64, ZETA2I float64,
	SUMR float64, SUMI float64, CWRKR []float64, CWRKI []float64) (float64, float64, float64, int, int, float64, int, float64,
	float64, float64, float64, float64, float64, float64, float64, []float64, []float64) {

	const (
		ZEROR = 0.0e0
		ZEROI = 0.0e0
		CONER = 1.0e0
		CONEI = 0.0e0
	)

	var AC, CRFNI, CRFNR, RFN, SI, SR, SRI, SRR, STI, STR,
		TEST, TI, TR, T2I, T2R, ZNI, ZNR float64
	var I, J, K, L int
	var CON = [3]float64{math.NaN(), 3.98942280401432678e-01, 1.25331413731550025e+00}
	//var CWRKR, CWRKI [17]float64

	var C = [121]float64{math.NaN(),
		1.00000000000000000e+00, -2.08333333333333333e-01,
		1.25000000000000000e-01, 3.34201388888888889e-01,
		-4.01041666666666667e-01, 7.03125000000000000e-02,
		-1.02581259645061728e+00, 1.84646267361111111e+00,
		-8.91210937500000000e-01, 7.32421875000000000e-02,
		4.66958442342624743e+00, -1.12070026162229938e+01,
		8.78912353515625000e+00, -2.36408691406250000e+00,
		1.12152099609375000e-01, -2.82120725582002449e+01,
		8.46362176746007346e+01, -9.18182415432400174e+01,
		4.25349987453884549e+01, -7.36879435947963170e+00,
		2.27108001708984375e-01, 2.12570130039217123e+02,
		-7.65252468141181642e+02, 1.05999045252799988e+03,
		-6.99579627376132541e+02, 2.18190511744211590e+02,
		-2.64914304869515555e+01, 5.72501420974731445e-01,
		-1.91945766231840700e+03, 8.06172218173730938e+03,
		-1.35865500064341374e+04, 1.16553933368645332e+04,
		-5.30564697861340311e+03, 1.20090291321635246e+03,
		-1.08090919788394656e+02, 1.72772750258445740e+00,
		2.02042913309661486e+04, -9.69805983886375135e+04,
		1.92547001232531532e+05, -2.03400177280415534e+05,
		1.22200464983017460e+05, -4.11926549688975513e+04,
		7.10951430248936372e+03, -4.93915304773088012e+02,
		6.07404200127348304e+00, -2.42919187900551333e+05,
		1.31176361466297720e+06, -2.99801591853810675e+06,
		3.76327129765640400e+06, -2.81356322658653411e+06,
		1.26836527332162478e+06, -3.31645172484563578e+05,
		4.52187689813627263e+04, -2.49983048181120962e+03,
		2.43805296995560639e+01, 3.28446985307203782e+06,
		-1.97068191184322269e+07, 5.09526024926646422e+07,
		-7.41051482115326577e+07, 6.63445122747290267e+07,
		-3.75671766607633513e+07, 1.32887671664218183e+07,
		-2.78561812808645469e+06, 3.08186404612662398e+05,
		-1.38860897537170405e+04, 1.10017140269246738e+02,
		-4.93292536645099620e+07, 3.25573074185765749e+08,
		-9.39462359681578403e+08, 1.55359689957058006e+09,
		-1.62108055210833708e+09, 1.10684281682301447e+09,
		-4.95889784275030309e+08, 1.42062907797533095e+08,
		-2.44740627257387285e+07, 2.24376817792244943e+06,
		-8.40054336030240853e+04, 5.51335896122020586e+02,
		8.14789096118312115e+08, -5.86648149205184723e+09,
		1.86882075092958249e+10, -3.46320433881587779e+10,
		4.12801855797539740e+10, -3.30265997498007231e+10,
		1.79542137311556001e+10, -6.56329379261928433e+09,
		1.55927986487925751e+09, -2.25105661889415278e+08,
		1.73951075539781645e+07, -5.49842327572288687e+05,
		3.03809051092238427e+03, -1.46792612476956167e+10,
		1.14498237732025810e+11, -3.99096175224466498e+11,
		8.19218669548577329e+11, -1.09837515608122331e+12,
		1.00815810686538209e+12, -6.45364869245376503e+11,
		2.87900649906150589e+11, -8.78670721780232657e+10,
		1.76347306068349694e+10, -2.16716498322379509e+09,
		1.43157876718888981e+08, -3.87183344257261262e+06,
		1.82577554742931747e+04, 2.86464035717679043e+11,
		-2.40629790002850396e+12, 9.10934118523989896e+12,
		-2.05168994109344374e+13, 3.05651255199353206e+13,
		-3.16670885847851584e+13, 2.33483640445818409e+13,
		-1.23204913055982872e+13, 4.61272578084913197e+12,
		-1.19655288019618160e+12, 2.05914503232410016e+11,
		-2.18229277575292237e+10, 1.24700929351271032e+09,
		-2.91883881222208134e+07, 1.18838426256783253e+05}

	if INIT != 0 {
		goto L40
	}

	RFN = 1.0e0 / FNU

	// OVERFLOW TEST (ZR/FNU TOO SMALL)
	TEST = machine.D1MACH[1] * 1.0e+3
	AC = FNU * TEST
	if math.Abs(ZRR) > AC || math.Abs(ZRI) > AC {
		goto L15
	}
	ZETA1R = 2.0e0*math.Abs(math.Log(TEST)) + FNU
	ZETA1I = 0.0e0
	ZETA2R = FNU
	ZETA2I = 0.0e0
	PHIR = 1.0e0
	PHII = 0.0e0
	return ZRR, ZRI, FNU, IKFLG, IPMTR, TOL, INIT, PHIR, PHII, ZETA1R, ZETA1I, ZETA2R, ZETA2I, SUMR, SUMI, CWRKR, CWRKI
L15:
	TR = ZRR * RFN
	TI = ZRI * RFN
	SR = CONER + (TR*TR - TI*TI)
	SI = CONEI + (TR*TI + TI*TR)
	SRR, SRI = ZSQRT(SR, SI)
	STR = CONER + SRR
	STI = CONEI + SRI
	ZNR, ZNI = ZDIV(STR, STI, TR, TI)
	STR, STI = ZLOG(ZNR, ZNI)
	ZETA1R = FNU * STR
	ZETA1I = FNU * STI
	ZETA2R = FNU * SRR
	ZETA2I = FNU * SRI
	TR, TI = ZDIV(CONER, CONEI, SRR, SRI)
	SRR = TR * RFN
	SRI = TI * RFN
	CWRKR[16], CWRKI[16] = ZSQRT(SRR, SRI)
	PHIR = CWRKR[16] * CON[IKFLG]
	PHII = CWRKI[16] * CON[IKFLG]
	if IPMTR != 0 {
		return ZRR, ZRI, FNU, IKFLG, IPMTR, TOL, INIT, PHIR, PHII, ZETA1R, ZETA1I, ZETA2R, ZETA2I, SUMR, SUMI, CWRKR, CWRKI
	}
	T2R, T2I = ZDIV(CONER, CONEI, SR, SI)
	CWRKR[1] = CONER
	CWRKI[1] = CONEI
	CRFNR = CONER
	CRFNI = CONEI
	AC = 1.0e0
	L = 1
	for K = 2; K <= 15; K++ {
		SR = ZEROR
		SI = ZEROI
		for J = 1; J <= K; J++ {
			L = L + 1
			STR = SR*T2R - SI*T2I + C[L]
			SI = SR*T2I + SI*T2R
			SR = STR
		}
		STR = CRFNR*SRR - CRFNI*SRI
		CRFNI = CRFNR*SRI + CRFNI*SRR
		CRFNR = STR
		CWRKR[K] = CRFNR*SR - CRFNI*SI
		CWRKI[K] = CRFNR*SI + CRFNI*SR
		AC = AC * RFN
		TEST = math.Abs(CWRKR[K]) + math.Abs(CWRKI[K])
		if AC < TOL && TEST < TOL {
			goto L30
		}
	}
	K = 15
L30:
	INIT = K
L40:
	if IKFLG == 2 {
		goto L60
	}
	// COMPUTE SUM FOR THE I FUNCTION
	SR = ZEROR
	SI = ZEROI
	for I = 1; I < INIT; I++ {
		SR = SR + CWRKR[I]
		SI = SI + CWRKI[I]
	}
	SUMR = SR
	SUMI = SI
	PHIR = CWRKR[16] * CON[1]
	PHII = CWRKI[16] * CON[1]
	return ZRR, ZRI, FNU, IKFLG, IPMTR, TOL, INIT, PHIR, PHII, ZETA1R, ZETA1I, ZETA2R, ZETA2I, SUMR, SUMI, CWRKR, CWRKI
L60:
	// COMPUTE SUM FOR THE K FUNCTION
	SR = ZEROR
	SI = ZEROI
	TR = CONER
	for I = 1; I < INIT; I++ {
		SR = SR + TR*CWRKR[I]
		SI = SI + TR*CWRKI[I]
		TR = -TR
	}
	SUMR = SR
	SUMI = SI
	PHIR = CWRKR[16] * CON[2]
	PHII = CWRKI[16] * CON[2]
	return ZRR, ZRI, FNU, IKFLG, IPMTR, TOL, INIT, PHIR, PHII, ZETA1R, ZETA1I, ZETA2R, ZETA2I, SUMR, SUMI, CWRKR, CWRKI
}

// ZBUNI COMPUTES THE I BESSEL FUNCTION FOR LARGE CABS(Z) >  FNUL AND FNU+N-1 < FNUL.
// THE ORDER IS INCREASED FROM FNU+N-1 GREATER THAN FNUL BY ADDING NUI AND COMPUTING
// ACCORDING TO THE UNIFORM ASYMPTOTIC EXPANSION FOR I(FNU,Z) ON IFORM=1 AND
// THE EXPANSION FOR J(FNU,Z) ON IFORM=2
func ZBUNI(ZR float64, ZI float64, FNU float64, KODE int, N int, YR []float64, YI []float64, NZ int, NUI int, NLAST int,
	FNUL float64, TOL float64, ELIM float64, ALIM float64) (float64, float64, float64, int, int, []float64, []float64, int, int, int, float64, float64, float64, float64) {

	var AX, AY, CSCLR, CSCRR, DFNU, FNUI, GNU, RAZ, RZI, RZR, STI, STR, S1I, S1R, S2I, S2R, ASCLE, C1R, C1I, C1M float64

	var I, IFLAG, IFORM, K, NL, NW int
	var CYR, CYI []float64
	var BRY [4]float64

	NZ = 0
	AX = math.Abs(ZR) * 1.7321e0
	AY = math.Abs(ZI)
	IFORM = 1
	if AY > AX {
		IFORM = 2
	}
	if NUI == 0 {
		goto L60
	}
	FNUI = float64(float32(NUI))
	DFNU = FNU + float64(float32(N-1))
	GNU = DFNU + FNUI
	if IFORM == 2 {
		goto L10
	}

	// ASYMPTOTIC EXPANSION FOR I(FNU,Z) FOR LARGE FNU APPLIED IN -PI/3 <= ARG(Z) <= PI/3
	ZR, ZI, GNU, KODE, _, CYR, CYI, NW, NLAST, FNUL, TOL, ELIM, ALIM = ZUNI1(ZR, ZI, GNU, KODE, 2, CYR, CYI, NW, NLAST, FNUL, TOL, ELIM, ALIM)
	goto L20
L10:
	// ASYMPTOTIC EXPANSION FOR J(FNU,Z*EXP(M*HPI)) FOR LARGE FNU APPLIED IN
	// PI/3 < ABS(ARG(Z)) <= PI/2 WHERE M=+I OR -I AND HPI=PI/2
	ZR, ZI, GNU, KODE, _, CYR, CYI, NW, NLAST, FNUL, TOL, ELIM, ALIM = ZUNI2(ZR, ZI, GNU, KODE, 2, CYR, CYI, NW, NLAST, FNUL, TOL, ELIM, ALIM)
L20:
	if NW < 0 {
		goto L50
	}
	if NW != 0 {
		goto L90
	}
	STR = ZABS(CYR[1], CYI[1])

	// SCALE BACKWARD RECURRENCE, BRY(3) IS DEFINED BUT NEVER USED
	BRY[1] = 1000.0e0 * machine.D1MACH[1] / TOL
	BRY[2] = 1.0e0 / BRY[1]
	BRY[3] = BRY[2]
	IFLAG = 2
	ASCLE = BRY[2]
	CSCLR = 1.0e0
	if STR > BRY[1] {
		goto L21
	}
	IFLAG = 1
	ASCLE = BRY[1]
	CSCLR = 1.0e0 / TOL
	goto L25
L21:
	if STR < BRY[2] {
		goto L25
	}
	IFLAG = 3
	ASCLE = BRY[3]
	CSCLR = TOL
L25:
	CSCRR = 1.0e0 / CSCLR
	S1R = CYR[2] * CSCLR
	S1I = CYI[2] * CSCLR
	S2R = CYR[1] * CSCLR
	S2I = CYI[1] * CSCLR
	RAZ = 1.0e0 / ZABS(ZR, ZI)
	STR = ZR * RAZ
	STI = -ZI * RAZ
	RZR = (STR + STR) * RAZ
	RZI = (STI + STI) * RAZ
	for I = 1; I <= NUI; I++ {
		STR = S2R
		STI = S2I
		S2R = (DFNU+FNUI)*(RZR*STR-RZI*STI) + S1R
		S2I = (DFNU+FNUI)*(RZR*STI+RZI*STR) + S1I
		S1R = STR
		S1I = STI
		FNUI = FNUI - 1.0e0
		if IFLAG >= 3 {
			continue
		}
		STR = S2R * CSCRR
		STI = S2I * CSCRR
		C1R = math.Abs(STR)
		C1I = math.Abs(STI)
		C1M = math.Max(C1R, C1I)
		if C1M <= ASCLE {
			continue
		}
		IFLAG = IFLAG + 1
		ASCLE = BRY[IFLAG]
		S1R = S1R * CSCRR
		S1I = S1I * CSCRR
		S2R = STR
		S2I = STI
		CSCLR = CSCLR * TOL
		CSCRR = 1.0e0 / CSCLR
		S1R = S1R * CSCLR
		S1I = S1I * CSCLR
		S2R = S2R * CSCLR
		S2I = S2I * CSCLR
	}
	YR[N] = S2R * CSCRR
	YI[N] = S2I * CSCRR
	if N == 1 {
		return ZR, ZI, FNU, KODE, N, YR, YI, NZ, NUI, NLAST, FNUL, TOL, ELIM, ALIM
	}
	NL = N - 1
	FNUI = float64(float32(NL))
	K = NL
	for I = 1; I <= NL; I++ {

		STR = S2R
		STI = S2I
		S2R = (FNU+FNUI)*(RZR*STR-RZI*STI) + S1R
		S2I = (FNU+FNUI)*(RZR*STI+RZI*STR) + S1I
		S1R = STR
		S1I = STI
		STR = S2R * CSCRR
		STI = S2I * CSCRR
		YR[K] = STR
		YI[K] = STI
		FNUI = FNUI - 1.0e0
		K = K - 1
		if IFLAG >= 3 {
			continue
		}
		C1R = math.Abs(STR)
		C1I = math.Abs(STI)
		C1M = math.Max(C1R, C1I)
		if C1M <= ASCLE {
			continue
		}
		IFLAG = IFLAG + 1
		ASCLE = BRY[IFLAG]
		S1R = S1R * CSCRR
		S1I = S1I * CSCRR
		S2R = STR
		S2I = STI
		CSCLR = CSCLR * TOL
		CSCRR = 1.0e0 / CSCLR
		S1R = S1R * CSCLR
		S1I = S1I * CSCLR
		S2R = S2R * CSCLR
		S2I = S2I * CSCLR
	}
	return ZR, ZI, FNU, KODE, N, YR, YI, NZ, NUI, NLAST, FNUL, TOL, ELIM, ALIM
L50:
	NZ = -1
	if NW == -2 {
		NZ = -2
	}
	return ZR, ZI, FNU, KODE, N, YR, YI, NZ, NUI, NLAST, FNUL, TOL, ELIM, ALIM
L60:
	if IFORM == 2 {
		goto L70
	}
	// ASYMPTOTIC EXPANSION FOR I(FNU,Z) FOR LARGE FNU APPLIED IN -PI/3 <= ARG(Z) <= PI/3
	ZR, ZI, FNU, KODE, N, YR, YI, NW, NLAST, FNUL, TOL, ELIM, ALIM = ZUNI1(ZR, ZI, FNU, KODE, N, YR, YI, NW, NLAST, FNUL, TOL, ELIM, ALIM)
	goto L80
L70:
	// ASYMPTOTIC EXPANSION FOR J(FNU,Z*EXP(M*HPI)) FOR LARGE FNU APPLIED IN PI/3 < ABS(ARG(Z)) <= PI/2 WHERE M=+I OR -I AND HPI=PI/2
	ZR, ZI, FNU, KODE, N, YR, YI, NW, NLAST, FNUL, TOL, ELIM, ALIM = ZUNI2(ZR, ZI, FNU, KODE, N, YR, YI, NW, NLAST, FNUL, TOL, ELIM, ALIM)
L80:
	if NW < 0 {
		goto L50
	}
	NZ = NW
	return ZR, ZI, FNU, KODE, N, YR, YI, NZ, NUI, NLAST, FNUL, TOL, ELIM, ALIM
L90:
	NLAST = N
	return ZR, ZI, FNU, KODE, N, YR, YI, NZ, NUI, NLAST, FNUL, TOL, ELIM, ALIM
}

// ZUNI1 COMPUTES I(FNU,Z)  BY MEANS OF THE UNIFORM ASYMPTOTIC
// EXPANSION FOR I(FNU,Z) IN -PI/3 <= ARG Z <= PI/3.
//
// FNUL IS THE SMALLEST ORDER PERMITTED FOR THE ASYMPTOTIC
// EXPANSION. NLAST=0 MEANS ALL OF THE Y VALUES WERE SET.
// NLAST.NE.0 IS THE NUMBER LEFT TO BE COMPUTED BY ANOTHER
// FORMULA FOR ORDERS FNU TO FNU+NLAST-1 BECAUSE FNU+NLAST-1 < FNUL.
// Y(I)=CZERO FOR I=NLAST+1,N
func ZUNI1(ZR float64, ZI float64, FNU float64, KODE int, N int, YR []float64, YI []float64, NZ int, NLAST int, FNUL float64, TOL float64, ELIM float64, ALIM float64) (float64, float64, float64, int, int, []float64, []float64, int, int, float64, float64, float64, float64) {

	const (
		ZEROR = 0.0e0
		ZEROI = 0.0e0
		CONER = 1.0e0
	)
	var APHI, ASCLE, CRSC, CSCL, C1R, C2I, C2M, C2R, FN,
		PHII, PHIR, RAST, RS1, RZI, RZR, STI, STR, SUMI,
		SUMR, S1I, S1R, S2I, S2R, ZETA1I,
		ZETA1R, ZETA2I, ZETA2R float64
	var I, IFLAG, INIT, K, M, ND, NN, NUF, NW int

	var CYR, CYI [3]float64
	var CSRR, CSSR, BRY [4]float64
	var CWRKR, CWRKI []float64

	NZ = 0
	ND = N
	NLAST = 0
	// COMPUTED VALUES WITH EXPONENTS BETWEEN ALIM AND ELIM IN MAG-
	// NITUDE ARE SCALED TO KEEP INTERMEDIATE ARITHMETIC ON SCALE,
	// EXP(ALIM)=EXP(ELIM)*TOL
	CSCL = 1.0e0 / TOL
	CRSC = TOL
	CSSR[1] = CSCL
	CSSR[2] = CONER
	CSSR[3] = CRSC
	CSRR[1] = CRSC
	CSRR[2] = CONER
	CSRR[3] = CSCL
	BRY[1] = 1000.0e0 * machine.D1MACH[1] / TOL
	// CHECK FOR UNDERFLOW AND OVERFLOW ON FIRST MEMBER
	FN = math.Max(FNU, 1.0e0)
	INIT = 0
	ZR, ZI, FN, _, _, TOL, INIT, PHIR, PHII, ZETA1R, ZETA1I, ZETA2R, ZETA2I, SUMR, SUMI, CWRKR, CWRKI = ZUNIK(ZR, ZI, FN, 1, 1, TOL, INIT, PHIR, PHII, ZETA1R, ZETA1I, ZETA2R, ZETA2I, SUMR, SUMI, CWRKR, CWRKI)
	if KODE == 1 {
		goto L10
	}
	STR = ZR + ZETA2R
	STI = ZI + ZETA2I
	RAST = FN / ZABS(STR, STI)
	STR = STR * RAST * RAST
	STI = -STI * RAST * RAST
	S1R = -ZETA1R + STR
	S1I = -ZETA1I + STI
	goto L20
L10:
	S1R = -ZETA1R + ZETA2R
	S1I = -ZETA1I + ZETA2I
L20:
	RS1 = S1R
	if math.Abs(RS1) > ELIM {
		goto L130
	}
L30:
	NN = MIN(2, ND)
	for I = 1; I <= NN; I++ {
		FN = FNU + float64(float32(ND-I))
		INIT = 0
		ZR, ZI, FN, _, _, TOL, INIT, PHIR, PHII, ZETA1R, ZETA1I, ZETA2R, ZETA2I, SUMR, SUMI, CWRKR, CWRKI = ZUNIK(ZR, ZI, FN, 1, 0, TOL, INIT, PHIR, PHII, ZETA1R, ZETA1I, ZETA2R, ZETA2I, SUMR, SUMI, CWRKR, CWRKI)
		if KODE == 1 {
			continue
		}
		STR = ZR + ZETA2R
		STI = ZI + ZETA2I
		RAST = FN / ZABS(STR, STI)
		STR = STR * RAST * RAST
		STI = -STI * RAST * RAST
		S1R = -ZETA1R + STR
		S1I = -ZETA1I + STI + ZI
		goto L50

		S1R = -ZETA1R + ZETA2R
		S1I = -ZETA1I + ZETA2I
	L50:
		// TEST FOR UNDERFLOW AND OVERFLOW
		RS1 = S1R
		if math.Abs(RS1) > ELIM {
			goto L110
		}
		if I == 1 {
			IFLAG = 2
		}
		if math.Abs(RS1) < ALIM {
			goto L60
		}
		// REFINE  TEST AND SCALE
		APHI = ZABS(PHIR, PHII)
		RS1 = RS1 + math.Log(APHI)
		if math.Abs(RS1) > ELIM {
			goto L110
		}
		if I == 1 {
			IFLAG = 1
		}
		if RS1 < 0.0e0 {
			goto L60
		}
		if I == 1 {
			IFLAG = 3
		}
	L60:
		// SCALE S1 IF CABS(S1) < ASCLE
		S2R = PHIR*SUMR - PHII*SUMI
		S2I = PHIR*SUMI + PHII*SUMR
		STR = math.Exp(S1R) * CSSR[IFLAG]
		S1R = STR * math.Cos(S1I)
		S1I = STR * math.Sin(S1I)
		STR = S2R*S1R - S2I*S1I
		S2I = S2R*S1I + S2I*S1R
		S2R = STR
		if IFLAG != 1 {
			goto L70
		}
		S2R, S2I, NW, _, TOL = ZUCHK(S2R, S2I, NW, BRY[1], TOL)
		if NW != 0 {
			goto L110
		}
	L70:
		CYR[I] = S2R
		CYI[I] = S2I
		M = ND - I + 1
		YR[M] = S2R * CSRR[IFLAG]
		YI[M] = S2I * CSRR[IFLAG]
	}
	if ND <= 2 {
		goto L100
	}
	RAST = 1.0e0 / ZABS(ZR, ZI)
	STR = ZR * RAST
	STI = -ZI * RAST
	RZR = (STR + STR) * RAST
	RZI = (STI + STI) * RAST
	BRY[2] = 1.0e0 / BRY[1]
	BRY[3] = machine.D1MACH[2]
	S1R = CYR[1]
	S1I = CYI[1]
	S2R = CYR[2]
	S2I = CYI[2]
	C1R = CSRR[IFLAG]
	ASCLE = BRY[IFLAG]
	K = ND - 2
	FN = float64(float32(K))
	for I = 3; I <= ND; I++ {
		C2R = S2R
		C2I = S2I
		S2R = S1R + (FNU+FN)*(RZR*C2R-RZI*C2I)
		S2I = S1I + (FNU+FN)*(RZR*C2I+RZI*C2R)
		S1R = C2R
		S1I = C2I
		C2R = S2R * C1R
		C2I = S2I * C1R
		YR[K] = C2R
		YI[K] = C2I
		K = K - 1
		FN = FN - 1.0e0
		if IFLAG >= 3 {
			continue
		}
		STR = math.Abs(C2R)
		STI = math.Abs(C2I)
		C2M = math.Max(STR, STI)
		if C2M <= ASCLE {
			continue
		}
		IFLAG = IFLAG + 1
		ASCLE = BRY[IFLAG]
		S1R = S1R * C1R
		S1I = S1I * C1R
		S2R = C2R
		S2I = C2I
		S1R = S1R * CSSR[IFLAG]
		S1I = S1I * CSSR[IFLAG]
		S2R = S2R * CSSR[IFLAG]
		S2I = S2I * CSSR[IFLAG]
		C1R = CSRR[IFLAG]
	}
L100:
	return ZR, ZI, FNU, KODE, N, YR, YI, NZ, NLAST, FNUL, TOL, ELIM, ALIM
	// SET UNDERFLOW AND UPDATE PARAMETERS
L110:
	if RS1 > 0.0e0 {
		goto L120
	}
	YR[ND] = ZEROR
	YI[ND] = ZEROI
	NZ = NZ + 1
	ND = ND - 1
	if ND == 0 {
		goto L100
	}
	ZR, ZI, FNU, KODE, _, ND, YR, YI, NUF, TOL, ELIM, ALIM = ZUOIK(ZR, ZI, FNU, KODE, 1, ND, YR, YI, NUF, TOL, ELIM, ALIM)
	if NUF < 0 {
		goto L120
	}
	ND = ND - NUF
	NZ = NZ + NUF
	if ND == 0 {
		goto L100
	}
	FN = FNU + float64(float32(ND-1))
	if FN >= FNUL {
		goto L30
	}
	NLAST = ND
	return ZR, ZI, FNU, KODE, N, YR, YI, NZ, NLAST, FNUL, TOL, ELIM, ALIM
L120:
	NZ = -1
	return ZR, ZI, FNU, KODE, N, YR, YI, NZ, NLAST, FNUL, TOL, ELIM, ALIM
L130:
	if RS1 > 0.0e0 {
		goto L120
	}
	NZ = N
	for I = 1; I <= N; I++ {
		YR[I] = ZEROR
		YI[I] = ZEROI
	}
	return ZR, ZI, FNU, KODE, N, YR, YI, NZ, NLAST, FNUL, TOL, ELIM, ALIM
}

// ZBINU COMPUTES THE I FUNCTION IN THE RIGHT HALF Z PLANE
func ZBINU(ZR float64, ZI float64, FNU float64, KODE int, N int, CYR []float64, CYI []float64, NZ int,
	RL float64, FNUL float64, TOL float64, ELIM float64, ALIM float64) (float64, float64, float64, int, int, []float64, []float64, int, float64, float64, float64, float64, float64) {

	const (
		ZEROR = 0.0e0
		ZEROI = 0.0e0
	)

	var AZ, DFNU float64
	var I, INW, NLAST, NN, NUI, NW int

	CWR := []float64{math.NaN(), 0, 0}
	CWI := []float64{math.NaN(), 0, 0}

	NZ = 0
	AZ = ZABS(ZR, ZI)
	NN = N
	DFNU = FNU + float64(float32(N-1))
	if AZ <= 2.0e0 {
		goto L10
	}
	if AZ*AZ*0.25e0 > DFNU+1.0e0 {
		goto L20
	}
L10:
	// POWER SERIES
	ZR, ZI, FNU, KODE, NN, CYR, CYI, NW, TOL, ELIM, ALIM = ZSERI(ZR, ZI, FNU, KODE, NN, CYR, CYI, NW, TOL, ELIM, ALIM)
	INW = ABS(NW)
	NZ = NZ + INW
	NN = NN - INW
	if NN == 0 {
		return ZR, ZI, FNU, KODE, N, CYR, CYI, NZ, RL, FNUL, TOL, ELIM, ALIM
	}
	if NW >= 0 {
		goto L120
	}
	DFNU = FNU + float64(float32(NN-1))
L20:
	if AZ < RL {
		goto L40
	}
	if DFNU <= 1.0e0 {
		goto L30
	}
	if AZ+AZ < DFNU*DFNU {
		goto L50
	}

	// ASYMPTOTIC EXPANSION FOR LARGE Z
L30:
	ZR, ZI, FNU, KODE, NN, CYR, CYI, NW, RL, TOL, ELIM, ALIM = ZASYI(ZR, ZI, FNU, KODE, NN, CYR, CYI, NW, RL, TOL, ELIM, ALIM)
	if NW < 0 {
		goto L130
	}
	goto L120
L40:
	if DFNU <= 1.0e0 {
		goto L70
	}
L50:
	// OVERFLOW AND UNDERFLOW TEST ON I SEQUENCE FOR MILLER ALGORITHM
	ZR, ZI, FNU, KODE, _, NN, CYR, CYI, NW, TOL, ELIM, ALIM = ZUOIK(ZR, ZI, FNU, KODE, 1, NN, CYR, CYI, NW, TOL, ELIM, ALIM)
	if NW < 0 {
		goto L130
	}
	NZ = NZ + NW
	NN = NN - NW
	if NN == 0 {
		return ZR, ZI, FNU, KODE, N, CYR, CYI, NZ, RL, FNUL, TOL, ELIM, ALIM
	}
	DFNU = FNU + float64(float32(NN-1))
	if DFNU > FNUL {
		goto L110
	}
	if AZ > FNUL {
		goto L110
	}
L60:
	if AZ > RL {
		goto L80
	}
L70:
	// MILLER ALGORITHM NORMALIZED BY THE SERIES
	ZR, ZI, FNU, KODE, NN, CYR, CYI, NW, TOL = ZMLRI(ZR, ZI, FNU, KODE, NN, CYR, CYI, NW, TOL)
	if NW < 0 {
		goto L130
	}
	goto L120
L80:
	// MILLER ALGORITHM NORMALIZED BY THE WRONSKIAN
	// OVERFLOW TEST ON K FUNCTIONS USED IN WRONSKIAN
	ZR, ZI, FNU, KODE, _, _, CWR, CWI, NW, TOL, ELIM, ALIM = ZUOIK(ZR, ZI, FNU, KODE, 2, 2, CWR, CWI, NW, TOL, ELIM, ALIM)
	if NW >= 0 {
		goto L100
	}
	NZ = NN
	for I = 1; I <= NN; I++ {
		CYR[I] = ZEROR
		CYI[I] = ZEROI
	}
	return ZR, ZI, FNU, KODE, N, CYR, CYI, NZ, RL, FNUL, TOL, ELIM, ALIM
L100:
	if NW > 0 {
		goto L130
	}
	ZR, ZI, FNU, KODE, NN, CYR, CYI, NW, CWR, CWI, TOL, ELIM, ALIM = ZWRSK(ZR, ZI, FNU, KODE, NN, CYR, CYI, NW, CWR, CWI, TOL, ELIM, ALIM)
	if NW < 0 {
		goto L130
	}
	goto L120
L110:
	// INCREMENT FNU+NN-1 UP TO FNUL, COMPUTE AND RECUR BACKWARD
	NUI = int(float32(FNUL-DFNU)) + 1
	NUI = MAX(NUI, 0)
	ZR, ZI, FNU, KODE, NN, CYR, CYI, NW, NUI, NLAST, FNUL, TOL, ELIM, ALIM = ZBUNI(ZR, ZI, FNU, KODE, NN, CYR, CYI, NW, NUI, NLAST, FNUL, TOL, ELIM, ALIM)
	if NW < 0 {
		goto L130
	}
	NZ = NZ + NW
	if NLAST == 0 {
		goto L120
	}
	NN = NLAST
	goto L60
L120:
	return ZR, ZI, FNU, KODE, N, CYR, CYI, NZ, RL, FNUL, TOL, ELIM, ALIM

L130:
	NZ = -1
	if NW == -2 {
		NZ = -2
	}
	return ZR, ZI, FNU, KODE, N, CYR, CYI, NZ, RL, FNUL, TOL, ELIM, ALIM
}

// ZWRSK COMPUTES THE I BESSEL FUNCTION FOR RE(Z) >= 0.0 BY
// NORMALIZING THE I FUNCTION RATIOS FROM ZRATI BY THE WRONSKIAN
func ZWRSK(ZRR float64, ZRI float64, FNU float64, KODE int, N int, YR []float64, YI []float64, NZ int, CWR []float64, CWI []float64, TOL float64, ELIM float64, ALIM float64) (float64, float64, float64, int, int, []float64, []float64, int, []float64, []float64, float64, float64, float64) {

	var ACT, ACW, ASCLE, CINUI, CINUR, CSCLR, CTI, CTR, C1R, C1I, C2I, C2R, PTI, PTR, RACT, STI, STR float64
	var I, NW int

	// I(FNU+I-1,Z) BY BACKWARD RECURRENCE FOR RATIOS
	// Y(I)=I(FNU+I,Z)/I(FNU+I-1,Z) FROM CRATI NORMALIZED BY THE
	// WRONSKIAN WITH K(FNU,Z) AND K(FNU+1,Z) FROM CBKNU.
	NZ = 0
	ZRR, ZRI, FNU, KODE, _, CWR, CWI, NW, TOL, ELIM, ALIM = ZBKNU(ZRR, ZRI, FNU, KODE, 2, CWR, CWI, NW, TOL, ELIM, ALIM)
	if NW != 0 {
		goto L50
	}
	ZRR, ZRI, FNU, N, YR, YI, TOL = ZRATI(ZRR, ZRI, FNU, N, YR, YI, TOL)

	// RECUR FORWARD ON I(FNU+1,Z) = R(FNU,Z)*I(FNU,Z),
	// R(FNU+J-1,Z)=Y(J),  J=1,...,N
	CINUR = 1.0e0
	CINUI = 0.0e0
	if KODE == 1 {
		goto L10
	}
	CINUR = math.Cos(ZRI)
	CINUI = math.Sin(ZRI)
L10:
	// ON LOW EXPONENT MACHINES THE K FUNCTIONS CAN BE CLOSE TO BOTH
	// THE UNDER AND OVERFLOW LIMITS AND THE NORMALIZATION MUST BE
	// SCALED TO PREVENT OVER OR UNDERFLOW. CUOIK HAS DETERMINED THAT
	// THE RESULT IS ON SCALE.
	ACW = ZABS(CWR[2], CWI[2])
	ASCLE = 1000.0e0 * machine.D1MACH[1] / TOL
	CSCLR = 1.0e0
	if ACW > ASCLE {
		goto L20
	}
	CSCLR = 1.0e0 / TOL
	goto L30
L20:
	ASCLE = 1.0e0 / ASCLE
	if ACW < ASCLE {
		goto L30
	}
	CSCLR = TOL
L30:
	C1R = CWR[1] * CSCLR
	C1I = CWI[1] * CSCLR
	C2R = CWR[2] * CSCLR
	C2I = CWI[2] * CSCLR
	STR = YR[1]
	STI = YI[1]

	// CINU=CINU*(CONJG(CT)/CABS(CT))*(1.0e0/CABS(CT) PREVENTS
	// UNDER- OR OVERFLOW PREMATURELY BY SQUARING CABS(CT)
	PTR = STR*C1R - STI*C1I
	PTI = STR*C1I + STI*C1R
	PTR = PTR + C2R
	PTI = PTI + C2I
	CTR = ZRR*PTR - ZRI*PTI
	CTI = ZRR*PTI + ZRI*PTR
	ACT = ZABS(CTR, CTI)
	RACT = 1.0e0 / ACT
	CTR = CTR * RACT
	CTI = -CTI * RACT
	PTR = CINUR * RACT
	PTI = CINUI * RACT
	CINUR = PTR*CTR - PTI*CTI
	CINUI = PTR*CTI + PTI*CTR
	YR[1] = CINUR * CSCLR
	YI[1] = CINUI * CSCLR
	if N == 1 {
		return ZRR, ZRI, FNU, KODE, N, YR, YI, NZ, CWR, CWI, TOL, ELIM, ALIM
	}
	for I = 2; I <= N; I++ {

		PTR = STR*CINUR - STI*CINUI
		CINUI = STR*CINUI + STI*CINUR
		CINUR = PTR
		STR = YR[I]
		STI = YI[I]
		YR[I] = CINUR * CSCLR
		YI[I] = CINUI * CSCLR
	}
	return ZRR, ZRI, FNU, KODE, N, YR, YI, NZ, CWR, CWI, TOL, ELIM, ALIM
L50:
	NZ = -1
	if NW == -2 {
		NZ = -2
	}
	return ZRR, ZRI, FNU, KODE, N, YR, YI, NZ, CWR, CWI, TOL, ELIM, ALIM
}

// ZRATI COMPUTES RATIOS OF I BESSEL FUNCTIONS BY BACKWARD
// RECURRENCE.  THE STARTING INDEX IS DETERMINED BY FORWARD
// RECURRENCE AS DESCRIBED IN J. RES. OF NAT. BUR. OF STANDARDS-B,
// MATHEMATICAL SCIENCES, VOL 77B, P111-114, SEPTEMBER, 1973,
// BESSEL FUNCTIONS I AND J OF COMPLEX ARGUMENT AND INTEGER ORDER,
//   BY D. J. SOOKNE.
func ZRATI(ZR float64, ZI float64, FNU float64, N int, CYR []float64, CYI []float64, TOL float64) (float64, float64, float64, int, []float64, []float64, float64) {

	const (
		CZEROR = 0.0e0
		CZEROI = 0.0e0
		CONER  = 1.0e0
		CONEI  = 0.0e0
		RT2    = 1.41421356237309505e0
	)

	var AK, AMAGZ, AP1, AP2, ARG, AZ, CDFNUI, CDFNUR, DFNU, FDNU, FLAM, FNUP, PTI, PTR, P1I, P1R,
		P2I, P2R, RAK, RAP1, RHO, RZI, RZR, TEST, TEST1, TTI, TTR, T1I, T1R float64
	var I, ID, IDNU, INU, ITIME, K, KK, MAGZ int

	AZ = ZABS(ZR, ZI)
	INU = int(float32(FNU))
	IDNU = INU + N - 1
	MAGZ = int(float32(AZ))
	AMAGZ = float64(float32(MAGZ + 1))
	FDNU = float64(float32(IDNU))
	FNUP = math.Max(AMAGZ, FDNU)
	ID = IDNU - MAGZ - 1
	ITIME = 1
	K = 1
	PTR = 1.0e0 / AZ
	RZR = PTR * (ZR + ZR) * PTR
	RZI = -PTR * (ZI + ZI) * PTR
	T1R = RZR * FNUP
	T1I = RZI * FNUP
	P2R = -T1R
	P2I = -T1I
	P1R = CONER
	P1I = CONEI
	T1R = T1R + RZR
	T1I = T1I + RZI
	if ID > 0 {
		ID = 0
	}
	AP2 = ZABS(P2R, P2I)
	AP1 = ZABS(P1R, P1I)
	// THE OVERFLOW TEST ON K(FNU+I-1,Z) BEFORE THE CALL TO CBKNU
	// GUARANTEES THAT P2 IS ON SCALE. SCALE TEST1 AND ALL SUBSEQUENT
	// P2 VALUES BY AP1 TO ENSURE THAT AN OVERFLOW DOES NOT OCCUR
	// PREMATURELY.
	ARG = (AP2 + AP2) / (AP1 * TOL)
	TEST1 = math.Sqrt(ARG)
	TEST = TEST1
	RAP1 = 1.0e0 / AP1
	P1R = P1R * RAP1
	P1I = P1I * RAP1
	P2R = P2R * RAP1
	P2I = P2I * RAP1
	AP2 = AP2 * RAP1
L10:
	K = K + 1
	AP1 = AP2
	PTR = P2R
	PTI = P2I
	P2R = P1R - (T1R*PTR - T1I*PTI)
	P2I = P1I - (T1R*PTI + T1I*PTR)
	P1R = PTR
	P1I = PTI
	T1R = T1R + RZR
	T1I = T1I + RZI
	AP2 = ZABS(P2R, P2I)
	if AP1 <= TEST {
		goto L10
	}
	if ITIME == 2 {
		goto L20
	}
	AK = ZABS(T1R, T1I) * 0.5e0
	FLAM = AK + math.Sqrt(AK*AK-1.0e0)
	RHO = math.Min(AP2/AP1, FLAM)
	TEST = TEST1 * math.Sqrt(RHO/(RHO*RHO-1.0e0))
	ITIME = 2
	goto L10
L20:
	KK = K + 1 - ID
	AK = float64(float32(KK))
	T1R = AK
	T1I = CZEROI
	DFNU = FNU + float64(float32(N-1))
	P1R = 1.0e0 / AP2
	P1I = CZEROI
	P2R = CZEROR
	P2I = CZEROI
	for I = 1; I <= KK; I++ {
		PTR = P1R
		PTI = P1I
		RAP1 = DFNU + T1R
		TTR = RZR * RAP1
		TTI = RZI * RAP1
		P1R = (PTR*TTR - PTI*TTI) + P2R
		P1I = (PTR*TTI + PTI*TTR) + P2I
		P2R = PTR
		P2I = PTI
		T1R = T1R - CONER
	}
	if P1R != CZEROR || P1I != CZEROI {
		goto L40
	}
	P1R = TOL
	P1I = TOL
L40:
	CYR[N], CYI[N] = ZDIV(P2R, P2I, P1R, P1I)
	if N == 1 {
		return ZR, ZI, FNU, N, CYR, CYI, TOL
	}
	K = N - 1
	AK = float64(float32(K))
	T1R = AK
	T1I = CZEROI
	CDFNUR = FNU * RZR
	CDFNUI = FNU * RZI
	for I = 2; I <= N; I++ {
		PTR = CDFNUR + (T1R*RZR - T1I*RZI) + CYR[K+1]
		PTI = CDFNUI + (T1R*RZI + T1I*RZR) + CYI[K+1]
		AK = ZABS(PTR, PTI)
		if AK != CZEROR {
			goto L50
		}
		PTR = TOL
		PTI = TOL
		AK = TOL * RT2
	L50:
		RAK = CONER / AK
		CYR[K] = RAK * PTR * RAK
		CYI[K] = -RAK * PTI * RAK
		T1R = T1R - CONER
		K = K - 1
	}
	return ZR, ZI, FNU, N, CYR, CYI, TOL
}

// ZUNI2 COMPUTES I(FNU,Z) IN THE RIGHT HALF PLANE BY MEANS OF
// UNIFORM ASYMPTOTIC EXPANSION FOR J(FNU,ZN) WHERE ZN IS Z*I
// OR -Z*I AND ZN IS IN THE RIGHT HALF PLANE ALSO.
//
// FNUL IS THE SMALLEST ORDER PERMITTED FOR THE ASYMPTOTIC
// EXPANSION. NLAST=0 MEANS ALL OF THE Y VALUES WERE SET.
// NLAST != 0 IS THE NUMBER LEFT TO BE COMPUTED BY ANOTHER
// FORMULA FOR ORDERS FNU TO FNU+NLAST-1 BECAUSE FNU+NLAST-1 < FNUL.
// Y(I)=CZERO FOR I=NLAST+1,N
func ZUNI2(ZR float64, ZI float64, FNU float64, KODE int, N int, YR []float64, YI []float64, NZ int, NLAST int, FNUL float64, TOL float64, ELIM float64, ALIM float64) (float64, float64, float64, int, int, []float64, []float64, int, int, float64, float64, float64, float64) {

	const (
		ZEROR = 0.0e0
		ZEROI = 0.0e0
		CONER = 1.0e0
		RT2   = 1.41421356237309505e0
		HPI   = 1.57079632679489662e+00
		AIC   = 1.265512123484645396e+00
	)

	var AARG, AII, AIR, ANG, APHI, ARGI, ARGR, ASCLE, ASUMI, ASUMR, BSUMI, BSUMR, CIDI,
		CRSC, CSCL, C1R, C2I, C2M, C2R, DAII, DAIR, FN, PHII, PHIR, RAST, RAZ, RS1, RZI, RZR,
		STI, STR, S1I, S1R, S2I, S2R, ZBI, ZBR, ZETA1I, ZETA1R, ZETA2I, ZETA2R, ZNI, ZNR, CAR, SAR float64

	var I, IFLAG, IN, INU, J, K, ND, NN, NUF, NW int

	var BRY, CSSR, CSRR [4]float64
	var CYR, CYI [4]float64
	var CIPR = [5]float64{math.NaN(), 1.0e0, 0.0e0, -1.0e0, 0.0e0}
	var CIPI = [5]float64{math.NaN(), 0.0e0, 1.0e0, 0.0e0, -1.0e0}

	NZ = 0
	ND = N
	NLAST = 0

	// COMPUTED VALUES WITH EXPONENTS BETWEEN ALIM AND ELIM IN MAG-
	// NITUDE ARE SCALED TO KEEP INTERMEDIATE ARITHMETIC ON SCALE,
	// EXP(ALIM)=EXP(ELIM)*TOL
	CSCL = 1.0e0 / TOL
	CRSC = TOL
	CSSR[1] = CSCL
	CSSR[2] = CONER
	CSSR[3] = CRSC
	CSRR[1] = CRSC
	CSRR[2] = CONER
	CSRR[3] = CSCL
	BRY[1] = 1000.0e0 * machine.D1MACH[1] / TOL

	// ZN IS IN THE RIGHT HALF PLANE AFTER ROTATION BY CI OR -CI
	ZNR = ZI
	ZNI = -ZR
	ZBR = ZR
	ZBI = ZI
	CIDI = -CONER
	INU = int(float32(FNU))
	ANG = HPI * (FNU - float64(float32(INU)))
	C2R = math.Cos(ANG)
	C2I = math.Sin(ANG)
	CAR = C2R
	SAR = C2I
	IN = INU + N - 1
	IN = IN%4 + 1
	STR = C2R*CIPR[IN] - C2I*CIPI[IN]
	C2I = C2R*CIPI[IN] + C2I*CIPR[IN]
	C2R = STR
	if ZI > 0.0e0 {
		goto L10
	}
	ZNR = -ZNR
	ZBI = -ZBI
	CIDI = -CIDI
	C2I = -C2I
L10:
	// CHECK FOR UNDERFLOW AND OVERFLOW ON FIRST MEMBER
	FN = math.Max(FNU, 1.0e0)
	ZNR, ZNI, FN, _, TOL, PHIR, PHII, ARGR, ARGI, ZETA1R, ZETA1I, ZETA2R, ZETA2I, ASUMR, ASUMI, BSUMR, BSUMI = ZUNHJ(ZNR, ZNI, FN, 1, TOL, PHIR, PHII, ARGR, ARGI, ZETA1R, ZETA1I, ZETA2R, ZETA2I, ASUMR, ASUMI, BSUMR, BSUMI)
	if KODE == 1 {
		goto L20
	}
	STR = ZBR + ZETA2R
	STI = ZBI + ZETA2I
	RAST = FN / ZABS(STR, STI)
	STR = STR * RAST * RAST
	STI = -STI * RAST * RAST
	S1R = -ZETA1R + STR
	S1I = -ZETA1I + STI
	goto L30
L20:
	S1R = -ZETA1R + ZETA2R
	S1I = -ZETA1I + ZETA2I
L30:
	RS1 = S1R
	if math.Abs(RS1) > ELIM {
		goto L150
	}
L40:
	NN = MIN(2, ND)
	for I = 1; I <= NN; I++ {
		FN = FNU + float64(float32(ND-I))
		ZNR, ZNI, FN, _, TOL, PHIR, PHII, ARGR, ARGI, ZETA1R, ZETA1I, ZETA2R, ZETA2I, ASUMR, ASUMI, BSUMR, BSUMI = ZUNHJ(ZNR, ZNI, FN, 0, TOL, PHIR, PHII, ARGR, ARGI, ZETA1R, ZETA1I, ZETA2R, ZETA2I, ASUMR, ASUMI, BSUMR, BSUMI)
		if KODE == 1 {
			goto L50
		}
		STR = ZBR + ZETA2R
		STI = ZBI + ZETA2I
		RAST = FN / ZABS(STR, STI)
		STR = STR * RAST * RAST
		STI = -STI * RAST * RAST
		S1R = -ZETA1R + STR
		S1I = -ZETA1I + STI + math.Abs(ZI)
		goto L60
	L50:
		S1R = -ZETA1R + ZETA2R
		S1I = -ZETA1I + ZETA2I
	L60:
		// TEST FOR UNDERFLOW AND OVERFLOW
		RS1 = S1R
		if math.Abs(RS1) > ELIM {
			goto L120
		}
		if I == 1 {
			IFLAG = 2
		}
		if math.Abs(RS1) < ALIM {
			goto L70
		}

		// REFINE  TEST AND SCALE
		APHI = ZABS(PHIR, PHII)
		AARG = ZABS(ARGR, ARGI)
		RS1 = RS1 + math.Log(APHI) - 0.25e0*math.Log(AARG) - AIC
		if math.Abs(RS1) > ELIM {
			goto L120
		}
		if I == 1 {
			IFLAG = 1
		}
		if RS1 < 0.0e0 {
			goto L70
		}
		if I == 1 {
			IFLAG = 3
		}
	L70:

		// SCALE S1 TO KEEP INTERMEDIATE ARITHMETIC ON SCALE NEAR
		// EXPONENT EXTREMES
		AIR, AII, _, _ = ZAIRY(ARGR, ARGI, 0, 2)
		DAIR, DAII, _, _ = ZAIRY(ARGR, ARGI, 1, 2)

		STR = DAIR*BSUMR - DAII*BSUMI
		STI = DAIR*BSUMI + DAII*BSUMR
		STR = STR + (AIR*ASUMR - AII*ASUMI)
		STI = STI + (AIR*ASUMI + AII*ASUMR)
		S2R = PHIR*STR - PHII*STI
		S2I = PHIR*STI + PHII*STR
		STR = math.Exp(S1R) * CSSR[IFLAG]
		S1R = STR * math.Cos(S1I)
		S1I = STR * math.Sin(S1I)
		STR = S2R*S1R - S2I*S1I
		S2I = S2R*S1I + S2I*S1R
		S2R = STR
		if IFLAG != 1 {
			goto L80
		}
		S2R, S2I, NW, BRY[1], TOL = ZUCHK(S2R, S2I, NW, BRY[1], TOL)
		if NW != 0 {
			goto L120
		}
	L80:
		if ZI <= 0.0e0 {
			S2I = -S2I
		}
		STR = S2R*C2R - S2I*C2I
		S2I = S2R*C2I + S2I*C2R
		S2R = STR
		CYR[I] = S2R
		CYI[I] = S2I
		J = ND - I + 1
		YR[J] = S2R * CSRR[IFLAG]
		YI[J] = S2I * CSRR[IFLAG]
		STR = -C2I * CIDI
		C2I = C2R * CIDI
		C2R = STR
	}
	if ND <= 2 {
		goto L110
	}
	RAZ = 1.0e0 / ZABS(ZR, ZI)
	STR = ZR * RAZ
	STI = -ZI * RAZ
	RZR = (STR + STR) * RAZ
	RZI = (STI + STI) * RAZ
	BRY[2] = 1.0e0 / BRY[1]
	BRY[3] = machine.D1MACH[2]
	S1R = CYR[1]
	S1I = CYI[1]
	S2R = CYR[2]
	S2I = CYI[2]
	C1R = CSRR[IFLAG]
	ASCLE = BRY[IFLAG]
	K = ND - 2
	FN = float64(float32(K))
	for I = 3; I <= ND; I++ {
		C2R = S2R
		C2I = S2I
		S2R = S1R + (FNU+FN)*(RZR*C2R-RZI*C2I)
		S2I = S1I + (FNU+FN)*(RZR*C2I+RZI*C2R)
		S1R = C2R
		S1I = C2I
		C2R = S2R * C1R
		C2I = S2I * C1R
		YR[K] = C2R
		YI[K] = C2I
		K = K - 1
		FN = FN - 1.0e0
		if IFLAG >= 3 {
			continue
		}
		STR = math.Abs(C2R)
		STI = math.Abs(C2I)
		C2M = math.Max(STR, STI)
		if C2M <= ASCLE {
			continue
		}
		IFLAG = IFLAG + 1
		ASCLE = BRY[IFLAG]
		S1R = S1R * C1R
		S1I = S1I * C1R
		S2R = C2R
		S2I = C2I
		S1R = S1R * CSSR[IFLAG]
		S1I = S1I * CSSR[IFLAG]
		S2R = S2R * CSSR[IFLAG]
		S2I = S2I * CSSR[IFLAG]
		C1R = CSRR[IFLAG]
	}
L110:
	return ZR, ZI, FNU, KODE, N, YR, YI, NZ, NLAST, FNUL, TOL, ELIM, ALIM
L120:
	if RS1 > 0.0e0 {
		goto L140
	}

	// SET UNDERFLOW AND UPDATE PARAMETERS
	YR[ND] = ZEROR
	YI[ND] = ZEROI
	NZ = NZ + 1
	ND = ND - 1
	if ND == 0 {
		goto L110
	}
	ZR, ZI, FNU, KODE, _, ND, YR, YI, NUF, TOL, ELIM, ALIM = ZUOIK(ZR, ZI, FNU, KODE, 1, ND, YR, YI, NUF, TOL, ELIM, ALIM)
	if NUF < 0 {
		goto L140
	}
	ND = ND - NUF
	NZ = NZ + NUF
	if ND == 0 {
		goto L110
	}
	FN = FNU + float64(float32(ND-1))
	if FN < FNUL {
		goto L130
	}
	IN = INU + ND - 1
	IN = IN%4 + 1
	C2R = CAR*CIPR[IN] - SAR*CIPI[IN]
	C2I = CAR*CIPI[IN] + SAR*CIPR[IN]
	if ZI <= 0.0e0 {
		C2I = -C2I
	}
	goto L40
L130:
	NLAST = ND
	return ZR, ZI, FNU, KODE, N, YR, YI, NZ, NLAST, FNUL, TOL, ELIM, ALIM
L140:
	NZ = -1
	return ZR, ZI, FNU, KODE, N, YR, YI, NZ, NLAST, FNUL, TOL, ELIM, ALIM
L150:
	if RS1 > 0.0e0 {
		goto L140
	}
	NZ = N
	for I = 1; I <= N; I++ {
		YR[I] = ZEROR
		YI[I] = ZEROI
	}
	return ZR, ZI, FNU, KODE, N, YR, YI, NZ, NLAST, FNUL, TOL, ELIM, ALIM

}

// ZUNHJ COMPUTES PARAMETERS FOR BESSEL FUNCTIONS C(FNU,Z) =
// J(FNU,Z), Y(FNU,Z) OR H(I,FNU,Z) I=1,2 FOR LARGE ORDERS FNU
// BY MEANS OF THE UNIFORM ASYMPTOTIC EXPANSION
//
// C(FNU,Z)=C1*PHI*( ASUM*AIRY(ARG) + C2*BSUM*DAIRY(ARG) )
//
// FOR PROPER CHOICES OF C1, C2, AIRY AND DAIRY WHERE AIRY IS
// AN AIRY FUNCTION AND DAIRY IS ITS DERIVATIVE.
//
//       (2/3)*FNU*ZETA**1.5 = ZETA1-ZETA2,
//
// ZETA1=0.5*FNU*CLOG((1+W)/(1-W)), ZETA2=FNU*W FOR SCALING
// PURPOSES IN AIRY FUNCTIONS FROM CAIRY OR CBIRY.
//
// MCONJ=SIGN OF AIMAG(Z), BUT IS AMBIGUOUS WHEN Z IS REAL AND
// MUST BE SPECIFIED. IPMTR=0 RETURNS ALL PARAMETERS. IPMTR=
// 1 COMPUTES ALL EXCEPT ASUM AND BSUM.
//
// HANDBOOK OF MATHEMATICAL FUNCTIONS BY M. ABRAMOWITZ AND I.A.
// STEGUN, AMS55, NATIONAL BUREAU OF STANDARDS, 1965, CHAPTER 9.
// ASYMPTOTICS AND SPECIAL FUNCTIONS BY F.W.J. OLVER, ACADEMIC
// PRESS, N.Y., 1974, PAGE 420
func ZUNHJ(ZR float64, ZI float64, FNU float64, IPMTR int, TOL float64, PHIR float64, PHII float64,
	ARGR float64, ARGI float64, ZETA1R float64, ZETA1I float64, ZETA2R float64, ZETA2I float64,
	ASUMR float64, ASUMI float64, BSUMR float64, BSUMI float64) (float64, float64, float64, int, float64, float64, float64,
	float64, float64, float64, float64, float64, float64, float64, float64, float64, float64) {

	const (
		ZEROR = 0.0e0
		ZEROI = 0.0e0
		CONER = 1.0e0
		CONEI = 1.0e0
		EX1   = 3.33333333333333333e-01
		EX2   = 6.66666666666666667e-01
		HPI   = 1.57079632679489662e+00
		GPI   = 3.14159265358979324e+00
		THPI  = 4.71238898038468986e+00
	)

	var ANG, ATOL, AW2, AZTH, BTOL, FN13, FN23,
		PP, PRZTHI, PRZTHR, PTFNI, PTFNR, RAW, RAW2, RAZTH, RFNU, RFNU2, RFN13, RTZTI, RTZTR, RZTHI, RZTHR, STI, STR,
		SUMAI, SUMAR, SUMBI, SUMBR, TEST, TFNI, TFNR, TZAI, TZAR, T2I, T2R, WI, WR, W2I, W2R, ZAI, ZAR, ZBI, ZBR,
		ZCI, ZCR, ZETAI, ZETAR, ZTHI, ZTHR, AC float64
	var IAS, IBS, IS, J, JR, JU, K, KMAX, KP1, KS, L, LR, LRP1, L1, L2, M int

	var AP, PR, PI [31]float64
	var UPR, UPI, CRR, CRI, DRR, DRI [15]float64

	var AR = [15]float64{math.NaN(),
		1.00000000000000000e+00, 1.04166666666666667e-01,
		8.35503472222222222e-02, 1.28226574556327160e-01,
		2.91849026464140464e-01, 8.81627267443757652e-01,
		3.32140828186276754e+00, 1.49957629868625547e+01,
		7.89230130115865181e+01, 4.74451538868264323e+02,
		3.20749009089066193e+03, 2.40865496408740049e+04,
		1.98923119169509794e+05, 1.79190200777534383e+06}

	var BR = [15]float64{math.NaN(),
		1.00000000000000000e+00, -1.45833333333333333e-01,
		-9.87413194444444444e-02, -1.43312053915895062e-01,
		-3.17227202678413548e-01, -9.42429147957120249e-01,
		-3.51120304082635426e+00, -1.57272636203680451e+01,
		-8.22814390971859444e+01, -4.92355370523670524e+02,
		-3.31621856854797251e+03, -2.48276742452085896e+04,
		-2.04526587315129788e+05, -1.83844491706820990e+06}

	var C = [106]float64{math.NaN(),
		1.00000000000000000e+00, -2.08333333333333333e-01,
		1.25000000000000000e-01, 3.34201388888888889e-01,
		-4.01041666666666667e-01, 7.03125000000000000e-02,
		-1.02581259645061728e+00, 1.84646267361111111e+00,
		-8.91210937500000000e-01, 7.32421875000000000e-02,
		4.66958442342624743e+00, -1.12070026162229938e+01,
		8.78912353515625000e+00, -2.36408691406250000e+00,
		1.12152099609375000e-01, -2.82120725582002449e+01,
		8.46362176746007346e+01, -9.18182415432400174e+01,
		4.25349987453884549e+01, -7.36879435947963170e+00,
		2.27108001708984375e-01, 2.12570130039217123e+02,
		-7.65252468141181642e+02, 1.05999045252799988e+03,
		-6.99579627376132541e+02, 2.18190511744211590e+02,
		-2.64914304869515555e+01, 5.72501420974731445e-01,
		-1.91945766231840700e+03, 8.06172218173730938e+03,
		-1.35865500064341374e+04, 1.16553933368645332e+04,
		-5.30564697861340311e+03, 1.20090291321635246e+03,
		-1.08090919788394656e+02, 1.72772750258445740e+00,
		2.02042913309661486e+04, -9.69805983886375135e+04,
		1.92547001232531532e+05, -2.03400177280415534e+05,
		1.22200464983017460e+05, -4.11926549688975513e+04,
		7.10951430248936372e+03, -4.93915304773088012e+02,
		6.07404200127348304e+00, -2.42919187900551333e+05,
		1.31176361466297720e+06, -2.99801591853810675e+06,
		3.76327129765640400e+06, -2.81356322658653411e+06,
		1.26836527332162478e+06, -3.31645172484563578e+05,
		4.52187689813627263e+04, -2.49983048181120962e+03,
		2.43805296995560639e+01, 3.28446985307203782e+06,
		-1.97068191184322269e+07, 5.09526024926646422e+07,
		-7.41051482115326577e+07, 6.63445122747290267e+07,
		-3.75671766607633513e+07, 1.32887671664218183e+07,
		-2.78561812808645469e+06, 3.08186404612662398e+05,
		-1.38860897537170405e+04, 1.10017140269246738e+02,
		-4.93292536645099620e+07, 3.25573074185765749e+08,
		-9.39462359681578403e+08, 1.55359689957058006e+09,
		-1.62108055210833708e+09, 1.10684281682301447e+09,
		-4.95889784275030309e+08, 1.42062907797533095e+08,
		-2.44740627257387285e+07, 2.24376817792244943e+06,
		-8.40054336030240853e+04, 5.51335896122020586e+02,
		8.14789096118312115e+08, -5.86648149205184723e+09,
		1.86882075092958249e+10, -3.46320433881587779e+10,
		4.12801855797539740e+10, -3.30265997498007231e+10,
		1.79542137311556001e+10, -6.56329379261928433e+09,
		1.55927986487925751e+09, -2.25105661889415278e+08,
		1.73951075539781645e+07, -5.49842327572288687e+05,
		3.03809051092238427e+03, -1.46792612476956167e+10,
		1.14498237732025810e+11, -3.99096175224466498e+11,
		8.19218669548577329e+11, -1.09837515608122331e+12,
		1.00815810686538209e+12, -6.45364869245376503e+11,
		2.87900649906150589e+11, -8.78670721780232657e+10,
		1.76347306068349694e+10, -2.16716498322379509e+09,
		1.43157876718888981e+08, -3.87183344257261262e+06,
		1.82577554742931747e+04}

	var ALFA = [181]float64{math.NaN(),
		-4.44444444444444444e-03, -9.22077922077922078e-04,
		-8.84892884892884893e-05, 1.65927687832449737e-04,
		2.46691372741792910e-04, 2.65995589346254780e-04,
		2.61824297061500945e-04, 2.48730437344655609e-04,
		2.32721040083232098e-04, 2.16362485712365082e-04,
		2.00738858762752355e-04, 1.86267636637545172e-04,
		1.73060775917876493e-04, 1.61091705929015752e-04,
		1.50274774160908134e-04, 1.40503497391269794e-04,
		1.31668816545922806e-04, 1.23667445598253261e-04,
		1.16405271474737902e-04, 1.09798298372713369e-04,
		1.03772410422992823e-04, 9.82626078369363448e-05,
		9.32120517249503256e-05, 8.85710852478711718e-05,
		8.42963105715700223e-05, 8.03497548407791151e-05,
		7.66981345359207388e-05, 7.33122157481777809e-05,
		7.01662625163141333e-05, 6.72375633790160292e-05,
		6.93735541354588974e-04, 2.32241745182921654e-04,
		-1.41986273556691197e-05, -1.16444931672048640e-04,
		-1.50803558053048762e-04, -1.55121924918096223e-04,
		-1.46809756646465549e-04, -1.33815503867491367e-04,
		-1.19744975684254051e-04, -1.06184319207974020e-04,
		-9.37699549891194492e-05, -8.26923045588193274e-05,
		-7.29374348155221211e-05, -6.44042357721016283e-05,
		-5.69611566009369048e-05, -5.04731044303561628e-05,
		-4.48134868008882786e-05, -3.98688727717598864e-05,
		-3.55400532972042498e-05, -3.17414256609022480e-05,
		-2.83996793904174811e-05, -2.54522720634870566e-05,
		-2.28459297164724555e-05, -2.05352753106480604e-05,
		-1.84816217627666085e-05, -1.66519330021393806e-05,
		-1.50179412980119482e-05, -1.35554031379040526e-05,
		-1.22434746473858131e-05, -1.10641884811308169e-05,
		-3.54211971457743841e-04, -1.56161263945159416e-04,
		3.04465503594936410e-05, 1.30198655773242693e-04,
		1.67471106699712269e-04, 1.70222587683592569e-04,
		1.56501427608594704e-04, 1.36339170977445120e-04,
		1.14886692029825128e-04, 9.45869093034688111e-05,
		7.64498419250898258e-05, 6.07570334965197354e-05,
		4.74394299290508799e-05, 3.62757512005344297e-05,
		2.69939714979224901e-05, 1.93210938247939253e-05,
		1.30056674793963203e-05, 7.82620866744496661e-06,
		3.59257485819351583e-06, 1.44040049814251817e-07,
		-2.65396769697939116e-06, -4.91346867098485910e-06,
		-6.72739296091248287e-06, -8.17269379678657923e-06,
		-9.31304715093561232e-06, -1.02011418798016441e-05,
		-1.08805962510592880e-05, -1.13875481509603555e-05,
		-1.17519675674556414e-05, -1.19987364870944141e-05,
		3.78194199201772914e-04, 2.02471952761816167e-04,
		-6.37938506318862408e-05, -2.38598230603005903e-04,
		-3.10916256027361568e-04, -3.13680115247576316e-04,
		-2.78950273791323387e-04, -2.28564082619141374e-04,
		-1.75245280340846749e-04, -1.25544063060690348e-04,
		-8.22982872820208365e-05, -4.62860730588116458e-05,
		-1.72334302366962267e-05, 5.60690482304602267e-06,
		2.31395443148286800e-05, 3.62642745856793957e-05,
		4.58006124490188752e-05, 5.24595294959114050e-05,
		5.68396208545815266e-05, 5.94349820393104052e-05,
		6.06478527578421742e-05, 6.08023907788436497e-05,
		6.01577894539460388e-05, 5.89199657344698500e-05,
		5.72515823777593053e-05, 5.52804375585852577e-05,
		5.31063773802880170e-05, 5.08069302012325706e-05,
		4.84418647620094842e-05, 4.60568581607475370e-05,
		-6.91141397288294174e-04, -4.29976633058871912e-04,
		1.83067735980039018e-04, 6.60088147542014144e-04,
		8.75964969951185931e-04, 8.77335235958235514e-04,
		7.49369585378990637e-04, 5.63832329756980918e-04,
		3.68059319971443156e-04, 1.88464535514455599e-04,
		3.70663057664904149e-05, -8.28520220232137023e-05,
		-1.72751952869172998e-04, -2.36314873605872983e-04,
		-2.77966150694906658e-04, -3.02079514155456919e-04,
		-3.12594712643820127e-04, -3.12872558758067163e-04,
		-3.05678038466324377e-04, -2.93226470614557331e-04,
		-2.77255655582934777e-04, -2.59103928467031709e-04,
		-2.39784014396480342e-04, -2.20048260045422848e-04,
		-2.00443911094971498e-04, -1.81358692210970687e-04,
		-1.63057674478657464e-04, -1.45712672175205844e-04,
		-1.29425421983924587e-04, -1.14245691942445952e-04,
		1.92821964248775885e-03, 1.35592576302022234e-03,
		-7.17858090421302995e-04, -2.58084802575270346e-03,
		-3.49271130826168475e-03, -3.46986299340960628e-03,
		-2.82285233351310182e-03, -1.88103076404891354e-03,
		-8.89531718383947600e-04, 3.87912102631035228e-06,
		7.28688540119691412e-04, 1.26566373053457758e-03,
		1.62518158372674427e-03, 1.83203153216373172e-03,
		1.91588388990527909e-03, 1.90588846755546138e-03,
		1.82798982421825727e-03, 1.70389506421121530e-03,
		1.55097127171097686e-03, 1.38261421852276159e-03,
		1.20881424230064774e-03, 1.03676532638344962e-03,
		8.71437918068619115e-04, 7.16080155297701002e-04,
		5.72637002558129372e-04, 4.42089819465802277e-04,
		3.24724948503090564e-04, 2.20342042730246599e-04,
		1.28412898401353882e-04, 4.82005924552095464e-05}

	var BETA = [211]float64{math.NaN(),
		1.79988721413553309e-02, 5.59964911064388073e-03,
		2.88501402231132779e-03, 1.80096606761053941e-03,
		1.24753110589199202e-03, 9.22878876572938311e-04,
		7.14430421727287357e-04, 5.71787281789704872e-04,
		4.69431007606481533e-04, 3.93232835462916638e-04,
		3.34818889318297664e-04, 2.88952148495751517e-04,
		2.52211615549573284e-04, 2.22280580798883327e-04,
		1.97541838033062524e-04, 1.76836855019718004e-04,
		1.59316899661821081e-04, 1.44347930197333986e-04,
		1.31448068119965379e-04, 1.20245444949302884e-04,
		1.10449144504599392e-04, 1.01828770740567258e-04,
		9.41998224204237509e-05, 8.74130545753834437e-05,
		8.13466262162801467e-05, 7.59002269646219339e-05,
		7.09906300634153481e-05, 6.65482874842468183e-05,
		6.25146958969275078e-05, 5.88403394426251749e-05,
		-1.49282953213429172e-03, -8.78204709546389328e-04,
		-5.02916549572034614e-04, -2.94822138512746025e-04,
		-1.75463996970782828e-04, -1.04008550460816434e-04,
		-5.96141953046457895e-05, -3.12038929076098340e-05,
		-1.26089735980230047e-05, -2.42892608575730389e-07,
		8.05996165414273571e-06, 1.36507009262147391e-05,
		1.73964125472926261e-05, 1.98672978842133780e-05,
		2.14463263790822639e-05, 2.23954659232456514e-05,
		2.28967783814712629e-05, 2.30785389811177817e-05,
		2.30321976080909144e-05, 2.28236073720348722e-05,
		2.25005881105292418e-05, 2.20981015361991429e-05,
		2.16418427448103905e-05, 2.11507649256220843e-05,
		2.06388749782170737e-05, 2.01165241997081666e-05,
		1.95913450141179244e-05, 1.90689367910436740e-05,
		1.85533719641636667e-05, 1.80475722259674218e-05,
		5.52213076721292790e-04, 4.47932581552384646e-04,
		2.79520653992020589e-04, 1.52468156198446602e-04,
		6.93271105657043598e-05, 1.76258683069991397e-05,
		-1.35744996343269136e-05, -3.17972413350427135e-05,
		-4.18861861696693365e-05, -4.69004889379141029e-05,
		-4.87665447413787352e-05, -4.87010031186735069e-05,
		-4.74755620890086638e-05, -4.55813058138628452e-05,
		-4.33309644511266036e-05, -4.09230193157750364e-05,
		-3.84822638603221274e-05, -3.60857167535410501e-05,
		-3.37793306123367417e-05, -3.15888560772109621e-05,
		-2.95269561750807315e-05, -2.75978914828335759e-05,
		-2.58006174666883713e-05, -2.41308356761280200e-05,
		-2.25823509518346033e-05, -2.11479656768912971e-05,
		-1.98200638885294927e-05, -1.85909870801065077e-05,
		-1.74532699844210224e-05, -1.63997823854497997e-05,
		-4.74617796559959808e-04, -4.77864567147321487e-04,
		-3.20390228067037603e-04, -1.61105016119962282e-04,
		-4.25778101285435204e-05, 3.44571294294967503e-05,
		7.97092684075674924e-05, 1.03138236708272200e-04,
		1.12466775262204158e-04, 1.13103642108481389e-04,
		1.08651634848774268e-04, 1.01437951597661973e-04,
		9.29298396593363896e-05, 8.40293133016089978e-05,
		7.52727991349134062e-05, 6.69632521975730872e-05,
		5.92564547323194704e-05, 5.22169308826975567e-05,
		4.58539485165360646e-05, 4.01445513891486808e-05,
		3.50481730031328081e-05, 3.05157995034346659e-05,
		2.64956119950516039e-05, 2.29363633690998152e-05,
		1.97893056664021636e-05, 1.70091984636412623e-05,
		1.45547428261524004e-05, 1.23886640995878413e-05,
		1.04775876076583236e-05, 8.79179954978479373e-06,
		7.36465810572578444e-04, 8.72790805146193976e-04,
		6.22614862573135066e-04, 2.85998154194304147e-04,
		3.84737672879366102e-06, -1.87906003636971558e-04,
		-2.97603646594554535e-04, -3.45998126832656348e-04,
		-3.53382470916037712e-04, -3.35715635775048757e-04,
		-3.04321124789039809e-04, -2.66722723047612821e-04,
		-2.27654214122819527e-04, -1.89922611854562356e-04,
		-1.55058918599093870e-04, -1.23778240761873630e-04,
		-9.62926147717644187e-05, -7.25178327714425337e-05,
		-5.22070028895633801e-05, -3.50347750511900522e-05,
		-2.06489761035551757e-05, -8.70106096849767054e-06,
		1.13698686675100290e-06, 9.16426474122778849e-06,
		1.56477785428872620e-05, 2.08223629482466847e-05,
		2.48923381004595156e-05, 2.80340509574146325e-05,
		3.03987774629861915e-05, 3.21156731406700616e-05,
		-1.80182191963885708e-03, -2.43402962938042533e-03,
		-1.83422663549856802e-03, -7.62204596354009765e-04,
		2.39079475256927218e-04, 9.49266117176881141e-04,
		1.34467449701540359e-03, 1.48457495259449178e-03,
		1.44732339830617591e-03, 1.30268261285657186e-03,
		1.10351597375642682e-03, 8.86047440419791759e-04,
		6.73073208165665473e-04, 4.77603872856582378e-04,
		3.05991926358789362e-04, 1.60315694594721630e-04,
		4.00749555270613286e-05, -5.66607461635251611e-05,
		-1.32506186772982638e-04, -1.90296187989614057e-04,
		-2.32811450376937408e-04, -2.62628811464668841e-04,
		-2.82050469867598672e-04, -2.93081563192861167e-04,
		-2.97435962176316616e-04, -2.96557334239348078e-04,
		-2.91647363312090861e-04, -2.83696203837734166e-04,
		-2.73512317095673346e-04, -2.61750155806768580e-04,
		6.38585891212050914e-03, 9.62374215806377941e-03,
		7.61878061207001043e-03, 2.83219055545628054e-03,
		-2.09841352012720090e-03, -5.73826764216626498e-03,
		-7.70804244495414620e-03, -8.21011692264844401e-03,
		-7.65824520346905413e-03, -6.47209729391045177e-03,
		-4.99132412004966473e-03, -3.45612289713133280e-03,
		-2.01785580014170775e-03, -7.59430686781961401e-04,
		2.84173631523859138e-04, 1.10891667586337403e-03,
		1.72901493872728771e-03, 2.16812590802684701e-03,
		2.45357710494539735e-03, 2.61281821058334862e-03,
		2.67141039656276912e-03, 2.65203073395980430e-03,
		2.57411652877287315e-03, 2.45389126236094427e-03,
		2.30460058071795494e-03, 2.13684837686712662e-03,
		1.95896528478870911e-03, 1.77737008679454412e-03,
		1.59690280765839059e-03, 1.42111975664438546e-03}

	var GAMA = [31]float64{math.NaN(),
		6.29960524947436582e-01, 2.51984209978974633e-01,
		1.54790300415655846e-01, 1.10713062416159013e-01,
		8.57309395527394825e-02, 6.97161316958684292e-02,
		5.86085671893713576e-02, 5.04698873536310685e-02,
		4.42600580689154809e-02, 3.93720661543509966e-02,
		3.54283195924455368e-02, 3.21818857502098231e-02,
		2.94646240791157679e-02, 2.71581677112934479e-02,
		2.51768272973861779e-02, 2.34570755306078891e-02,
		2.19508390134907203e-02, 2.06210828235646240e-02,
		1.94388240897880846e-02, 1.83810633800683158e-02,
		1.74293213231963172e-02, 1.65685837786612353e-02,
		1.57865285987918445e-02, 1.50729501494095594e-02,
		1.44193250839954639e-02, 1.38184805735341786e-02,
		1.32643378994276568e-02, 1.27517121970498651e-02,
		1.22761545318762767e-02, 1.18338262398482403e-02}

	RFNU = 1.0e0 / FNU

	// OVERFLOW TEST (Z/FNU TOO SMALL)
	TEST = machine.D1MACH[1] * 1.0e+3
	AC = FNU * TEST
	if math.Abs(ZR) > AC || math.Abs(ZI) > AC {
		goto L15
	}

	ZETA1R = 2.0e0*math.Abs(math.Log(TEST)) + FNU
	ZETA1I = 0.0e0
	ZETA2R = FNU
	ZETA2I = 0.0e0
	PHIR = 1.0e0
	PHII = 0.0e0
	ARGR = 1.0e0
	ARGI = 0.0e0
	return ZR, ZI, FNU, IPMTR, TOL, PHIR, PHII, ARGR, ARGI, ZETA1R, ZETA1I, ZETA2R, ZETA2I, ASUMR, ASUMI, BSUMR, BSUMI
L15:
	ZBR = ZR * RFNU
	ZBI = ZI * RFNU
	RFNU2 = RFNU * RFNU

	// COMPUTE IN THE FOURTH QUADRANT
	FN13 = math.Pow(FNU, EX1)
	FN23 = FN13 * FN13
	RFN13 = 1.0e0 / FN13
	W2R = CONER - ZBR*ZBR + ZBI*ZBI
	W2I = CONEI - ZBR*ZBI - ZBR*ZBI
	AW2 = ZABS(W2R, W2I)
	if AW2 > 0.25e0 {
		goto L130
	}

	// POWER SERIES FOR CABS(W2) <= 0.25e0
	K = 1
	PR[1] = CONER
	PI[1] = CONEI
	SUMAR = GAMA[1]
	SUMAI = ZEROI
	AP[1] = 1.0e0
	if AW2 < TOL {
		goto L20
	}
	for K = 2; K <= 30; K++ {
		PR[K] = PR[K-1]*W2R - PI[K-1]*W2I
		PI[K] = PR[K-1]*W2I + PI[K-1]*W2R
		SUMAR = SUMAR + PR[K]*GAMA[K]
		SUMAI = SUMAI + PI[K]*GAMA[K]
		AP[K] = AP[K-1] * AW2
		if AP[K] < TOL {
			goto L20
		}
	}
	K = 30
L20:
	KMAX = K
	ZETAR = W2R*SUMAR - W2I*SUMAI
	ZETAI = W2R*SUMAI + W2I*SUMAR
	ARGR = ZETAR * FN23
	ARGI = ZETAI * FN23
	ZAR, ZAI = ZSQRT(SUMAR, SUMAI)
	STR, STI = ZSQRT(W2R, W2I)
	ZETA2R = STR * FNU
	ZETA2I = STI * FNU
	STR = CONER + EX2*(ZETAR*ZAR-ZETAI*ZAI)
	STI = CONEI + EX2*(ZETAR*ZAI+ZETAI*ZAR)
	ZETA1R = STR*ZETA2R - STI*ZETA2I
	ZETA1I = STR*ZETA2I + STI*ZETA2R
	ZAR = ZAR + ZAR
	ZAI = ZAI + ZAI
	STR, STI = ZSQRT(ZAR, ZAI)
	PHIR = STR * RFN13
	PHII = STI * RFN13
	if IPMTR == 1 {
		goto L120
	}

	// SUM SERIES FOR ASUM AND BSUM
	SUMBR = ZEROR
	SUMBI = ZEROI
	for K = 1; K <= KMAX; K++ {
		SUMBR = SUMBR + PR[K]*BETA[K]
		SUMBI = SUMBI + PI[K]*BETA[K]
	}
	ASUMR = ZEROR
	ASUMI = ZEROI
	BSUMR = SUMBR
	BSUMI = SUMBI
	L1 = 0
	L2 = 30
	BTOL = TOL * (math.Abs(BSUMR) + math.Abs(BSUMI))
	ATOL = TOL
	PP = 1.0e0
	IAS = 0
	IBS = 0
	if RFNU2 < TOL {
		goto L110
	}
	for IS = 2; IS <= 7; IS++ {
		ATOL = ATOL / RFNU2
		PP = PP * RFNU2
		if IAS == 1 {
			goto L60
		}
		SUMAR = ZEROR
		SUMAI = ZEROI
		for K = 1; K <= KMAX; K++ {
			M = L1 + K
			SUMAR = SUMAR + PR[K]*ALFA[M]
			SUMAI = SUMAI + PI[K]*ALFA[M]
			if AP[K] < ATOL {
				goto L50
			}
		}
	L50:
		ASUMR = ASUMR + SUMAR*PP
		ASUMI = ASUMI + SUMAI*PP
		if PP < TOL {
			IAS = 1
		}
	L60:
		if IBS == 1 {
			goto L90
		}
		SUMBR = ZEROR
		SUMBI = ZEROI
		for K = 1; K <= KMAX; K++ {
			M = L2 + K
			SUMBR = SUMBR + PR[K]*BETA[M]
			SUMBI = SUMBI + PI[K]*BETA[M]
			if AP[K] < ATOL {
				goto L80
			}
		}
	L80:
		BSUMR = BSUMR + SUMBR*PP
		BSUMI = BSUMI + SUMBI*PP
		if PP < BTOL {
			IBS = 1
		}
	L90:
		if IAS == 1 && IBS == 1 {
			goto L110
		}
		L1 = L1 + 30
		L2 = L2 + 30
	}
L110:
	ASUMR = ASUMR + CONER
	PP = RFNU * RFN13
	BSUMR = BSUMR * PP
	BSUMI = BSUMI * PP
L120:
	return ZR, ZI, FNU, IPMTR, TOL, PHIR, PHII, ARGR, ARGI, ZETA1R, ZETA1I, ZETA2R, ZETA2I, ASUMR, ASUMI, BSUMR, BSUMI

	// CABS(W2) > 0.25e0
L130:
	WR, WI = ZSQRT(W2R, W2I)
	if WR < 0.0e0 {
		WR = 0.0e0
	}
	if WI < 0.0e0 {
		WI = 0.0e0
	}
	STR = CONER + WR
	STI = WI
	ZAR, ZAI = ZDIV(STR, STI, ZBR, ZBI)
	ZCR, ZCI = ZLOG(ZAR, ZAI)
	if ZCI < 0.0e0 {
		ZCI = 0.0e0
	}
	if ZCI > HPI {
		ZCI = HPI
	}
	if ZCR < 0.0e0 {
		ZCR = 0.0e0
	}
	ZTHR = (ZCR - WR) * 1.5e0
	ZTHI = (ZCI - WI) * 1.5e0
	ZETA1R = ZCR * FNU
	ZETA1I = ZCI * FNU
	ZETA2R = WR * FNU
	ZETA2I = WI * FNU
	AZTH = ZABS(ZTHR, ZTHI)
	ANG = THPI
	if ZTHR >= 0.0e0 && ZTHI < 0.0e0 {
		goto L140
	}
	ANG = HPI
	if ZTHR == 0.0e0 {
		goto L140
	}
	ANG = math.Atan(ZTHI / ZTHR)
	if ZTHR < 0.0e0 {
		ANG = ANG + GPI
	}
L140:
	PP = math.Pow(AZTH, EX2)
	ANG = ANG * EX2
	ZETAR = PP * math.Cos(ANG)
	ZETAI = PP * math.Sin(ANG)
	if ZETAI < 0.0e0 {
		ZETAI = 0.0e0
	}
	ARGR = ZETAR * FN23
	ARGI = ZETAI * FN23
	RTZTR, RTZTI = ZDIV(ZTHR, ZTHI, ZETAR, ZETAI)
	ZAR, ZAI = ZDIV(RTZTR, RTZTI, WR, WI)
	TZAR = ZAR + ZAR
	TZAI = ZAI + ZAI
	STR, STI = ZSQRT(TZAR, TZAI)
	PHIR = STR * RFN13
	PHII = STI * RFN13
	if IPMTR == 1 {
		goto L120
	}
	RAW = 1.0e0 / math.Sqrt(AW2)
	STR = WR * RAW
	STI = -WI * RAW
	TFNR = STR * RFNU * RAW
	TFNI = STI * RFNU * RAW
	RAZTH = 1.0e0 / AZTH
	STR = ZTHR * RAZTH
	STI = -ZTHI * RAZTH
	RZTHR = STR * RAZTH * RFNU
	RZTHI = STI * RAZTH * RFNU
	ZCR = RZTHR * AR[2]
	ZCI = RZTHI * AR[2]
	RAW2 = 1.0e0 / AW2
	STR = W2R * RAW2
	STI = -W2I * RAW2
	T2R = STR * RAW2
	T2I = STI * RAW2
	STR = T2R*C[2] + C[3]
	STI = T2I * C[2]
	UPR[2] = STR*TFNR - STI*TFNI
	UPI[2] = STR*TFNI + STI*TFNR
	BSUMR = UPR[2] + ZCR
	BSUMI = UPI[2] + ZCI
	ASUMR = ZEROR
	ASUMI = ZEROI
	if RFNU < TOL {
		goto L220
	}
	PRZTHR = RZTHR
	PRZTHI = RZTHI
	PTFNR = TFNR
	PTFNI = TFNI
	UPR[1] = CONER
	UPI[1] = CONEI
	PP = 1.0e0
	BTOL = TOL * (math.Abs(BSUMR) + math.Abs(BSUMI))
	KS = 0
	KP1 = 2
	L = 3
	IAS = 0
	IBS = 0
	for LR = 2; LR < 12; LR = LR + 2 {
		LRP1 = LR + 1

		// COMPUTE TWO ADDITIONAL CR, DR, AND UP FOR TWO MORE TERMS IN
		// NEXT SUMA AND SUMB
		for K = LR; K <= LRP1; K++ {
			KS = KS + 1
			KP1 = KP1 + 1
			L = L + 1
			ZAR = C[L]
			ZAI = ZEROI
			for J = 2; J <= KP1; J++ {
				L = L + 1
				STR = ZAR*T2R - T2I*ZAI + C[L]
				ZAI = ZAR*T2I + ZAI*T2R
				ZAR = STR
			}
			STR = PTFNR*TFNR - PTFNI*TFNI
			PTFNI = PTFNR*TFNI + PTFNI*TFNR
			PTFNR = STR
			UPR[KP1] = PTFNR*ZAR - PTFNI*ZAI
			UPI[KP1] = PTFNI*ZAR + PTFNR*ZAI
			CRR[KS] = PRZTHR * BR[KS+1]
			CRI[KS] = PRZTHI * BR[KS+1]
			STR = PRZTHR*RZTHR - PRZTHI*RZTHI
			PRZTHI = PRZTHR*RZTHI + PRZTHI*RZTHR
			PRZTHR = STR
			DRR[KS] = PRZTHR * AR[KS+2]
			DRI[KS] = PRZTHI * AR[KS+2]
		}
		PP = PP * RFNU2
		if IAS == 1 {
			goto L180
		}
		SUMAR = UPR[LRP1]
		SUMAI = UPI[LRP1]
		JU = LRP1
		for JR = 1; JR <= LR; JR++ {
			JU = JU - 1
			SUMAR = SUMAR + CRR[JR]*UPR[JU] - CRI[JR]*UPI[JU]
			SUMAI = SUMAI + CRR[JR]*UPI[JU] + CRI[JR]*UPR[JU]
		}
		ASUMR = ASUMR + SUMAR
		ASUMI = ASUMI + SUMAI
		TEST = math.Abs(SUMAR) + math.Abs(SUMAI)
		if PP < TOL && TEST < TOL {
			IAS = 1
		}
	L180:
		if IBS == 1 {
			goto L200
		}
		SUMBR = UPR[LR+2] + UPR[LRP1]*ZCR - UPI[LRP1]*ZCI
		SUMBI = UPI[LR+2] + UPR[LRP1]*ZCI + UPI[LRP1]*ZCR
		JU = LRP1
		for JR = 1; JR <= LR; JR++ {
			JU = JU - 1
			SUMBR = SUMBR + DRR[JR]*UPR[JU] - DRI[JR]*UPI[JU]
			SUMBI = SUMBI + DRR[JR]*UPI[JU] + DRI[JR]*UPR[JU]
		}
		BSUMR = BSUMR + SUMBR
		BSUMI = BSUMI + SUMBI
		TEST = math.Abs(SUMBR) + math.Abs(SUMBI)
		if PP < BTOL && TEST < BTOL {
			IBS = 1
		}
	L200:
		if IAS == 1 && IBS == 1 {
			goto L220
		}
	}
L220:
	ASUMR = ASUMR + CONER
	STR = -BSUMR * RFN13
	STI = -BSUMI * RFN13
	BSUMR, BSUMI = ZDIV(STR, STI, RTZTR, RTZTI)
	goto L120
}

// ZUOIK COMPUTES THE LEADING TERMS OF THE UNIFORM ASYMPTOTIC
// EXPANSIONS FOR THE I AND K FUNCTIONS AND COMPARES THEM
// (IN LOGARITHMIC FORM) TO ALIM AND ELIM FOR OVER AND UNDERFLOW
// WHERE ALIM < ELIM. if THE MAGNITUDE, BASED ON THE LEADING
// EXPONENTIAL, IS LESS THAN ALIM OR GREATER THAN -ALIM, THEN
// THE RESULT IS ON SCALE. if NOT, THEN A REFINED TEST USING OTHER
// MULTIPLIERS (IN LOGARITHMIC FORM) IS MADE BASED ON ELIM. HERE
// EXP(-ELIM)=SMALLEST MACHINE NUMBER*1.0E+3 AND EXP(-ALIM)=
// EXP(-ELIM)/TOL
//
// IKFLG=1 MEANS THE I SEQUENCE IS TESTED
//   =2 MEANS THE K SEQUENCE IS TESTED
// NUF = 0 MEANS THE LAST MEMBER OF THE SEQUENCE IS ON SCALE
//  =-1 MEANS AN OVERFLOW WOULD OCCUR
// IKFLG=1 AND NUF > 0 MEANS THE LAST NUF Y VALUES WERE SET TO ZERO
//      THE FIRST N-NUF VALUES MUST BE SET BY ANOTHER ROUTINE
// IKFLG=2 AND NUF == N MEANS ALL Y VALUES WERE SET TO ZERO
// IKFLG=2 AND 0 < NUF < N NOT CONSIDERED. Y MUST BE SET BY
//      ANOTHER ROUTINE
func ZUOIK(ZR float64, ZI float64, FNU float64, KODE int, IKFLG int, N int, YR []float64, YI []float64, NUF int, TOL float64, ELIM float64, ALIM float64) (
	float64, float64, float64, int, int, int, []float64, []float64, int, float64, float64, float64) {

	const (
		ZEROR = 0.0e0
		ZEROI = 0.0e0
		AIC   = 1.265512123484645396e+00
	)

	var AARG, APHI, ARGI, ARGR, ASUMI, ASUMR, ASCLE, AX, AY, BSUMI, BSUMR, CZI, CZR, FNN,
		GNN, GNU, PHII, PHIR, RCZ, STR, STI, SUMI, SUMR, ZBI, ZBR, ZETA1I, ZETA1R, ZETA2I, ZETA2R,
		ZNI, ZNR, ZRI, ZRR float64
	var I, IFORM, INIT, NN, NW int

	var CWRKR = []float64{math.NaN(), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
	var CWRKI = []float64{math.NaN(), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}

	NUF = 0
	NN = N
	ZRR = ZR
	ZRI = ZI
	if ZR >= 0.0e0 {
		goto L10
	}
	ZRR = -ZR
	ZRI = -ZI
L10:
	ZBR = ZRR
	ZBI = ZRI
	AX = math.Abs(ZR) * 1.7321e0
	AY = math.Abs(ZI)
	IFORM = 1
	if AY > AX {
		IFORM = 2
	}
	GNU = math.Max(FNU, 1.0e0)
	if IKFLG == 1 {
		goto L20
	}
	FNN = float64(float32(NN))
	GNN = FNU + FNN - 1.0e0
	GNU = math.Max(GNN, FNN)
L20:
	// ONLY THE MAGNITUDE OF ARG AND PHI ARE NEEDED ALONG WITH THE
	// REAL PARTS OF ZETA1, ZETA2 AND ZB. NO ATTEMPT IS MADE TO GET
	// THE SIGN OF THE IMAGINARY PART CORRECT.
	if IFORM == 2 {
		goto L30
	}
	INIT = 0
	ZRR, ZRI, GNU, IKFLG, _, TOL, INIT, PHIR, PHII, ZETA1R, ZETA1I, ZETA2R, ZETA2I, SUMR, SUMI, CWRKR, CWRKI = ZUNIK(ZRR, ZRI, GNU, IKFLG, 1, TOL, INIT, PHIR, PHII, ZETA1R, ZETA1I, ZETA2R, ZETA2I, SUMR, SUMI, CWRKR, CWRKI)
	CZR = -ZETA1R + ZETA2R
	CZI = -ZETA1I + ZETA2I
	goto L50
L30:
	ZNR = ZRI
	ZNI = -ZRR
	if ZI > 0.0e0 {
		goto L40
	}
	ZNR = -ZNR
L40:
	ZNR, ZNI, GNU, _, TOL, PHIR, PHII, ARGR, ARGI, ZETA1R, ZETA1I, ZETA2R, ZETA2I, ASUMR, ASUMI, BSUMR, BSUMI = ZUNHJ(ZNR, ZNI, GNU, 1, TOL, PHIR, PHII, ARGR, ARGI, ZETA1R, ZETA1I, ZETA2R, ZETA2I, ASUMR, ASUMI, BSUMR, BSUMI)
	CZR = -ZETA1R + ZETA2R
	CZI = -ZETA1I + ZETA2I
	AARG = ZABS(ARGR, ARGI)
L50:
	if KODE == 1 {
		goto L60
	}
	CZR = CZR - ZBR
	CZI = CZI - ZBI
L60:
	if IKFLG == 1 {
		goto L70
	}
	CZR = -CZR
	CZI = -CZI
L70:
	APHI = ZABS(PHIR, PHII)
	RCZ = CZR

	// OVERFLOW TEST
	if RCZ > ELIM {
		goto L210
	}
	if RCZ < ALIM {
		goto L80
	}
	RCZ = RCZ + math.Log(APHI)
	if IFORM == 2 {
		RCZ = RCZ - 0.25e0*math.Log(AARG) - AIC
	}
	if RCZ > ELIM {
		goto L210
	}
	goto L130
L80:

	// UNDERFLOW TEST
	if RCZ < -ELIM {
		goto L90
	}
	if RCZ > -ALIM {
		goto L130
	}
	RCZ = RCZ + math.Log(APHI)
	if IFORM == 2 {
		RCZ = RCZ - 0.25e0*math.Log(AARG) - AIC
	}
	if RCZ > -ELIM {
		goto L110
	}
L90:
	for I = 1; I <= NN; I++ {
		YR[I] = ZEROR
		YI[I] = ZEROI
	}
	NUF = NN
	return ZR, ZI, FNU, KODE, IKFLG, N, YR, YI, NUF, TOL, ELIM, ALIM
L110:
	ASCLE = 1000.0e0 * machine.D1MACH[1] / TOL
	STR, STI = ZLOG(PHIR, PHII)
	CZR = CZR + STR
	CZI = CZI + STI
	if IFORM == 1 {
		goto L120
	}
	STR, STI = ZLOG(ARGR, ARGI)
	CZR = CZR - 0.25e0*STR - AIC
	CZI = CZI - 0.25e0*STI
L120:
	AX = math.Exp(RCZ) / TOL
	AY = CZI
	CZR = AX * math.Cos(AY)
	CZI = AX * math.Sin(AY)
	CZR, CZI, NW, ASCLE, TOL = ZUCHK(CZR, CZI, NW, ASCLE, TOL)
	if NW != 0 {
		goto L90
	}
L130:
	if IKFLG == 2 {
		return ZR, ZI, FNU, KODE, IKFLG, N, YR, YI, NUF, TOL, ELIM, ALIM
	}
	if N == 1 {
		return ZR, ZI, FNU, KODE, IKFLG, N, YR, YI, NUF, TOL, ELIM, ALIM
	}

	// SET UNDERFLOWS ON I SEQUENCE
L140:
	GNU = FNU + float64(float32(NN-1))
	if IFORM == 2 {
		goto L150
	}
	INIT = 0
	ZRR, ZRI, GNU, IKFLG, _, TOL, INIT, PHIR, PHII, ZETA1R, ZETA1I, ZETA2R, ZETA2I, SUMR, SUMI, CWRKR, CWRKI = ZUNIK(ZRR, ZRI, GNU, IKFLG, 1, TOL, INIT, PHIR, PHII, ZETA1R, ZETA1I, ZETA2R, ZETA2I, SUMR, SUMI, CWRKR, CWRKI)
	CZR = -ZETA1R + ZETA2R
	CZI = -ZETA1I + ZETA2I
	goto L160
L150:
	ZNR, ZNI, GNU, _, TOL, PHIR, PHII, ARGR, ARGI, ZETA1R, ZETA1I, ZETA2R, ZETA2I, ASUMR, ASUMI, BSUMR, BSUMI = ZUNHJ(ZNR, ZNI, GNU, 1, TOL, PHIR, PHII, ARGR, ARGI, ZETA1R, ZETA1I, ZETA2R, ZETA2I, ASUMR, ASUMI, BSUMR, BSUMI)
	CZR = -ZETA1R + ZETA2R
	CZI = -ZETA1I + ZETA2I
	AARG = ZABS(ARGR, ARGI)
L160:
	if KODE == 1 {
		goto L170
	}
	CZR = CZR - ZBR
	CZI = CZI - ZBI
L170:
	APHI = ZABS(PHIR, PHII)
	RCZ = CZR
	if RCZ < -ELIM {
		goto L180
	}
	if RCZ > -ALIM {
		return ZR, ZI, FNU, KODE, IKFLG, N, YR, YI, NUF, TOL, ELIM, ALIM
	}
	RCZ = RCZ + math.Log(APHI)
	if IFORM == 2 {
		RCZ = RCZ - 0.25e0*math.Log(AARG) - AIC
	}
	if RCZ > -ELIM {
		goto L190
	}
L180:
	YR[NN] = ZEROR
	YI[NN] = ZEROI
	NN = NN - 1
	NUF = NUF + 1
	if NN == 0 {
		return ZR, ZI, FNU, KODE, IKFLG, N, YR, YI, NUF, TOL, ELIM, ALIM
	}
	goto L140
L190:
	ASCLE = 1000.0e0 * machine.D1MACH[1] / TOL
	STR, STI = ZLOG(PHIR, PHII)
	CZR = CZR + STR
	CZI = CZI + STI
	if IFORM == 1 {
		goto L200
	}
	STR, STI = ZLOG(ARGR, ARGI)
	CZR = CZR - 0.25e0*STR - AIC
	CZI = CZI - 0.25e0*STI
L200:
	AX = math.Exp(RCZ) / TOL
	AY = CZI
	CZR = AX * math.Cos(AY)
	CZI = AX * math.Sin(AY)
	CZR, CZI, NW, ASCLE, TOL = ZUCHK(CZR, CZI, NW, ASCLE, TOL)
	if NW != 0 {
		goto L180
	}
	return ZR, ZI, FNU, KODE, IKFLG, N, YR, YI, NUF, TOL, ELIM, ALIM
L210:
	NUF = -1
	return ZR, ZI, FNU, KODE, IKFLG, N, YR, YI, NUF, TOL, ELIM, ALIM
}
